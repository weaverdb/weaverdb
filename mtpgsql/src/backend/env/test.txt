# 1 "WeaverConnection.c"
 
# 13

# 1 "/usr/include/stdlib.h"
 
# 21
 
# 25

 
 


# 32

#ident	"@(#)stdlib.h	1.56	07/05/23 SMI"

# 1 "/usr/include/iso/stdlib_iso.h"
 
# 22
 
# 26

 
 


 
# 42

# 45

#ident	"@(#)stdlib_iso.h	1.13	05/08/18 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 29

#ident	"@(#)feature_tests.h	1.26	06/09/19 SMI"

# 1 "/usr/include/sys/ccompile.h"
 
# 22
 
# 26

# 29

#ident	"@(#)ccompile.h	1.3	05/06/08 SMI"

 
# 36

# 40

 
# 50

# 105

# 107

# 109

 
# 113

# 121


# 126

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 29

#ident	"@(#)isa_defs.h	1.32	07/01/10 SMI"

 
# 210

# 214

 
# 359

 
# 366

 
# 376

 
# 397

 
# 406

 
# 437

 
# 446

# 448

 
# 459

# 463

 
# 470

# 474

# 478

# 34 "/usr/include/sys/feature_tests.h"

# 38

 
# 52

 
# 83

# 87

 
# 132

# 139

 
# 143

# 147

 
# 187

 
# 215

 
# 266

 
# 300

 
# 324

 
# 344

 
# 360

 
# 373

 
# 379

 
# 385

 
# 391

# 395

# 49 "/usr/include/iso/stdlib_iso.h"

# 53

# 55
extern unsigned char	__ctype[];
# 61

# 65

typedef	struct {
	int	quot;
	int	rem;
} div_t;

typedef struct {
	long	quot;
	long	rem;
} ldiv_t;

# 79
typedef unsigned long	size_t;		 
# 84

# 92

# 96

 
# 114
typedef	int	wchar_t;
# 120

# 122

extern void abort(void) ;
extern int abs(int);
extern int atexit(void (*)(void));
extern double atof(const char *);
extern int atoi(const char *);
extern long int atol(const char *);
extern void *bsearch(const void *, const void *, size_t, size_t,
	int (*)(const void *, const void *));
# 137
extern void *calloc(size_t, size_t);
extern div_t div(int, int);
extern void exit(int)
	;
extern void free(void *);
extern char *getenv(const char *);
extern long int labs(long);
extern ldiv_t ldiv(long, long);
extern void *malloc(size_t);
extern int mblen(const char *, size_t);
extern size_t mbstowcs(wchar_t *, const char *,
	size_t);
extern int mbtowc(wchar_t *, const char *, size_t);
extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));
# 156
extern int rand(void);
extern void *realloc(void *, size_t);
extern void srand(unsigned int);
extern double strtod(const char *, char **);
extern long int strtol(const char *, char **, int);
extern unsigned long int strtoul(const char *,
	char **, int);
extern int system(const char *);
extern int wctomb(char *, wchar_t);
extern size_t wcstombs(char *, const wchar_t *,
	size_t);

# 174

# 207

# 211

# 215

# 1 "/usr/include/iso/stdlib_c99.h"
 
# 22
 
# 26

 
# 37

# 40

#ident	"@(#)stdlib_c99.h	1.3	05/06/08 SMI"

# 46

 
# 54

# 56
typedef struct {
	long long	quot;
	long long	rem;
} lldiv_t;
# 61

# 63

# 66

extern void _Exit(int);
extern float strtof(const char *, char **);
extern long double strtold(const char *, char **);

# 72
extern long long atoll(const char *);
extern long long llabs(long long);
extern lldiv_t lldiv(long long, long long);
extern long long strtoll(const char *, char **,
	int);
extern unsigned long long strtoull(const char *,
	char **, int);
# 80

# 82

# 102

# 106

# 37 "/usr/include/stdlib.h"

# 41

 
# 79

# 83

# 86
typedef	unsigned int	uid_t;		 
# 88

# 90

 
# 103

 
# 106

#pragma	redefine_extname	mkstemp64	mkstemp
#pragma	redefine_extname	mkstemps64	mkstemps
# 114

# 116

# 120
extern int rand_r(unsigned int *);
# 122

extern void _exithandle(void);

# 128
extern double drand48(void);
extern double erand48(unsigned short *);
extern long jrand48(unsigned short *);
extern void lcong48(unsigned short *);
extern long lrand48(void);
extern long mrand48(void);
extern long nrand48(unsigned short *);
extern unsigned short *seed48(unsigned short *);
extern void srand48(long);
extern int putenv(char *);
extern void setkey(const char *);
# 140

 
# 155
typedef long	ssize_t;	 
# 160

extern void swab(const char *, char *, ssize_t);
# 163

# 167
extern int	mkstemp(char *);
# 169
extern int	mkstemps(char *, int);
# 172

# 175
extern int	mkstemp64(char *);
# 177
extern int	mkstemps64(char *, int);
# 180

# 184
extern long a64l(const char *);
extern char *ecvt(double, int, int *, int *);
extern char *fcvt(double, int, int *, int *);
extern char *gcvt(double, int, char *);
extern int getsubopt(char **, char *const *, char **);
extern int  grantpt(int);
extern char *initstate(unsigned, char *, size_t);
extern char *l64a(long);
extern char *mktemp(char *);
extern char *ptsname(int);
extern long random(void);
extern char *realpath(const char *, char *);
extern char *setstate(const char *);
extern void srandom(unsigned);
extern int  unlockpt(int);
 
# 201
extern int ttyslot(void);
extern void *valloc(size_t);
# 205

# 209
extern int posix_openpt(int);
extern int setenv(const char *, const char *, int);
extern int unsetenv(const char *);
# 213

# 216
extern void closefrom(int);
extern int dup2(int, int);
extern int fdwalk(int (*)(void *, int), void *);
extern char *qecvt(long double, int, int *, int *);
extern char *qfcvt(long double, int, int *, int *);
extern char *qgcvt(long double, int, char *);
extern char *getcwd(char *, size_t);
extern const char *getexecname(void);
extern char *getlogin(void);
extern int getopt(int, char *const *, const char *);
extern char *optarg;
extern int optind, opterr, optopt;
extern char *getpass(const char *);
extern char *getpassphrase(const char *);
extern int getpw(uid_t, char *);
extern int isatty(int);
extern void *memalign(size_t, size_t);
extern char *ttyname(int);
extern char *mkdtemp(char *);

# 237
extern char *lltostr(long long, char *);
extern char *ulltostr(unsigned long long, char *);
# 240

# 242

# 344

# 348

# 1 "/usr/include/unistd.h"
 
# 21
 
 


 
# 29

# 32

#ident	"@(#)unistd.h	1.80	06/06/16 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 36 "/usr/include/unistd.h"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 32

#ident	"@(#)types.h	1.91	07/06/07 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 37 "/usr/include/sys/types.h"

 
# 1 "/usr/include/sys/machtypes.h"
 
# 22
 
# 26

 
 


# 33

#ident	"@(#)machtypes.h	1.15	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 37 "/usr/include/sys/machtypes.h"

# 41

 
# 47

# 50

typedef	struct	_label_t { long val[2]; } label_t;

# 54

typedef	unsigned char	lock_t;		 

# 60

# 42 "/usr/include/sys/types.h"

 
# 1 "/usr/include/sys/int_types.h"
 
# 22
 
# 26

# 29

#ident	"@(#)int_types.h	1.11	05/06/08 SMI"

 
# 54

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 56 "/usr/include/sys/int_types.h"

# 60

 
# 75
typedef char			int8_t;
# 81
typedef short			int16_t;
typedef int			int32_t;
# 85
typedef long			int64_t;
# 92

typedef unsigned char		uint8_t;
typedef unsigned short		uint16_t;
typedef unsigned int		uint32_t;
# 97
typedef unsigned long		uint64_t;
# 103

 
# 109
typedef int64_t			intmax_t;
typedef uint64_t		uintmax_t;
# 115

 
# 122
typedef long			intptr_t;
typedef unsigned long		uintptr_t;
# 128

 
# 134
typedef char			int_fast8_t;
# 140
typedef int			int_fast16_t;
typedef int			int_fast32_t;
# 143
typedef long			int_fast64_t;
# 149

typedef unsigned char		uint_fast8_t;
typedef unsigned int		uint_fast16_t;
typedef unsigned int		uint_fast32_t;
# 154
typedef unsigned long		uint_fast64_t;
# 160

 
# 166
typedef char			int_least8_t;
# 172
typedef short			int_least16_t;
typedef int			int_least32_t;
# 175
typedef long			int_least64_t;
# 181

typedef unsigned char		uint_least8_t;
typedef unsigned short		uint_least16_t;
typedef unsigned int		uint_least32_t;
# 186
typedef unsigned long		uint_least64_t;
# 192

# 196

# 55 "/usr/include/sys/types.h"

# 59

# 63

 
# 70
typedef	long long		longlong_t;
typedef	unsigned long long	u_longlong_t;
# 83

 
# 90
typedef int32_t		t_scalar_t;
typedef uint32_t	t_uscalar_t;
# 96

 
# 100
typedef	unsigned char	uchar_t;
typedef	unsigned short	ushort_t;
typedef	unsigned int	uint_t;
typedef	unsigned long	ulong_t;

typedef	char		*caddr_t;	 
typedef	long		daddr_t;	 
typedef	short		cnt_t;		 

# 112
typedef	long	ptrdiff_t;		 
# 117

 
# 121
typedef	ulong_t		pfn_t;		 
typedef	ulong_t		pgcnt_t;	 
typedef	long		spgcnt_t;	 

typedef	uchar_t		use_t;		 
typedef	short		sysid_t;
typedef	short		index_t;
typedef void		*timeout_id_t;	 
typedef void		*bufcall_id_t;	 

 
# 141

# 143
typedef long		off_t;		 
# 147

# 150
typedef	off_t		off64_t;	 
# 155

# 157

# 159
typedef ulong_t		ino_t;		 
typedef long		blkcnt_t;	 
typedef ulong_t		fsblkcnt_t;	 
typedef ulong_t		fsfilcnt_t;	 
# 169

# 172
typedef	ino_t		ino64_t;	 
typedef	blkcnt_t	blkcnt64_t;	 
typedef	fsblkcnt_t	fsblkcnt64_t;	 
typedef	fsfilcnt_t	fsfilcnt64_t;	 
# 183

# 185
typedef	int		blksize_t;	 
# 189

# 193
typedef enum { B_FALSE, B_TRUE } boolean_t;
# 195

 
# 209
typedef int64_t		pad64_t;
typedef	uint64_t	upad64_t;
# 222

typedef union {
	long double	_q;
	int32_t		_l[4];
} pad128_t;

typedef union {
	long double	_q;
	uint32_t	_l[4];
} upad128_t;

typedef	longlong_t	offset_t;
typedef	u_longlong_t	u_offset_t;
typedef u_longlong_t	len_t;
typedef	u_longlong_t	diskaddr_t;
# 240

 
# 255

# 257
typedef union {
	offset_t	_f;	 
	struct {
		int32_t	_u;	 
		int32_t	_l;	 
	} _p;
} lloff_t;
# 265

# 275

# 277
typedef union {
	longlong_t	_f;	 
	struct {
		int32_t	_u;	 
		int32_t	_l;	 
	} _p;
} lldaddr_t;
# 285

typedef uint_t k_fltset_t;	 

 
# 298
typedef int		id_t;
# 302

typedef id_t		lgrp_id_t;	 

 
# 309
typedef uint_t		useconds_t;	 

# 313
typedef long	suseconds_t;	 
# 315

 
# 320
typedef uint_t	major_t;	 
typedef uint_t	minor_t;	 
# 326

 
# 330
typedef short	pri_t;

 
# 336
typedef ushort_t	cpu_flag_t;

 
# 349
typedef	ushort_t o_mode_t;		 
typedef short	o_dev_t;		 
typedef	ushort_t o_uid_t;		 
typedef	o_uid_t	o_gid_t;		 
typedef	short	o_nlink_t;		 
typedef short	o_pid_t;		 
typedef ushort_t o_ino_t;		 


 
# 361
typedef	int	key_t;			 
# 363
typedef	uint_t	mode_t;			 
# 367

# 372

typedef	uid_t	gid_t;			 

typedef id_t    taskid_t;
typedef id_t    projid_t;
typedef	id_t	poolid_t;
typedef id_t	zoneid_t;
typedef id_t	ctid_t;

 
# 386
typedef	uint_t	pthread_t;	 
typedef	uint_t	pthread_key_t;	 

 
# 394

typedef	struct _pthread_mutex {		 
	struct {
		uint16_t	__pthread_mutex_flag1;
		uint8_t		__pthread_mutex_flag2;
		uint8_t		__pthread_mutex_ceiling;
		uint16_t 	__pthread_mutex_type;
		uint16_t 	__pthread_mutex_magic;
	} __pthread_mutex_flags;
	union {
		struct {
			uint8_t	__pthread_mutex_pad[8];
		} __pthread_mutex_lock64;
		struct {
			uint32_t __pthread_ownerpid;
			uint32_t __pthread_lockword;
		} __pthread_mutex_lock32;
		upad64_t __pthread_mutex_owner64;
	} __pthread_mutex_lock;
	upad64_t __pthread_mutex_data;
} pthread_mutex_t;

typedef	struct _pthread_cond {		 
	struct {
		uint8_t		__pthread_cond_flag[4];
		uint16_t 	__pthread_cond_type;
		uint16_t 	__pthread_cond_magic;
	} __pthread_cond_flags;
	upad64_t __pthread_cond_data;
} pthread_cond_t;

 
# 428
typedef	struct _pthread_rwlock {	 
	int32_t		__pthread_rwlock_readers;
	uint16_t	__pthread_rwlock_type;
	uint16_t	__pthread_rwlock_magic;
	pthread_mutex_t	__pthread_rwlock_mutex;
	pthread_cond_t	__pthread_rwlock_readercv;
	pthread_cond_t	__pthread_rwlock_writercv;
} pthread_rwlock_t;

 
# 440
typedef struct {
	uint32_t	__pthread_barrier_count;
	uint32_t	__pthread_barrier_current;
	upad64_t	__pthread_barrier_cycle;
	upad64_t	__pthread_barrier_reserved;
	pthread_mutex_t	__pthread_barrier_lock;
	pthread_cond_t	__pthread_barrier_cond;
} pthread_barrier_t;

typedef	pthread_mutex_t	pthread_spinlock_t;

 
# 454
typedef struct _pthread_attr {
	void	*__pthread_attrp;
} pthread_attr_t;

 
# 461
typedef struct _pthread_mutexattr {
	void	*__pthread_mutexattrp;
} pthread_mutexattr_t;

 
# 468
typedef struct _pthread_condattr {
	void	*__pthread_condattrp;
} pthread_condattr_t;

 
# 475
typedef	struct _once {
	upad64_t	__pthread_once_pad[4];
} pthread_once_t;

 
# 483
typedef struct _pthread_rwlockattr {
	void	*__pthread_rwlockattrp;
} pthread_rwlockattr_t;

 
# 491
typedef struct {
	void	*__pthread_barrierattrp;
} pthread_barrierattr_t;

typedef ulong_t	dev_t;			 

# 498
typedef	uint_t nlink_t;			 
typedef int	pid_t;			 
# 504

# 513

# 522

# 525
typedef	long		time_t;	 
# 527

# 530
typedef	long		clock_t;  
# 532

# 535
typedef	int	clockid_t;	 
# 537

# 540
typedef	int	timer_t;	 
# 542

# 544

 
typedef	unsigned char	unchar;
typedef	unsigned short	ushort;
typedef	unsigned int	uint;
typedef	unsigned long	ulong;
 

# 575

# 577

 
# 585

# 592

 
# 599

 
typedef unsigned char	u_char;
typedef unsigned short	u_short;
typedef unsigned int	u_int;
typedef unsigned long	u_long;
typedef struct _quad { int val[2]; } quad_t;	 
typedef quad_t		quad;			 
 

 
# 1 "/usr/include/sys/select.h"
 
# 22
 
# 26

 
 

 
# 39

# 42

#ident	"@(#)select.h	1.21	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 46 "/usr/include/sys/select.h"

# 1 "/usr/include/sys/time_impl.h"
 
# 22
 
# 26

 
# 36

# 39

#ident	"@(#)time_impl.h	1.12	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 43 "/usr/include/sys/time_impl.h"

# 47

# 49

# 54

 
# 58

typedef struct  timespec {		 
	time_t		tv_sec;		 
	long		tv_nsec;	 
} timespec_t;

# 82

typedef struct timespec timestruc_t;	 

 
# 89

# 93

 
# 97
typedef struct itimerspec {		 
	struct timespec	it_interval;	 
	struct timespec	it_value;	 
} itimerspec_t;

# 119

# 121

# 130

# 134

# 137

# 141

# 1 "/usr/include/sys/time.h"
 
 


 
# 10

 
# 15

# 18

#ident	"@(#)time.h	2.81	07/06/26 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 22 "/usr/include/sys/time.h"

 
# 27

# 31

# 35

# 40

# 45

struct timeval {
	time_t		tv_sec;		 
	suseconds_t	tv_usec;	 
};

# 72

# 75

# 78
struct timezone {
	int	tz_minuteswest;	 
	int	tz_dsttime;	 
};

# 85

# 89

 
# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 98 "/usr/include/sys/time.h"

# 102

# 104

# 116

 
# 127

# 129

# 131

# 133
 
# 140
				 
				 
# 143
				 
				 

# 147
struct	itimerval {
	struct	timeval it_interval;	 
	struct	timeval it_value;	 
};

# 176


# 179
 
# 186

# 188

# 190

 
# 194
typedef	longlong_t	hrtime_t;

# 315

# 318
int adjtime(struct timeval *, struct timeval *);
# 323

# 327
int futimesat(int, const char *, const struct timeval *);
# 332

# 335

# 337

int getitimer(int, struct itimerval *);
int utimes(const char *, const struct timeval *);
# 344
int setitimer(int, struct itimerval *,
	struct itimerval *);
# 347

# 355

 
# 371

# 376
int settimeofday(struct timeval *, void *);
# 378
hrtime_t	gethrtime(void);
hrtime_t	gethrvtime(void);
# 385

# 387

# 390

# 395
int gettimeofday(struct timeval *, void *);
# 400

# 402

 
# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 32

#ident	"@(#)time.h	1.47	07/01/05 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/iso/time_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)time_iso.h	1.6	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 49 "/usr/include/iso/time_iso.h"

# 53

# 57

# 65

# 74

# 79

# 84

# 86

struct	tm {	 
	int	tm_sec;
	int	tm_min;
	int	tm_hour;
	int	tm_mday;
	int	tm_mon;
	int	tm_year;
	int	tm_wday;
	int	tm_yday;
	int	tm_isdst;
};


# 101

extern char *asctime(const struct tm *);
extern clock_t clock(void);
extern char *ctime(const time_t *);
extern double difftime(time_t, time_t);
extern struct tm *gmtime(const time_t *);
extern struct tm *localtime(const time_t *);
extern time_t mktime(struct tm *);
extern time_t time(time_t *);
extern size_t strftime(char *, size_t, const char *,
	const struct tm *);

# 126

# 130

# 134

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/time_impl.h"
 
# 22
 
# 26

 
# 36

# 42 "/usr/include/time.h"

 
# 62

# 66

# 71

# 76

# 78

# 82
extern struct tm *gmtime_r(const time_t *,
			struct tm *);
extern struct tm *localtime_r(const time_t *,
			struct tm *);
# 87

# 90

# 99

extern char *strptime(const char *, const char *,
		struct tm *);

# 104

# 107
 
# 120
union sigval {
	int	sival_int;	 
	void	*sival_ptr;	 
};
# 125

# 128
struct sigevent {
	int		sigev_notify;	 
	int		sigev_signo;	 
	union sigval	sigev_value;	 
	void		(*sigev_notify_function)(union sigval);
	pthread_attr_t	*sigev_notify_attributes;
	int		__sigev_pad2;
};
# 137

extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int timer_create(clockid_t, struct sigevent *,
		timer_t *);
extern int timer_delete(timer_t);
extern int timer_getoverrun(timer_t);
extern int timer_gettime(timer_t, struct itimerspec *);
extern int timer_settime(timer_t, int, const struct itimerspec *,
		struct itimerspec *);

extern int nanosleep(const struct timespec *, struct timespec *);
extern int clock_nanosleep(clockid_t, int,
	const struct timespec *, struct timespec *);

# 154

# 157

extern void tzset(void);
extern char *tzname[2];

 
# 164
extern long _sysconf(int);	 
# 166
				 
# 169

# 172
extern long timezone;
extern int daylight;
# 175

# 177

# 180
extern int cftime(char *, char *, const time_t *);
extern int ascftime(char *, const char *, const struct tm *);
extern long altzone;
# 184

# 187
extern struct tm *getdate(const char *);
# 191
extern int *_getdate_err_addr(void);
# 196

# 236

 
# 240

 
# 272

# 276

# 278

# 315

extern char *asctime_r(const struct tm *, char *, int);
extern char *ctime_r(const time_t *, char *, int);

# 320

# 368

# 370

# 374

# 418 "/usr/include/sys/time.h"

 
# 1 "/usr/include/sys/select.h"
 
# 22
 
# 26

 
 

 
# 39

# 430 "/usr/include/sys/time.h"

# 432

# 436

# 53 "/usr/include/sys/select.h"

# 57


# 60
 
# 72
typedef struct {		 
	unsigned int	__sigbits[4];
} sigset_t;

# 86

# 88

 
# 114

# 116
typedef	long	fd_mask;
# 118
typedef	long	fds_mask;

 
# 130

# 135

# 142

# 144
typedef	struct fd_set {
# 148
	long	fds_bits[ ( ( ( 65536 ) + ( ( ( sizeof ( fds_mask ) * 8 ) ) - 1 ) ) / ( ( sizeof ( fds_mask ) * 8 ) ) )];
} fd_set;

# 153

# 156

# 159

# 165

# 168
extern int select(int, fd_set *, fd_set *,
	fd_set *, struct timeval *);

# 172
extern int pselect(int, fd_set *, fd_set *,
	fd_set *, const struct timespec *,
	const sigset_t *);
# 176

# 184

# 188

# 614 "/usr/include/sys/types.h"

# 616

 
# 626
 
# 628

# 632

# 1 "/usr/include/sys/unistd.h"
 
# 21
 
# 26

 
# 31

 
# 37

# 40

#ident	"@(#)unistd.h	1.46	07/05/23 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 44 "/usr/include/sys/unistd.h"

# 48

 

# 52

 
# 56
 
# 61
 
# 66

 
# 84

 
# 103

 

 
# 115
 
# 120
 
# 125
 
# 153
 
# 174

 
# 178

 
# 184

 
# 189

# 192

 
# 208

# 214

 
# 235

 
# 244

 
# 285

 

 
# 298
 
# 302
 
# 312
 
# 320

 
# 326

 
# 333

# 341

# 349

 
# 362

# 366

# 370

# 381

 
# 386

# 390

# 39 "/usr/include/unistd.h"

# 43

 
# 49

# 56

 

# 62

# 66

# 70

# 75

# 80

# 82
 
# 86

 
# 92

 
# 98

 
# 129

 
# 150

 
# 161

 
# 173

# 177

# 185

# 189

 
# 199

 
# 220

 
#pragma	redefine_extname	ftruncate64	ftruncate
#pragma	redefine_extname	lseek64		lseek
#pragma	redefine_extname	pread64		pread
#pragma	redefine_extname	pwrite64	pwrite
#pragma	redefine_extname	truncate64	truncate
#pragma	redefine_extname	lockf64		lockf
#pragma	redefine_extname	tell64		tell
# 241

# 243

extern int access(const char *, int);
# 246
extern int acct(const char *);
# 248
extern unsigned alarm(unsigned);
 
# 252
extern int brk(void *);
# 254
extern int chdir(const char *);
extern int chown(const char *, uid_t, gid_t);
 
# 259
extern int chroot(const char *);
# 261
extern int close(int);
# 268
extern char *ctermid(char *);
# 271
extern char *ctermid_r(char *);
# 273
 
# 275
extern char *cuserid(char *);
# 277
extern int dup(int);
extern int dup2(int, int);
# 283
extern void endusershell(void);
# 285
extern int execl(const char *, const char *, ...);
extern int execle(const char *, const char *, ...);
extern int execlp(const char *, const char *, ...);
extern int execv(const char *, char *const *);
extern int execve(const char *, char *const *, char *const *);
extern int execvp(const char *, char *const *);
extern void _exit(int)
	;
 
# 299
extern int fattach(int, const char *);
# 302
extern int fchdir(int);
extern int fchown(int, uid_t, gid_t);
# 306
extern int fchownat(int, const char *, uid_t, gid_t, int);
# 310
extern int fchroot(int);
# 314
extern int fdatasync(int);
# 316
 
# 322
extern int fdetach(const char *);
# 324
extern pid_t fork(void);
# 326
extern pid_t fork1(void);
extern pid_t forkall(void);
# 329
extern long fpathconf(int, int);
# 332
extern int fsync(int);
# 337
extern int ftruncate(int, off_t);
# 339
extern char *getcwd(char *, size_t);
# 342
extern int getdtablesize(void);
# 344
extern gid_t getegid(void);
extern uid_t geteuid(void);
extern gid_t getgid(void);
extern int getgroups(int, gid_t *);
# 349
extern long gethostid(void);
# 354
extern int gethostname(char *, int);
# 356
extern char *getlogin(void);
# 367
 
# 369
extern int getpagesize(void);
# 371
extern pid_t getpgid(pid_t);
# 373
extern pid_t getpid(void);
extern pid_t getppid(void);
extern pid_t getpgrp(void);

# 378
char *gettxt(const char *, const char *);
# 381
extern pid_t getsid(pid_t);
# 383
extern uid_t getuid(void);
# 385
extern char *getusershell(void);
# 388
extern char *getwd(char *);
# 390
 
# 396
extern int ioctl(int, int, ...);
extern int isaexec(const char *, char *const *, char *const *);
extern int issetugid(void);
# 400
extern int isatty(int);
# 402
extern int lchown(const char *, uid_t, gid_t);
# 404
extern int link(const char *, const char *);
# 406
extern offset_t llseek(int, offset_t, int);
# 411
extern int lockf(int, int, off_t);
# 413
extern off_t lseek(int, off_t, int);
# 416
extern int nice(int);
# 419
extern int mincore(caddr_t, size_t, char *);
# 421
extern long pathconf(const char *, int);
extern int pause(void);
extern int pipe(int *);
# 427
extern ssize_t pread(int, void *, size_t, off_t);
# 430
extern void profil(unsigned short *, size_t, unsigned long, unsigned int);
# 432
 
# 442
extern int pthread_atfork(void (*) (void), void (*) (void), void (*) (void));
# 451
extern ssize_t pwrite(int, const void *, size_t, off_t);
# 454
 
extern int rcmd_af(char **, unsigned short, const char *, const char *,
	const char *, int *, int);
# 458
extern ssize_t read(int, void *, size_t);
# 461
extern ssize_t readlink(const char *, char *,
	size_t);
# 466
extern int rename(const char *, const char *);
# 470
extern int renameat(int, const char *, int, const char *);
# 473
extern int resolvepath(const char *, char *, size_t);
 
extern int rexec_af(char **, unsigned short, const char *, const char *,
	const char *, int *, int);
# 478
extern int rmdir(const char *);
# 480
 
extern int rresvport_af(int *, int);
# 483

# 486
extern void *sbrk(intptr_t);
# 489
extern int setegid(gid_t);
extern int seteuid(uid_t);
# 492
extern int setgid(gid_t);
# 494
extern int setgroups(int, const gid_t *);
extern int sethostname(char *, int);
# 497
extern int setpgid(pid_t, pid_t);
# 499
extern pid_t setpgrp(void);
extern int setregid(gid_t, gid_t);
extern int setreuid(uid_t, uid_t);
# 503
extern pid_t setsid(void);
extern int setuid(uid_t);
# 506
extern void setusershell(void);
# 508
extern unsigned sleep(unsigned);
# 510
extern int stime(const time_t *);
# 517
extern int symlink(const char *, const char *);
extern void sync(void);
# 527
extern long sysconf(int);
extern pid_t tcgetpgrp(int);
extern int tcsetpgrp(int, pid_t);
# 533
extern off_t tell(int);
# 538
extern int truncate(const char *, off_t);
# 540
extern char *ttyname(int);
# 542
extern useconds_t ualarm(useconds_t, useconds_t);
# 544
extern int unlink(const char *);
# 547
extern int unlinkat(int, const char *, int);
# 550
extern int usleep(useconds_t);
# 553
extern pid_t vfork(void);
# 556
extern void vhangup(void);
# 558
extern ssize_t write(int, const void *, size_t);
# 560
extern void yield(void);
# 562

 
# 566
extern int ftruncate64(int, off64_t);
extern off64_t lseek64(int, off64_t, int);
extern ssize_t	pread64(int, void *, size_t, off64_t);
extern ssize_t	pwrite64(int, const void *, size_t, off64_t);
extern off64_t	tell64(int);
extern int	truncate64(const char *, off64_t);
extern int	lockf64(int, int, off64_t);
# 574

# 873

 
#pragma	unknown_control_flow(vfork)
# 884

 
# 888

 
# 920

# 924

# 926

# 961

extern char *getlogin_r(char *, int);
extern char *ttyname_r(int, char *, int);

# 966

# 1014

# 1016

# 1020

# 16 "WeaverConnection.c"

# 1 "/usr/include/sys/socket.h"
 
# 21
 
# 25

 
 

 
# 38

# 41

#ident	"@(#)socket.h	1.82	07/01/07 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/uio.h"
 
# 22
 
# 26

 
 

 
# 39

# 42

#ident	"@(#)uio.h	1.36	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 46 "/usr/include/sys/uio.h"

# 50

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 52 "/usr/include/sys/uio.h"

 
# 59

# 66
typedef struct iovec {
	caddr_t	iov_base;
# 69
	size_t	iov_len;
# 73
} iovec_t;
# 75

# 86

# 88
 
# 91
typedef enum uio_seg { UIO_USERSPACE, UIO_SYSSPACE, UIO_USERISPACE } uio_seg_t;

typedef struct uio {
	iovec_t		*uio_iov;	 
	int		uio_iovcnt;	 
	lloff_t		_uio_offset;	 
	uio_seg_t	uio_segflg;	 
	uint16_t	uio_fmode;	 
	uint16_t	uio_extflg;	 
	lloff_t		_uio_limit;	 
	ssize_t		uio_resid;	 
} uio_t;

# 110

# 117

 
# 121
typedef enum uio_rw { UIO_READ, UIO_WRITE } uio_rw_t;

 
# 133

# 135

# 145

# 147

extern ssize_t readv(int, const struct iovec *, int);
extern ssize_t writev(int, const struct iovec *, int);

# 157

# 159

# 163

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/socket_impl.h"
 
# 22
 
# 26

 
 

 
# 34

# 37

#ident	"@(#)socket_impl.h	1.3	05/06/08 SMI"

# 43

# 46
typedef uint16_t	sa_family_t;
# 48

 
# 53
struct sockaddr {
	sa_family_t	sa_family;	 
	char		sa_data[14];	 
};

# 1 "/usr/include/sys/un.h"
 
# 22
 
# 26

 
 

 
# 39

# 42

#ident	"@(#)un.h	1.13	05/06/08 SMI"

# 48

# 53

 
# 57
struct	sockaddr_un {
	sa_family_t	sun_family;		 
	char		sun_path[108];		 
};

# 65

# 69

# 1 "/usr/include/net/if_dl.h"
 
# 5
 
# 37

# 40

#ident	"@(#)if_dl.h	1.12	05/06/12 SMI"
 

# 47

 
# 65

 
# 69
struct sockaddr_dl {
	ushort_t sdl_family;	 
	ushort_t sdl_index;	 
	uchar_t	sdl_type;	 
	uchar_t	sdl_nlen;	 
	uchar_t	sdl_alen;	 
	uchar_t	sdl_slen;	 
	char	sdl_data[244];	 
};

# 80

# 82
extern char *_link_ntoa(const unsigned char *, char *, int, int);
extern unsigned char *_link_aton(const char *, int *);
# 88

# 92

# 62 "/usr/include/sys/socket_impl.h"

# 64
 
# 69

 
# 74

 
# 88
typedef	double		sockaddr_maxalign_t;

# 91

 
# 98

struct sockaddr_storage {
	sa_family_t	ss_family;	 
	 
	char		_ss_pad1[ ( ( sizeof ( sockaddr_maxalign_t ) ) - sizeof ( sa_family_t ) )];
	sockaddr_maxalign_t _ss_align;
	char		_ss_pad2[ ( 256 - ( sizeof ( sa_family_t ) + ( ( sizeof ( sockaddr_maxalign_t ) ) - sizeof ( sa_family_t ) ) + ( sizeof ( sockaddr_maxalign_t ) ) ) )];
};
# 107

# 111

# 1 "/usr/include/sys/netconfig.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)netconfig.h	1.26	05/06/08 SMI"

# 39

# 42

struct  netconfig {
	char		*nc_netid;	 
	unsigned int	nc_semantics;	 
	unsigned int	nc_flag;	 
	char		*nc_protofmly;	 
	char		*nc_proto;	 
	char		*nc_device;	 
	unsigned int	nc_nlookups;	 
	char		**nc_lookups;	 
	unsigned int	nc_unused[8];	 
};

typedef struct {
	struct netconfig **nc_head;
	struct netconfig **nc_curr;
} NCONF_HANDLE;

 
# 63

# 68
 
# 77

 
# 81

# 85

 
# 89

# 114
 
# 123

 
# 127

# 132

 
# 139

# 141

extern void		*setnetconfig(void);
extern int		endnetconfig(void *);
extern struct netconfig	*getnetconfig(void *);
extern struct netconfig	*getnetconfigent(const char *);
extern void		freenetconfigent(struct netconfig *);
extern void		*setnetpath(void);
extern int		endnetpath(void *);
extern struct netconfig *getnetpath(void *);
extern void		nc_perror(const char *);
extern char		*nc_sperror(void);

# 167

# 171

# 1 "/usr/include/netinet/in.h"
 
# 5
 
# 16

 
# 26

# 29

#ident	"@(#)in.h	1.61	07/06/17 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 33 "/usr/include/netinet/in.h"

# 37

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 39 "/usr/include/netinet/in.h"

# 1 "/usr/include/sys/socket_impl.h"
 
# 22
 
# 26

 
 

 
# 34

# 43 "/usr/include/netinet/in.h"

# 46

 
# 54
typedef	uint32_t	socklen_t;
# 56

# 60
typedef	void		*Psocklen_t;
# 62

# 64

# 1 "/usr/include/sys/stream.h"
 
# 21
 
# 25

 
 


# 32

#ident	"@(#)stream.h	1.123	06/12/27 SMI"

 
# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/vnode.h"
 
# 21
 
# 25

 
 

 
# 38

# 41

#ident	"@(#)vnode.h	1.132	07/03/26 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/t_lock.h"
 
# 22
 
# 26

 
# 32

# 35

#ident	"@(#)t_lock.h	1.46	05/06/08 SMI"

# 1 "/usr/include/sys/machlock.h"
 
# 21
 
# 25

# 28

#ident	"@(#)machlock.h	1.27	07/06/26 SMI"

# 34

# 36

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 38 "/usr/include/sys/machlock.h"

# 51

# 56

typedef	lock_t	disp_lock_t;		 

 
# 64

 
# 72

 
# 76
extern	volatile int	hres_lock;

# 79

 
# 105

# 107

# 109

 
# 122

# 126

# 1 "/usr/include/sys/param.h"
 
# 21
 
# 25

 
 

 
# 38

# 41

#ident	"@(#)param.h	1.87	07/05/23 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 48 "/usr/include/sys/param.h"


# 53

 
# 57

 
# 73

# 77

# 81

# 84

# 86

# 92

# 99

# 101

# 103

# 106

# 108

# 110

# 112

# 114
				 
				 
				 

 
# 124

 
# 130

 
# 135

 
# 139

# 141

# 149

# 156

# 169

 
# 173

 
# 190

# 194

 
# 203

# 207

# 211

 
# 215

 
# 247

# 252

 
# 258

# 267

 
# 278

 
# 285

 
# 304

# 308

 
# 313

# 446

 
# 454

# 1 "/usr/include/sys/unistd.h"
 
# 21
 
# 26

 
# 31

 
# 37

# 456 "/usr/include/sys/param.h"

# 460

# 462
extern long _sysconf(int);	 
# 464

# 472

# 476

# 478

# 1 "/usr/include/sys/mutex.h"
 
# 21
 
# 25

# 28

#ident	"@(#)mutex.h	1.22	07/03/27 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 34 "/usr/include/sys/mutex.h"

# 38

# 40

 
# 59
typedef enum {
	MUTEX_ADAPTIVE = 0,	 
	MUTEX_SPIN = 1,		 
	MUTEX_DRIVER = 4,	 
	MUTEX_DEFAULT = 6	 
} kmutex_type_t;

typedef struct mutex {
# 68
	void	*_opaque[1];
# 72
} kmutex_t;

# 89

# 91

# 95

# 1 "/usr/include/sys/rwlock.h"
 
# 22
 
# 26

# 29

#ident	"@(#)rwlock.h	1.10	05/06/08 SMI"

 
# 35

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 37 "/usr/include/sys/rwlock.h"

# 41

# 43

typedef enum {
	RW_DRIVER = 2,		 
	RW_DEFAULT = 4		 
} krw_type_t;

typedef enum {
	RW_WRITER,
	RW_READER
} krw_t;

typedef struct _krwlock {
	void	*_opaque[1];
} krwlock_t;

# 80

# 82

# 86

# 1 "/usr/include/sys/semaphore.h"
 
# 22
 
# 26

# 29

#ident	"@(#)semaphore.h	1.6	05/06/08 SMI"

 
# 35

# 37

# 41

# 45

typedef enum {
	SEMA_DEFAULT,
	SEMA_DRIVER
} ksema_type_t;

typedef struct _ksema {
	void	* _opaque[2];	 
} ksema_t;

# 68

# 72

# 74

# 1 "/usr/include/sys/condvar.h"
 
# 22
 
# 26

 
# 34

# 37

#ident	"@(#)condvar.h	1.17	07/04/26 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/time.h"
 
 


 
# 10

 
# 15

# 47 "/usr/include/sys/condvar.h"

# 51

# 53

 
# 57

typedef struct _kcondvar {
	ushort_t	_opaque;
} kcondvar_t;

typedef	enum {
	CV_DEFAULT,
	CV_DRIVER
} kcv_type_t;


# 88

# 90

# 94

# 46 "/usr/include/sys/t_lock.h"

# 50

# 52

 
# 62

# 98

# 100

# 104

# 1 "/usr/include/sys/rwstlock.h"
 
# 22
 
# 26

# 29

#ident	"@(#)rwstlock.h	1.6	05/06/08 SMI"

 
# 36

# 40

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/ksynch.h"
 
# 22
 
# 25

 
# 29

# 32

#ident	"@(#)ksynch.h	1.7	05/06/08 SMI"

 
# 38

# 1 "/usr/include/sys/t_lock.h"
 
# 22
 
# 26

 
# 32

# 40 "/usr/include/sys/ksynch.h"

# 1 "/usr/include/sys/rwlock.h"
 
# 22
 
# 26

# 44 "/usr/include/sys/rwstlock.h"

typedef struct rwstlock {
	intptr_t	rwst_count;
	kcondvar_t	rwst_rcv;
	kcondvar_t	rwst_wcv;
	kmutex_t	rwst_lock;
} rwstlock_t;

 
# 56

# 59

# 79

extern void rwst_enter(rwstlock_t *, krw_t);
extern int rwst_enter_sig(rwstlock_t *, krw_t);
extern void rwst_exit(rwstlock_t *);
extern void rwst_init(rwstlock_t *, char *, krw_type_t, void *);
extern void rwst_destroy(rwstlock_t *);
extern int rwst_lock_held(rwstlock_t *, krw_t);
extern int rwst_tryenter(rwstlock_t *, krw_t);
extern struct _kthread *rwst_owner(rwstlock_t *);

# 92

# 1 "/usr/include/sys/time_impl.h"
 
# 22
 
# 26

 
# 36

# 1 "/usr/include/sys/cred.h"
 
# 21
 
# 25

 
 

 
# 33

# 36

#ident	"@(#)cred.h	1.30	07/05/23 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 40 "/usr/include/sys/cred.h"

# 44

 
# 49

typedef struct cred cred_t;

# 174

# 178

# 1 "/usr/include/sys/uio.h"
 
# 22
 
# 26

 
 

 
# 39

# 1 "/usr/include/sys/resource.h"
 
# 21
 
# 25

 
 

 
# 38

# 41

#ident	"@(#)resource.h	1.39	06/12/11 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 45 "/usr/include/sys/resource.h"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/time.h"
 
 


 
# 10

 
# 15

# 48 "/usr/include/sys/resource.h"

# 52

 
# 66

 
# 78

# 80

# 82

typedef	unsigned long	rlim_t;

# 88

# 114

# 131

struct rlimit {
	rlim_t	rlim_cur;		 
	rlim_t	rlim_max;		 
};

 
# 139

typedef u_longlong_t	rlim64_t;

# 145

struct rlimit64 {
	rlim64_t	rlim_cur;	 
	rlim64_t	rlim_max;	 
};

# 152

 
# 159

# 162

# 169


struct	rusage {
	struct timeval ru_utime;	 
	struct timeval ru_stime;	 
	long	ru_maxrss;		 
	long	ru_ixrss;		 
	long	ru_idrss;		 
	long	ru_isrss;		 
	long	ru_minflt;		 
	long	ru_majflt;		 
	long	ru_nswap;		 
	long	ru_inblock;		 
	long	ru_oublock;		 
	long	ru_msgsnd;		 
	long	ru_msgrcv;		 
	long	ru_nsignals;		 
	long	ru_nvcsw;		 
	long	ru_nivcsw;		 
};

# 194

# 217


# 226

# 230


# 245

# 247
 
#pragma	redefine_extname	setrlimit64	setrlimit
#pragma	redefine_extname	getrlimit64	getrlimit
# 260

# 262

extern int setrlimit(int, const struct rlimit *);
extern int getrlimit(int, struct rlimit *);

 
# 269
extern int setrlimit64(int, const struct rlimit64 *);
extern int getrlimit64(int, struct rlimit64 *);
# 272

extern int getpriority(int, id_t);
extern int setpriority(int, id_t, int);
extern int getrusage(int, struct rusage *);

# 294

# 296

# 300

# 1 "/usr/include/vm/seg_enum.h"
 
# 22
 
# 26
 
 

 
# 33

# 36

#ident	"@(#)seg_enum.h	1.11	05/10/07 SMI"

# 42

 
# 47

 
# 53
enum fault_type {
	F_INVAL,		 
	F_PROT,			 
	F_SOFTLOCK,		 
	F_SOFTUNLOCK		 
};

 
# 63
enum lock_type {
	L_PAGELOCK,		 
	L_PAGEUNLOCK,		 
	L_PAGERECLAIM		 
};

 
# 72
enum seg_rw {
	S_OTHER,		 
	S_READ,			 
	S_WRITE,		 
	S_EXEC,			 
	S_CREATE,		 
	S_READ_NOCOW		 
};

 
# 84
typedef enum {
	S_CAPABILITY_NOMINFLT	 
} segcapability_t;

# 91

# 1 "/usr/include/sys/kstat.h"
 
# 21
 
# 25

# 28

#ident	"@(#)kstat.h	1.23	06/10/17 SMI"

 
# 34

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/time.h"
 
 


 
# 10

 
# 15

# 37 "/usr/include/sys/kstat.h"

# 41

typedef int	kid_t;		 

 
# 47

# 49

# 53

 
# 61

# 63

 
# 67

typedef struct kstat {
	 
# 72
	hrtime_t	ks_crtime;	 
	struct kstat	*ks_next;	 
	kid_t		ks_kid;		 
	char		ks_module[ 31 ];  
	uchar_t		ks_resv;	 
	int		ks_instance;	 
	char		ks_name[ 31 ];  
	uchar_t		ks_type;	 
	char		ks_class[ 31 ];  
	uchar_t		ks_flags;	 
	void		*ks_data;	 
	uint_t		ks_ndata;	 
	size_t		ks_data_size;	 
	hrtime_t	ks_snaptime;	 
	 
# 89
	int		(*ks_update)(struct kstat *, int);  
	void		*ks_private;	 
	int		(*ks_snapshot)(struct kstat *, void *, int);
	void		*ks_lock;	 
} kstat_t;

# 127

 
# 150

# 164

 
# 173

 
# 185

 
# 194

 
# 205

 
# 220

# 222
					 
# 224
					 
# 226
					 
# 228
					 
# 230
					 

# 233

 
# 244

 
# 300

# 307

 
# 347

# 350

 
# 436

 
# 442

typedef struct kstat_named {
	char	name[ 31 ];	 
	uchar_t	data_type;		 
	union {
		char		c[16];	 
		int32_t		i32;
		uint32_t	ui32;
		struct {
			union {
				char 		*ptr;	 
# 456
				char 		__pad[8];  
			} addr;
			uint32_t	len;	 
		} str;
 
# 471
		int64_t		i64;
		uint64_t	ui64;
# 474
		long		l;
		ulong_t		ul;

		 

		longlong_t	ll;
		u_longlong_t	ull;
		float		f;
		double		d;
	} value;			 
} kstat_named_t;

# 491

# 504

 
# 522

 

# 529

# 531

 
# 536

 
# 542

 
# 561

# 567

# 569

typedef struct kstat_intr {
	uint_t	intrs[ 5 ];	 
} kstat_intr_t;

# 575

 
# 579

typedef struct kstat_io {

	 
# 588

	u_longlong_t	nread;		 
	u_longlong_t	nwritten;	 
	uint_t		reads;		 
	uint_t		writes;		 

	 
# 666

	hrtime_t wtime;		 
	hrtime_t wlentime;	 
	hrtime_t wlastupdate;	 
	hrtime_t rtime;		 
	hrtime_t rlentime;	 
	hrtime_t rlastupdate;	 

	uint_t	wcnt;		 
	uint_t	rcnt;		 

} kstat_io_t;

# 680

 
# 687

typedef struct kstat_timer {
	char		name[ 31 ];	 
	uchar_t		resv;			 
	u_longlong_t	num_events;		 
	hrtime_t	elapsed_time;		 
	hrtime_t	min_time;		 
	hrtime_t	max_time;		 
	hrtime_t	start_time;		 
	hrtime_t	stop_time;		 
} kstat_timer_t;

# 700

# 815

# 819

# 1 "/usr/include/sys/kmem.h"
 
# 22
 
# 26

 
 

# 32

#ident	"@(#)kmem.h	1.39	05/10/30 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/vmem.h"
 
# 21
 
# 25

# 28

#ident	"@(#)vmem.h	1.14	07/05/11 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 32 "/usr/include/sys/vmem.h"

# 36


 
# 46

# 50

 
# 58
 
# 64

# 66

 
# 73
 
# 83

 
# 89

 
# 96

 
# 107

typedef struct vmem vmem_t;
typedef void *(vmem_alloc_t)(vmem_t *, size_t, int);
typedef void (vmem_free_t)(vmem_t *, void *, size_t);

 
# 116
typedef void *(vmem_ximport_t)(vmem_t *, size_t *, size_t, int);

# 125

extern vmem_t *vmem_create(const char *, void *, size_t, size_t,
    vmem_alloc_t *, vmem_free_t *, vmem_t *, size_t, int);
extern vmem_t *vmem_xcreate(const char *, void *, size_t, size_t,
    vmem_ximport_t *, vmem_free_t *, vmem_t *, size_t, int);
extern void vmem_destroy(vmem_t *);
extern void *vmem_alloc(vmem_t *, size_t, int);
extern void *vmem_xalloc(vmem_t *, size_t, size_t, size_t, size_t,
    void *, void *, int);
extern void vmem_free(vmem_t *, void *, size_t);
extern void vmem_xfree(vmem_t *, void *, size_t);
extern void *vmem_add(vmem_t *, void *, size_t, int);
extern int vmem_contains(vmem_t *, void *, size_t);
extern void vmem_walk(vmem_t *, int, void (*)(void *, void *, size_t), void *);
extern size_t vmem_size(vmem_t *, int);

# 144

# 37 "/usr/include/sys/kmem.h"

# 41

 
# 46

# 52

# 54

# 63

 
# 69

 
# 80

struct kmem_cache;		 

typedef struct kmem_cache kmem_cache_t;

# 109

# 113

# 57 "/usr/include/sys/vnode.h"

# 61

 
# 71

# 73

typedef struct vopstats {
	kstat_named_t	nopen;		 
	kstat_named_t	nclose;		 
	kstat_named_t	nread;		 
	kstat_named_t	read_bytes;
	kstat_named_t	nwrite;		 
	kstat_named_t	write_bytes;
	kstat_named_t	nioctl;		 
	kstat_named_t	nsetfl;		 
	kstat_named_t	ngetattr;	 
	kstat_named_t	nsetattr;	 
	kstat_named_t	naccess;	 
	kstat_named_t	nlookup;	 
	kstat_named_t	ncreate;	 
	kstat_named_t	nremove;	 
	kstat_named_t	nlink;		 
	kstat_named_t	nrename;	 
	kstat_named_t	nmkdir;		 
	kstat_named_t	nrmdir;		 
	kstat_named_t	nreaddir;	 
	kstat_named_t	readdir_bytes;
	kstat_named_t	nsymlink;	 
	kstat_named_t	nreadlink;	 
	kstat_named_t	nfsync;		 
	kstat_named_t	ninactive;	 
	kstat_named_t	nfid;		 
	kstat_named_t	nrwlock;	 
	kstat_named_t	nrwunlock;	 
	kstat_named_t	nseek;		 
	kstat_named_t	ncmp;		 
	kstat_named_t	nfrlock;	 
	kstat_named_t	nspace;		 
	kstat_named_t	nrealvp;	 
	kstat_named_t	ngetpage;	 
	kstat_named_t	nputpage;	 
	kstat_named_t	nmap;		 
	kstat_named_t	naddmap;	 
	kstat_named_t	ndelmap;	 
	kstat_named_t	npoll;		 
	kstat_named_t	ndump;		 
	kstat_named_t	npathconf;	 
	kstat_named_t	npageio;	 
	kstat_named_t	ndumpctl;	 
	kstat_named_t	ndispose;	 
	kstat_named_t	nsetsecattr;	 
	kstat_named_t	ngetsecattr;	 
	kstat_named_t	nshrlock;	 
	kstat_named_t	nvnevent;	 
} vopstats_t;

 
# 151

 
# 156
typedef enum vtype {
	VNON	= 0,
	VREG	= 1,
	VDIR	= 2,
	VBLK	= 3,
	VCHR	= 4,
	VLNK	= 5,
	VFIFO	= 6,
	VDOOR	= 7,
	VPROC	= 8,
	VSOCK	= 9,
	VPORT	= 10,
	VBAD	= 11
} vtype_t;

 
# 211

struct fem_head;	 

typedef struct vnode {
	kmutex_t	v_lock;		 
	uint_t		v_flag;		 
	uint_t		v_count;	 
	void		*v_data;	 
	struct vfs	*v_vfsp;	 
	struct stdata	*v_stream;	 
	enum vtype	v_type;		 
	dev_t		v_rdev;		 

	 

	struct vfs	*v_vfsmountedhere;  
	struct vnodeops	*v_op;		 
	struct page	*v_pages;	 
	pgcnt_t		v_npages;	 
	pgcnt_t		v_msnpages;	 
	struct page	*v_scanfront;	 
	struct page	*v_scanback;	 
	struct filock	*v_filocks;	 
	struct shrlocklist *v_shrlocks;	 
	krwlock_t	v_nbllock;	 
	kcondvar_t	v_cv;		 
	void		*v_locality;	 
	struct fem_head	*v_femhead;	 
	char		*v_path;	 
	uint_t		v_rdcnt;	 
	uint_t		v_wrcnt;	 
	u_longlong_t	v_mmap_read;	 
	u_longlong_t	v_mmap_write;	 
	void		*v_mpssdata;	 
	hrtime_t	v_scantime;	 
	ushort_t	v_mset;		 
	uint_t		v_msflags;	 
	struct vnode	*v_msnext;	 
	struct vnode	*v_msprev;	 
	krwlock_t	v_mslock;	 
} vnode_t;

# 255

 
# 267

# 269

typedef struct vn_vfslocks_entry {
	rwstlock_t ve_lock;
	void *ve_vpvfs;
	struct vn_vfslocks_entry *ve_next;
	uint32_t ve_refcnt;
	char pad[64 - sizeof (rwstlock_t) - 2 * sizeof (void *) - 	    sizeof (uint32_t)];
# 277
} vn_vfslocks_entry_t;

 
# 284

 
# 289

 
# 295

 
# 301

# 303

# 305

# 307

# 309

 
# 319

# 322

 
# 328

 
# 335

typedef struct vattr {
	uint_t		va_mask;	 
	vtype_t		va_type;	 
	mode_t		va_mode;	 
	uid_t		va_uid;		 
	gid_t		va_gid;		 
	dev_t		va_fsid;	 
	u_longlong_t	va_nodeid;	 
	nlink_t		va_nlink;	 
	u_offset_t	va_size;	 
	timestruc_t	va_atime;	 
	timestruc_t	va_mtime;	 
	timestruc_t	va_ctime;	 
	dev_t		va_rdev;	 
	uint_t		va_blksize;	 
	u_longlong_t	va_nblocks;	 
	uint_t		va_seq;		 
} vattr_t;

# 390
typedef vattr_t		vattr32_t;
# 392

 
# 410
 	 
# 412

# 416

# 419

# 421

# 424

 
# 431

 
# 438

# 441

 
# 445

# 448

 
# 452
enum rm		{ RMFILE, RMDIRECTORY };	 
enum symfollow	{ NO_FOLLOW, FOLLOW };		 
enum vcexcl	{ NONEXCL, EXCL };		 
enum create	{ CRCREAT, CRMKNOD, CRMKDIR };	 

typedef enum rm		rm_t;
typedef enum symfollow	symfollow_t;
typedef enum vcexcl	vcexcl_t;
typedef enum create	create_t;

 
typedef enum vnevent	{
	VE_SUPPORT	= 0,	 
	VE_RENAME_SRC	= 1,	 
	VE_RENAME_DEST	= 2,	 
	VE_REMOVE	= 3,	 
	VE_RMDIR	= 4	 
} vnevent_t;

 
# 474
enum v_mode { V_READ, V_WRITE, V_RDORWR, V_RDANDWR };

typedef enum v_mode v_mode_t;

# 480

 
# 484

typedef struct vsecattr {
	uint_t		vsa_mask;	 
	int		vsa_aclcnt;	 
	void		*vsa_aclentp;	 
	int		vsa_dfaclcnt;	 
	void		*vsa_dfaclentp;	 
} vsecattr_t;

 
# 500

 
# 511
typedef struct caller_context {
	pid_t		cc_pid;		 
	int		cc_sysid;	 
	u_longlong_t	cc_caller_id;	 
} caller_context_t;

 
# 520
struct pathname;
struct fid;
struct flock64;
struct flk_callback;
struct shrlock;
struct page;
struct seg;
struct as;
struct pollhead;

# 681

# 770

# 815

 
# 822

 
# 829

 
# 836

 
# 957

 
# 966

 
# 971

# 973

# 976

# 1006

# 1010

# 1 "/usr/include/sys/poll.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)poll.h	1.30	05/06/08 SMI"

# 39

 
# 44
typedef struct pollfd {
	int fd;				 
	short events;			 
	short revents;			 
} pollfd_t;

typedef unsigned long	nfds_t;

 
# 62

# 64

 
# 72

# 74

# 87

# 139

# 142
int poll(struct pollfd *, nfds_t, int);
# 147

# 151

# 1 "/usr/include/sys/strmdep.h"
 
# 22
 
# 26

 
 


# 33

#ident	"@(#)strmdep.h	1.12	05/06/08 SMI"

# 39

 
# 44

 
# 50

 
# 56

 
# 62

# 66

# 1 "/usr/include/sys/cred.h"
 
# 21
 
# 25

 
 

 
# 33

# 1 "/usr/include/sys/t_lock.h"
 
# 22
 
# 26

 
# 32

# 1 "/usr/include/sys/model.h"
 
# 22
 
# 26

# 29

#ident	"@(#)model.h	1.26	05/06/08 SMI"

# 35

# 39

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 41 "/usr/include/sys/model.h"

# 67

# 69
 
# 75
typedef unsigned int model_t;

# 78

# 220

# 224

# 45 "/usr/include/sys/stream.h"

# 49

 
# 111
typedef struct queue {
	struct qinit	*q_qinfo;	 
	struct msgb	*q_first;	 
	struct msgb	*q_last;	 
	struct queue	*q_next;	 
	struct queue	*q_link;	 
	void		*q_ptr;		 
	size_t		q_count;	 
	uint_t		q_flag;		 
	ssize_t		q_minpsz;	 
	ssize_t		q_maxpsz;	 
	size_t		q_hiwat;	 
	size_t		q_lowat;	 
	struct qband	*q_bandp;	 
	kmutex_t	q_lock;		 
	struct stdata 	*q_stream;	 
	struct syncq	*q_syncq;	 
	unsigned char	q_nband;	 
	kcondvar_t	q_wait;		 
	struct queue	*q_nfsrv;	 
	ushort_t	q_draining;	 
	short		q_struiot;	 
	clock_t		q_qtstamp;	 
	size_t		q_mblkcnt;	 
	uint_t		q_syncqmsgs;	 
	size_t		q_rwcnt;	 
	pri_t		q_spri;		 

	 
# 142
	struct msgb	*q_sqhead;	 
	struct msgb	*q_sqtail;	 
	struct queue	*q_sqnext;	 
	struct queue	*q_sqprev;	 
	uint_t		q_sqflags;	 
	clock_t		q_sqtstamp;	 

	 
# 153
	struct fmodsw_impl	*q_fp;
} queue_t;

 
# 168
 
 
# 176
					 
# 183
 
 
 
# 190
					 

 
# 195
					 
					 
					 

 
# 203
typedef struct qband {
	struct qband	*qb_next;	 
	size_t		qb_count;	 
	struct msgb	*qb_first;	 
	struct msgb	*qb_last;	 
	size_t		qb_hiwat;	 
	size_t		qb_lowat;	 
	uint_t		qb_flag;	 
	size_t		qb_mblkcnt;	 
} qband_t;

 
# 220

 
# 225

 
# 229
typedef enum qfields {
	QHIWAT	= 0,		 
	QLOWAT	= 1,		 
	QMAXPSZ	= 2,		 
	QMINPSZ	= 3,		 
	QCOUNT	= 4,		 
	QFIRST	= 5,		 
	QLAST	= 6,		 
	QFLAG	= 7,		 
	QSTRUIOT = 8,		 
	QBAD	= 9
} qfields_t;

 
# 245
struct module_info {
	ushort_t mi_idnum;		 
	char 	*mi_idname;		 
	ssize_t	mi_minpsz;		 
	ssize_t	mi_maxpsz;		 
	size_t	mi_hiwat;		 
	size_t 	mi_lowat;		 
};

 
# 257
struct	qinit {
	int	(*qi_putp)();		 
	int	(*qi_srvp)();		 
	int	(*qi_qopen)();		 
	int	(*qi_qclose)();		 
	int	(*qi_qadmin)();		 
	struct module_info *qi_minfo;	 
	struct module_stat *qi_mstat;	 
	int	(*qi_rwp)();		 
	int	(*qi_infop)();		 
	int	qi_struiot;		 
};

 
# 276

 
# 280
struct streamtab {
	struct qinit *st_rdinit;
	struct qinit *st_wrinit;
	struct qinit *st_muxrinit;
	struct qinit *st_muxwinit;
};

 
# 290
struct linkblk {
	queue_t *l_qtop;	 
				 
	queue_t *l_qbot;	 
	int	l_index;	 
};

 
# 300
typedef struct free_rtn {
	void	(*free_func)();
	caddr_t	free_arg;
} frtn_t;

 
# 311

# 313

typedef struct datab {
	frtn_t		*db_frtnp;
	unsigned char	*db_base;
	unsigned char	*db_lim;
	unsigned char	db_ref;
	unsigned char	db_type;
	unsigned char	db_flags;
	unsigned char	db_struioflag;
	pid_t		db_cpid;	 
	void		*db_cache;	 
	struct msgb	*db_mblk;
	void		(*db_free)(struct msgb *, struct datab *);
	void		(*db_lastfree)(struct msgb *, struct datab *);
	intptr_t	db_cksumstart;
	intptr_t	db_cksumend;
	intptr_t	db_cksumstuff;
	union {
		double enforce_alignment;
		unsigned char data[8];
		struct {
			union {
				uint32_t u32;
				uint16_t u16;
			} cksum_val;     
			uint16_t flags;
			uint16_t pad;
		} cksum;
		 
# 344
	} db_struioun;
	struct fthdr	*db_fthdr;
	cred_t		*db_credp;	 
} dblk_t;

# 351

 
# 359
 
# 363

# 366

 
# 370
typedef struct	msgb {
	struct	msgb	*b_next;
	struct  msgb	*b_prev;
	struct	msgb	*b_cont;
	unsigned char	*b_rptr;
	unsigned char	*b_wptr;
	struct datab 	*b_datap;
	unsigned char	b_band;
	unsigned char	b_tag;
	unsigned short	b_flag;
	queue_t		*b_queue;	 
} mblk_t;

 
# 386
typedef	struct	bcache {
	kmutex_t		mutex;
	struct kmem_cache	*buffer_cache;
	struct kmem_cache	*dblk_cache;
	int			alloc;
	int			destroy;
	size_t			size;
	uint_t			align;
} bcache_t;

 
# 401

 
# 412

 
# 418
				 
# 420
 
# 424

 
# 428

 
# 435

 
# 448

 
# 470

 
# 476

 
# 481
struct iocblk {
	int 	ioc_cmd;		 
	cred_t	*ioc_cr;		 
	uint_t	ioc_id;			 
	uint_t	ioc_flag;		 
	size_t	ioc_count;		 
	int	ioc_rval;		 
	int	ioc_error;		 
};
# 503

typedef	struct iocblk	*IOCP;

 

# 513

 
# 519

 
# 524
struct copyreq {
	int	cq_cmd;			 
	cred_t	*cq_cr;			 
	uint_t	cq_id;			 
	uint_t	cq_flag;		 
	mblk_t	*cq_private;		 
	caddr_t	cq_addr;		 
	size_t	cq_size;		 
};
# 545

 
# 550
struct copyresp {
	int	cp_cmd;			 
	cred_t	*cp_cr;			 
	uint_t	cp_id;			 
	uint_t	cp_flag;		 
	mblk_t *cp_private;		 
	caddr_t	cp_rval;		 
					 
};
# 573

 
# 579
union ioctypes {
	struct iocblk	iocblk;
	struct copyreq	copyreq;
	struct copyresp	copyresp;
};

 
# 589

struct stroptions {
	uint_t	so_flags;		 
	short	so_readopt;		 
	ushort_t so_wroff;		 
	ssize_t	so_minpsz;		 
	ssize_t	so_maxpsz;		 
	size_t	so_hiwat;		 
	size_t	so_lowat;		 
	unsigned char so_band;		 
	ushort_t so_erropt;		 
	ssize_t	so_maxblk;		 
	ushort_t so_copyopt;		 
	ushort_t so_tail;		 
};

 

# 630

# 666

 
# 670

 
# 678

 
# 685

 
# 690

 
# 696

 
# 701

 
# 707

 
# 712

 
# 718

 
# 722

 
# 727

 
# 738

 
# 743

 
# 748

 
# 753

# 843

# 847

# 68 "/usr/include/netinet/in.h"
 
# 1 "/usr/include/sys/byteorder.h"
 
# 21

 
# 26

 
 

 
# 39

# 42

#ident	"@(#)byteorder.h	1.22	05/09/28 SMI"

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/int_types.h"
 
# 22
 
# 26

# 47 "/usr/include/sys/byteorder.h"

# 52

# 56

 
# 60

# 62
 
# 67

# 92

# 94

 
# 102

# 107

 
# 130

# 132

# 136

# 75 "/usr/include/netinet/in.h"

# 78
typedef	uint16_t	in_port_t;
# 80

 
# 94
typedef	uint32_t	in_addr_t;
# 96

# 99
typedef uint32_t ipaddr_t;
# 101

# 103

struct in6_addr {
	union {
		 
# 121
		uint8_t		_S6_u8[16];	 
		uint32_t	_S6_u32[4];	 
# 124
		uint32_t	__S6_align;	 
	} _S6_un;
};
# 128

# 133

typedef struct in6_addr in6_addr_t;

# 137

# 142

 
# 172
						 

# 176

# 180

 
# 201

 
# 221

 
# 227

 
# 236

 
# 246

 
# 252

# 254

 
# 263

 
# 270

 
# 278

# 285

struct in_addr {
	union {
		struct { uint8_t s_b1, s_b2, s_b3, s_b4; }  S_un_b ;
		struct { uint16_t s_w1, s_w2; }  S_un_w ;
# 291
		uint32_t  S_addr ;
# 295
	}  S_un ;
# 302
};

 
# 314

# 320

# 325

# 331

# 334

# 339

# 345

 
# 355

 
# 358

 
# 363

# 365

 
# 374

 
# 378
struct sockaddr_in {
	sa_family_t	sin_family;
	in_port_t	sin_port;
	struct	in_addr sin_addr;
# 383
	char		sin_zero[8];
# 387
};

# 390
 
# 393
struct sockaddr_in6 {
	sa_family_t	sin6_family;
	in_port_t	sin6_port;
	uint32_t	sin6_flowinfo;
	struct in6_addr	sin6_addr;
	uint32_t	sin6_scope_id;   
	uint32_t	__sin6_src_id;	 
};

 
# 408

 
# 412

# 420

 
# 431


# 443

# 448

# 454

 
# 464

 
# 488

# 494

# 508

# 516

# 524

# 532

# 544

 
# 563

 
# 572

# 581

 
# 591

# 596

# 604

# 612

# 620

# 628

# 636

 
# 656

 
# 662

# 670

# 675

 
# 685

 
# 692

 
# 709

 
# 746

 
# 766

 
# 804

 
# 820

# 822


 
# 835

# 837

# 841

# 845

# 853

# 864
 
# 870

# 872
 
# 879
 
# 884

typedef struct ipsec_req {
	uint_t 		ipsr_ah_req;		 
	uint_t 		ipsr_esp_req;		 
	uint_t		ipsr_self_encap_req;	 
	uint8_t		ipsr_auth_alg;		 
	uint8_t		ipsr_esp_alg;		 
	uint8_t		ipsr_esp_auth_alg;	 
} ipsec_req_t;

 
# 907

 
# 913
 
# 919
 
# 926

 
# 933

# 937

# 941

 
# 948

 
# 955

# 957
 
# 960
struct ip_mreq {
	struct in_addr	imr_multiaddr;	 
	struct in_addr	imr_interface;	 
};

 
# 969
struct ip_mreq_source {
	struct in_addr	imr_multiaddr;	 
	struct in_addr	imr_sourceaddr;	 
	struct in_addr	imr_interface;	 
};

 
# 979
struct ipv6_mreq {
	struct in6_addr	ipv6mr_multiaddr;	 
	unsigned int	ipv6mr_interface;	 
};

 
# 994

 
# 998
struct group_req {
	uint32_t		gr_interface;	 
	struct sockaddr_storage	gr_group;	 
};

 
# 1007
struct group_source_req {
	uint32_t		gsr_interface;	 
	struct sockaddr_storage	gsr_group;	 
	struct sockaddr_storage	gsr_source;	 
};

 
# 1016
struct group_filter {
	uint32_t		gf_interface;	 
	struct sockaddr_storage	gf_group;	 
	uint32_t		gf_fmode;	 
	uint32_t		gf_numsrc;	 
	struct sockaddr_storage	gf_slist[1];	 
};

# 1027

# 1031

 
# 1035
struct ip_msfilter {
	struct in_addr	imsf_multiaddr;	 
	struct in_addr	imsf_interface;	 
	uint32_t	imsf_fmode;	 
	uint32_t	imsf_numsrc;	 
	struct in_addr	imsf_slist[1];	 
};

# 1046

 
# 1051
int setsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t,
			uint_t, struct sockaddr_storage *);

int getsourcefilter(int, uint32_t, struct sockaddr *, socklen_t, uint32_t *,
			uint_t *, struct sockaddr_storage *);

int setipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t,
			uint32_t, struct in_addr *);

int getipv4sourcefilter(int, struct in_addr, struct in_addr, uint32_t *,
			uint32_t *, struct in_addr *);

 
# 1068

 
# 1072
typedef struct in_pktinfo {
	unsigned int		ipi_ifindex;	 
	struct in_addr		ipi_spec_dst;	 
	struct in_addr		ipi_addr;	 
} in_pktinfo_t;

 
# 1081
struct in6_pktinfo {
	struct in6_addr		ipi6_addr;	 
	unsigned int		ipi6_ifindex;	 
};

 
# 1089
struct ip6_mtuinfo {
	struct sockaddr_in6	ip6m_addr;  
	uint32_t		ip6m_mtu;   
};

 
# 1098

extern socklen_t inet6_rth_space(int type, int segments);
extern void *inet6_rth_init(void *bp, socklen_t bp_len, int type, int segments);
extern int inet6_rth_add(void *bp, const struct in6_addr *addr);
extern int inet6_rth_reverse(const void *in, void *out);
extern int inet6_rth_segments(const void *bp);
extern struct in6_addr *inet6_rth_getaddr(const void *bp, int index);

extern int inet6_opt_init(void *extbuf, socklen_t extlen);
extern int inet6_opt_append(void *extbuf, socklen_t extlen, int offset,
	uint8_t type, socklen_t len, uint_t align, void **databufp);
extern int inet6_opt_finish(void *extbuf, socklen_t extlen, int offset);
extern int inet6_opt_set_val(void *databuf, int offset, void *val,
	socklen_t vallen);
extern int inet6_opt_next(void *extbuf, socklen_t extlen, int offset,
	uint8_t *typep, socklen_t *lenp, void **databufp);
extern int inet6_opt_find(void *extbufp, socklen_t extlen, int offset,
	uint8_t type, socklen_t *lenp, void **databufp);
extern int inet6_opt_get_val(void *databuf, int offset, void *val,
	socklen_t vallen);
# 1119

 
# 1125
typedef struct {
	struct in_addr	in_prefix_addr;
	unsigned int	in_prefix_len;
} in_prefix_t;


# 1132
 
# 1136
					 
					 
# 1139
					 
					 
# 1142
					 
					 
# 1145
					 
					 
# 1148
					 
# 1150
					 
 
# 1157
					 
# 1159
					 

# 1162
					 
# 1167
					 
# 1170
					 
# 1174

 
# 1180

# 1182

 
# 1188

# 1199

 
# 1204

 
# 1214

 
# 1222

# 1229

# 1232

# 1235

 
# 1241
					 
# 1243
					 
 
# 1251

 
# 1256
					 
# 1258
					 
# 1260

# 1262

 
# 1269
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 1277

# 1281

# 54 "/usr/include/sys/socket.h"

# 58

# 80

 
# 92

 
# 107

 
# 122

# 126

 
# 132

 
# 148

 
# 151

# 156

# 159

# 165

# 173

 
# 177
struct	linger {
	int	l_onoff;		 
	int	l_linger;		 
};

 
# 186

 
# 221

# 223

 
# 258

# 260

 
# 265

 
# 269
struct msghdr {
	void		*msg_name;		 
	socklen_t	msg_namelen;		 
	struct iovec	*msg_iov;		 
	int		msg_iovlen;		 

# 280
	caddr_t		msg_accrights;	 
	int		msg_accrightslen;
# 283
};

# 328

# 332
 
# 337
 
# 341

# 343

 
# 348

struct cmsghdr {
	socklen_t	cmsg_len;	 
	int		cmsg_level;	 
	int		cmsg_type;	 
};

# 364

# 401

# 424

# 432

# 435
extern int accept(int, struct sockaddr *, Psocklen_t);
extern int bind(int, const struct sockaddr *, socklen_t);
extern int connect(int, const struct sockaddr *, socklen_t);
extern int getpeername(int, struct sockaddr *, Psocklen_t);
extern int getsockname(int, struct sockaddr *, Psocklen_t);
extern int getsockopt(int, int, int, void *, Psocklen_t);
extern int listen(int, int);	 
extern int socketpair(int, int, int, int *);
extern ssize_t recv(int, void *, size_t, int);
extern ssize_t recvfrom(int, void *, size_t, int,
	struct sockaddr *, Psocklen_t);
extern ssize_t recvmsg(int, struct msghdr *, int);
extern ssize_t send(int, const void *, size_t, int);
extern ssize_t sendmsg(int, const struct msghdr *, int);
extern ssize_t sendto(int, const void *, size_t, int, const struct sockaddr *,
	socklen_t);
extern int setsockopt(int, int, int, const void *, socklen_t);
extern int shutdown(int, int);
extern int socket(int, int, int);

# 456
extern int sockatmark(int);
# 479

# 483

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/string.h"
 
# 21
 
 


 
# 29

# 32

#ident	"@(#)string.h	1.31	06/11/13 SMI"

# 1 "/usr/include/iso/string_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)string_iso.h	1.8	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 49 "/usr/include/iso/string_iso.h"

# 53

# 57

# 66

# 74

# 76

extern int memcmp(const void *, const void *, size_t);
extern void *memcpy(void *, const void *, size_t);
extern void *memmove(void *, const void *, size_t);
extern void *memset(void *, int, size_t);
extern char *strcat(char *, const char *);
extern int strcmp(const char *, const char *);
extern char *strcpy(char *, const char *);
extern int strcoll(const char *, const char *);
extern size_t strcspn(const char *, const char *);
extern char *strerror(int);
extern size_t strlen(const char *);
extern char *strncat(char *, const char *, size_t);
extern int strncmp(const char *, const char *, size_t);
extern char *strncpy(char *, const char *, size_t);
extern size_t strspn(const char *, const char *);
extern char *strtok(char *, const char *);
extern size_t strxfrm(char *, const char *, size_t);

 
# 147
extern void *memchr(const void *, int, size_t);
extern char *strchr(const char *, int);
extern char *strpbrk(const char *, const char *);
extern char *strrchr(const char *, int);
extern char *strstr(const char *, const char *);
# 153

# 180

# 184

# 188

# 36 "/usr/include/string.h"

 
# 66

# 70

# 72

# 76
extern int strerror_r(int, char *, size_t);
# 78

# 82
extern char *strtok_r(char *, const char *,
	char **);
# 85

# 88
extern void *memccpy(void *, const void *,
		int, size_t);
# 91

# 94
extern int uucopy(const void *, void *, size_t);
extern int uucopystr(const void *, void *, size_t);
extern char *strsignal(int);
extern size_t strnlen(const char *, size_t);
extern int ffs(int);
extern int strcasecmp(const char *, const char *);
extern int strncasecmp(const char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);
extern size_t strlcat(char *, const char *, size_t);
# 104

# 108
extern char *strdup(const char *);
# 110

# 145

# 149

# 1 "/usr/include/ctype.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)ctype.h	1.37	05/06/08 SMI"

# 1 "/usr/include/iso/ctype_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)ctype_iso.h	1.5	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 49 "/usr/include/iso/ctype_iso.h"

# 53

# 62

# 75


# 78

# 80

extern int isalnum(int);
extern int isalpha(int);
extern int iscntrl(int);
extern int isdigit(int);
extern int isgraph(int);
extern int islower(int);
extern int isprint(int);
extern int ispunct(int);
extern int isspace(int);
extern int isupper(int);
extern int isxdigit(int);

# 94

# 98

extern int tolower(int);
extern int toupper(int);

# 105

extern unsigned char	__ctype[];
extern unsigned int	*__ctype_mask;
extern int		*__trans_upper;
extern int		*__trans_lower;

# 112

# 147

# 172

# 174

# 176

# 178

# 200

# 204

# 1 "/usr/include/iso/ctype_c99.h"
 
# 22
 
# 26

 
# 37

# 40

#ident	"@(#)ctype_c99.h	1.3	05/06/08 SMI"

# 46

 
# 54

# 56

# 59
extern int isblank(int);
# 61

# 63

# 69

# 71

# 81

# 85

# 38 "/usr/include/ctype.h"

 
# 58

# 62

# 64

# 68

extern int isascii(int);
extern int toascii(int);
extern int _tolower(int);
extern int _toupper(int);

# 75

# 77

# 90

# 92

# 94

# 107

# 111

# 1 "/usr/include/stdio.h"
 
# 22
 
 


 
# 30

 
# 34

# 37

#ident	"@(#)stdio.h	1.86	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 41 "/usr/include/stdio.h"

# 45

 
# 52

 
# 65

 
#pragma	redefine_extname	fopen64		fopen
#pragma	redefine_extname	freopen64	freopen
#pragma	redefine_extname	tmpfile64	tmpfile
#pragma	redefine_extname	fgetpos64	fgetpos
#pragma	redefine_extname	fsetpos64	fsetpos
#pragma	redefine_extname	fseeko64	fseeko
#pragma	redefine_extname	ftello64	ftello
# 78

# 80

# 84

# 1 "/usr/include/iso/stdio_iso.h"
 
# 22
 
# 26

 
 

 
# 41

 
# 45

# 48

#ident	"@(#)stdio_iso.h	1.10	05/06/13 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/va_list.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)va_list.h	1.17	05/06/08 SMI"

 
# 55

 
# 68

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 70 "/usr/include/sys/va_list.h"

# 74

# 80

# 82

# 85

# 92

# 126

typedef  void *__va_list;

# 130

# 134

# 1 "/usr/include/stdio_tag.h"
 
# 22
 
# 26

# 29

#ident	"@(#)stdio_tag.h	1.5	05/06/08 SMI"

# 35

# 42
typedef struct  __FILE __FILE;
# 44

# 48

# 1 "/usr/include/stdio_impl.h"
 
# 21

 
# 26

# 29

#ident	"@(#)stdio_impl.h	1.16	06/04/18 SMI"

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 33 "/usr/include/stdio_impl.h"

# 37

# 39

# 41

struct  __FILE {
	long	__pad[16];
};

# 47

# 72

# 76

# 55 "/usr/include/iso/stdio_iso.h"

 
# 63

# 67

# 84

# 88

# 91
typedef	__FILE FILE;
# 93

# 102

# 104
typedef long		fpos_t;
# 108

# 112

# 120

# 122

 
# 134

# 136

# 142

# 147

# 151

# 154

# 159

# 161

# 163
extern __FILE	__iob[ 20 ];
# 173

# 177

# 203

# 205

extern int	remove(const char *);
extern int	rename(const char *, const char *);
extern FILE	*tmpfile(void);
extern char	*tmpnam(char *);
extern int	fclose(FILE *);
extern int	fflush(FILE *);
extern FILE	*fopen(const char *, const char *);
extern FILE	*freopen(const char *,
			const char *, FILE *);
extern void	setbuf(FILE *, char *);
extern int	setvbuf(FILE *, char *, int,
			size_t);
 
extern int	fprintf(FILE *, const char *, ...);
 
extern int	fscanf(FILE *, const char *, ...);
 
extern int	printf(const char *, ...);
 
extern int	scanf(const char *, ...);
 
extern int	sprintf(char *, const char *, ...);
 
extern int	sscanf(const char *,
			const char *, ...);
extern int	vfprintf(FILE *, const char *,
			__va_list);
extern int	vprintf(const char *, __va_list);
extern int	vsprintf(char *, const char *,
			__va_list);
extern int	fgetc(FILE *);
extern char	*fgets(char *, int, FILE *);
extern int	fputc(int, FILE *);
extern int	fputs(const char *, FILE *);
# 242
extern int	getc(FILE *);
extern int	putc(int, FILE *);
# 247
extern int	getchar(void);
extern int	putchar(int);
# 250
extern char	*gets(char *);
extern int	puts(const char *);
extern int	ungetc(int, FILE *);
extern size_t	fread(void *, size_t, size_t,
	FILE *);
extern size_t	fwrite(const void *, size_t, size_t,
	FILE *);
# 258
extern int	fgetpos(FILE *, fpos_t *);
extern int	fsetpos(FILE *, const fpos_t *);
# 261
extern int	fseek(FILE *, long, int);
extern long	ftell(FILE *);
extern void	rewind(FILE *);
# 266
extern void	clearerr(FILE *);
extern int	feof(FILE *);
extern int	ferror(FILE *);
# 270
extern void	perror(const char *);

# 276

# 327

# 331

# 333

# 357

# 385

# 387

# 391

# 86 "/usr/include/stdio.h"

 
# 94

 
# 149

 
# 1 "/usr/include/iso/stdio_c99.h"
 
# 22
 
# 26

 
# 37

# 40

#ident	"@(#)stdio_c99.h	1.3	05/06/08 SMI"

# 46

 
# 54

# 57

# 73

# 75
extern int vfscanf(FILE *, const char *, __va_list);
extern int vscanf(const char *, __va_list);
extern int vsscanf(const char *, const char *,
		__va_list);
# 89
extern int snprintf(char *, size_t, const char *,
	...);
extern int vsnprintf(char *, size_t, const char *,
	__va_list);
# 97

# 99

# 103

# 155 "/usr/include/stdio.h"

# 159

# 177

# 180
typedef fpos_t		fpos64_t;
# 185

 
# 195

# 198

# 200

 
# 205

# 207

# 211

# 214

# 216
extern unsigned char	 _sibuf[], _sobuf[];
# 218

 
# 246

# 251

 
# 266

# 268

# 272
extern char	*tmpnam_r(char *);
# 274

# 277
extern void setbuffer(FILE *, char *, size_t);
extern int setlinebuf(FILE *);
# 280

 
# 286

extern FILE	*fdopen(int, const char *);
extern char	*ctermid(char *);
extern int	fileno(FILE *);

# 292

 
# 298
extern void	flockfile(FILE *);
extern int	ftrylockfile(FILE *);
extern void	funlockfile(FILE *);
extern int	getc_unlocked(FILE *);
extern int	getchar_unlocked(void);
extern int	putc_unlocked(int, FILE *);
extern int	putchar_unlocked(int);

# 307

 
# 313
extern FILE	*popen(const char *, const char *);
extern char	*tempnam(const char *, const char *);
extern int	pclose(FILE *);
# 317
extern int	getsubopt(char **, char *const *, char **);
# 319

 
# 322
extern char	*cuserid(char *);
extern int	getopt(int, char *const *, const char *);
extern char	*optarg;
extern int	optind, opterr, optopt;
extern int	getw(FILE *);
extern int	putw(int, FILE *);
# 329

# 331

 
# 336
extern int	fseeko(FILE *, off_t, int);
extern off_t	ftello(FILE *);
# 339

 
# 346
extern FILE	*fopen64(const char *, const char *);
extern FILE	*freopen64(const char *, const char *, FILE *);
extern FILE	*tmpfile64(void);
extern int	fgetpos64(FILE *, fpos64_t *);
extern int	fsetpos64(FILE *, const fpos64_t *);
extern int	fseeko64(FILE *, off64_t, int);
extern off64_t	ftello64(FILE *);
# 354

# 427

# 429

# 454

# 456

# 460

# 1 "/usr/include/assert.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)assert.h	1.12	05/06/08 SMI"

# 39

# 44
extern void __assert(const char *, const char *, int);
# 49

# 53

# 55

 
# 62

# 64

# 70

# 81

# 1 "/usr/include/setjmp.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)setjmp.h	1.40	05/06/08 SMI"

# 1 "/usr/include/iso/setjmp_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)setjmp_iso.h	1.5	05/06/11 SMI"
 

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 50 "/usr/include/iso/setjmp_iso.h"

# 54

# 56

 
# 77

# 81

# 85
typedef long	jmp_buf[ 12 ];
# 92

# 94

extern int setjmp(jmp_buf);
#pragma	unknown_control_flow(setjmp)
# 97
extern int _setjmp(jmp_buf);
#pragma	unknown_control_flow(_setjmp)
# 99
extern void longjmp(jmp_buf, int) ;
extern void _longjmp(jmp_buf, int) ;

# 112

# 116

# 120

# 124

# 126

# 130

# 37 "/usr/include/setjmp.h"

 
# 46

# 50

# 52

# 55
 

# 58
typedef long sigjmp_buf[ 19 ];
# 62

extern int sigsetjmp(sigjmp_buf, int);
#pragma	unknown_control_flow(sigsetjmp)
# 65
extern void siglongjmp(sigjmp_buf, int) ;
# 67

# 81

# 85

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 29

#ident	"@(#)pthread.h	1.39	07/03/14 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 33 "/usr/include/pthread.h"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sched.h"
 
# 22
 
# 26

# 29

#ident	"@(#)sched.h	1.11	05/06/08 SMI"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 34 "/usr/include/sched.h"

# 38

struct sched_param {
	int	sched_priority;	 
	int	sched_nicelim;	 
	int	sched_nice;	 
	int	sched_pad[6];	 
				 
				 
				 
};

 
# 58

 
# 63
int	sched_getparam(pid_t, struct sched_param *);
int	sched_setparam(pid_t, const struct sched_param *);
int	sched_getscheduler(pid_t);
int	sched_setscheduler(pid_t, int, const struct sched_param *);
int	sched_yield(void);
int	sched_get_priority_max(int);
int	sched_get_priority_min(int);
int	sched_rr_get_interval(pid_t, struct timespec *);
# 81

# 85

# 39 "/usr/include/pthread.h"

# 43

 
# 49
 
# 52
 
# 55

 
# 59
 
# 62

 
# 70

# 75

 
# 84

 
# 91

 
# 101

 
# 113

# 116

# 120

 
# 127

 
# 132

 
# 139

 
# 142

# 144

 
# 148
typedef struct _cleanup {
	uintptr_t	pthread_cleanup_pad[4];
} _cleanup_t;

# 153

void	__pthread_cleanup_push(void (*)(void *), void *, caddr_t, _cleanup_t *);
void	__pthread_cleanup_pop(int, _cleanup_t *);
caddr_t	_getfp(void);

# 165

# 169

typedef void (*_Voidfp)(void*);  

# 175

# 180

# 184

# 186

 
# 190

 
# 198
extern int pthread_atfork(void (*) (void), void (*) (void), void (*) (void));
extern int pthread_attr_init(pthread_attr_t *);
extern int pthread_attr_destroy(pthread_attr_t *);
extern int pthread_attr_setstack(pthread_attr_t *, void *, size_t);
extern int pthread_attr_getstack(const pthread_attr_t *,
		void **, size_t *);
extern int pthread_attr_setstacksize(pthread_attr_t *, size_t);
extern int pthread_attr_getstacksize(const pthread_attr_t *,
		size_t *);
extern int pthread_attr_setstackaddr(pthread_attr_t *, void *);
extern int pthread_attr_getstackaddr(const pthread_attr_t *,
		void **);
extern int pthread_attr_setdetachstate(pthread_attr_t *, int);
extern int pthread_attr_getdetachstate(const pthread_attr_t *, int *);
extern int pthread_attr_setscope(pthread_attr_t *, int);
extern int pthread_attr_getscope(const pthread_attr_t *,
	int *);
extern int pthread_attr_setinheritsched(pthread_attr_t *, int);
extern int pthread_attr_getinheritsched(const pthread_attr_t *,
	int *);
extern int pthread_attr_setschedpolicy(pthread_attr_t *, int);
extern int pthread_attr_getschedpolicy(const pthread_attr_t *,
	int *);
extern int pthread_attr_setschedparam(pthread_attr_t *,
		const struct sched_param *);
extern int pthread_attr_getschedparam(const pthread_attr_t *,
		struct sched_param *);
extern int pthread_create(pthread_t *,
		const pthread_attr_t *, void * (*)(void *),
		void *);
extern int pthread_once(pthread_once_t *, void (*)(void));
extern int pthread_join(pthread_t, void **);
extern int pthread_detach(pthread_t);
extern void pthread_exit(void *) ;
extern int pthread_cancel(pthread_t);
extern int pthread_setschedparam(pthread_t, int, const struct sched_param *);
extern int pthread_getschedparam(pthread_t, int *,
		struct sched_param *);
extern int pthread_setschedprio(pthread_t, int);
extern int pthread_setcancelstate(int, int *);
extern int pthread_setcanceltype(int, int *);
extern void pthread_testcancel(void);
extern int pthread_equal(pthread_t, pthread_t);
extern int pthread_key_create(pthread_key_t *, void (*)(void *));
extern int pthread_key_create_once_np(pthread_key_t *, void (*)(void *));
extern int pthread_key_delete(pthread_key_t);
extern int pthread_setspecific(pthread_key_t, const void *);
extern void *pthread_getspecific(pthread_key_t);
extern pthread_t pthread_self(void);

 
# 251
extern int pthread_mutexattr_init(pthread_mutexattr_t *);
extern int pthread_mutexattr_destroy(pthread_mutexattr_t *);
extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_getpshared(
	const pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_getprotocol(
	const pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_getprioceiling(
	const pthread_mutexattr_t *, int *);
extern int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_getrobust_np(
	const pthread_mutexattr_t *, int *);
extern int pthread_mutex_init(pthread_mutex_t *,
	const pthread_mutexattr_t *);
extern int pthread_mutex_consistent_np(pthread_mutex_t *);
extern int pthread_mutex_destroy(pthread_mutex_t *);
extern int pthread_mutex_lock(pthread_mutex_t *);
extern int pthread_mutex_timedlock(pthread_mutex_t *,
	const struct timespec *);
extern int pthread_mutex_reltimedlock_np(pthread_mutex_t *,
	const struct timespec *);
extern int pthread_mutex_unlock(pthread_mutex_t *);
extern int pthread_mutex_trylock(pthread_mutex_t *);
extern int pthread_mutex_setprioceiling(pthread_mutex_t *,
	int, int *);
extern int pthread_mutex_getprioceiling(const pthread_mutex_t *,
	int *);
extern int pthread_condattr_init(pthread_condattr_t *);
extern int pthread_condattr_destroy(pthread_condattr_t *);
extern int pthread_condattr_setclock(pthread_condattr_t *, clockid_t);
extern int pthread_condattr_getclock(const pthread_condattr_t *,
	clockid_t *);
extern int pthread_condattr_setpshared(pthread_condattr_t *, int);
extern int pthread_condattr_getpshared(const pthread_condattr_t *,
	int *);
extern int pthread_cond_init(pthread_cond_t *,
	const pthread_condattr_t *);
extern int pthread_cond_destroy(pthread_cond_t *);
extern int pthread_cond_broadcast(pthread_cond_t *);
extern int pthread_cond_signal(pthread_cond_t *);
extern int pthread_cond_wait(pthread_cond_t *,
	pthread_mutex_t *);
extern int pthread_cond_timedwait(pthread_cond_t *,
	pthread_mutex_t *, const struct timespec *);
extern int pthread_cond_reltimedwait_np(pthread_cond_t *,
	pthread_mutex_t *, const struct timespec *);
extern int pthread_attr_getguardsize(const pthread_attr_t *,
	size_t *);
extern int pthread_attr_setguardsize(pthread_attr_t *, size_t);
extern int pthread_getconcurrency(void);
extern int pthread_setconcurrency(int);
extern int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *,
	int *);
extern int pthread_rwlock_init(pthread_rwlock_t *,
	const pthread_rwlockattr_t *);
extern int pthread_rwlock_destroy(pthread_rwlock_t *);
extern int pthread_rwlock_rdlock(pthread_rwlock_t *);
extern int pthread_rwlock_timedrdlock(pthread_rwlock_t *,
	const struct timespec *);
extern int pthread_rwlock_reltimedrdlock_np(pthread_rwlock_t *,
	const struct timespec *);
extern int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
extern int pthread_rwlock_wrlock(pthread_rwlock_t *);
extern int pthread_rwlock_timedwrlock(pthread_rwlock_t *,
	const struct timespec *);
extern int pthread_rwlock_reltimedwrlock_np(pthread_rwlock_t *,
	const struct timespec *);
extern int pthread_rwlock_trywrlock(pthread_rwlock_t *);
extern int pthread_rwlock_unlock(pthread_rwlock_t *);
extern int pthread_rwlockattr_init(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
extern int pthread_rwlockattr_getpshared(
	const pthread_rwlockattr_t *, int *);
extern int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);
extern int pthread_spin_init(pthread_spinlock_t *, int);
extern int pthread_spin_destroy(pthread_spinlock_t *);
extern int pthread_spin_lock(pthread_spinlock_t *);
extern int pthread_spin_trylock(pthread_spinlock_t *);
extern int pthread_spin_unlock(pthread_spinlock_t *);
extern int pthread_barrierattr_init(pthread_barrierattr_t *);
extern int pthread_barrierattr_destroy(pthread_barrierattr_t *);
extern int pthread_barrierattr_setpshared(pthread_barrierattr_t *, int);
extern int pthread_barrierattr_getpshared(
	const pthread_barrierattr_t *, int *);
extern int pthread_barrier_init(pthread_barrier_t *,
	const pthread_barrierattr_t *, uint_t);
extern int pthread_barrier_destroy(pthread_barrier_t *);
extern int pthread_barrier_wait(pthread_barrier_t *);

# 453

# 455

# 459

# 25 "WeaverConnection.c"

# 27

# 1 "../../include/env/connectionutil.h"
 
# 11

# 14

# 1 "../../include/c.h"
 
# 15
 
# 41

 
# 46

# 1 "../../include/config.h"
 
 
# 14

# 17

# 1 "../../include/os.h"

# 4
 
# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 6 "../../include/os.h"

# 14

# 18

# 20

typedef pthread_mutex_t slock_t; 
extern char*	tzname[2];

# 36

# 40

extern  void* base_mem_alloc(size_t size);
extern  void base_mem_free(void* pointer);
extern  void* base_mem_realloc(void* pointer, size_t size);

# 48

# 19 "../../include/config.h"

# 26
 
 
 
 
 
 
 
 
 
 

# 46

# 50

# 52

# 56

# 59
 
# 61
 
# 68
 
# 73

 
# 82

 
# 87
 
 
# 90

 
# 108
 
# 114

 
# 122

 
# 136

 
# 141
 

 
# 147
 

 
# 156
 

 
# 167

 
# 177

 
# 182
 

 
# 192
 

 
# 205

 
# 211

 
# 216
 

 
# 224
 

 
 
 
 
 
 
 
 
 
 
 
 

 
# 250

 
# 255


 
# 262

 
 

 
 

 
 

 
 

  
# 281

 
 

 
# 287

 
 

 
 

 
# 296

 
# 299

 
# 304
 
 

 
 

 
# 312

 
 

 
 

 
 

 
# 324

 
# 327

 
# 330

 
# 333

 
 

 
 

 
 

 
# 345

 
# 348

 
# 351

 
# 354

 
 

 
 

 
 

 
 

 
# 370

 
# 373

 
# 376

 
# 379

 
# 383

 
# 389

 
# 392

 
# 395

 
# 398

 
# 401

 
# 404

 
# 410
 
 
 
 
 
# 422

 
# 428

 
 

 
# 437
 

 
# 441

 
 
# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/netinet/in.h"
 
# 5
 
# 16

 
# 26

# 1 "/usr/include/arpa/inet.h"
 
# 22
 
# 26

 
 

 
# 34

# 37

#ident	"@(#)inet.h	1.23	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 41 "/usr/include/arpa/inet.h"

# 1 "/usr/include/sys/socket.h"
 
# 21
 
# 25

 
 

 
# 38

# 45 "/usr/include/arpa/inet.h"

# 1 "/usr/include/netinet/in.h"
 
# 5
 
# 16

 
# 26

# 50 "/usr/include/arpa/inet.h"

# 54

 
# 61
extern int inet_net_pton(int, const char *, void *, size_t);
# 63

# 65
extern int inet_pton(int, const char *, void *);
extern const char *inet_ntop(int, const void *,
			char *, socklen_t);
# 69

extern in_addr_t inet_addr(const char *);

extern in_addr_t inet_lnaof(struct in_addr);
extern struct in_addr inet_makeaddr(in_addr_t, in_addr_t);
extern in_addr_t inet_netof(struct in_addr);
extern in_addr_t inet_network(const char *);
extern char *inet_ntoa(struct in_addr);
extern int inet_aton(const char *, struct in_addr *);
# 89

# 93

# 452 "../../include/config.h"
extern int  inet_aton(const char *cp, struct in_addr * addr);
# 454

 
# 457

 
# 460

 
# 463

 
# 466

 
# 469

 
# 480

 
# 483

 
# 486

 
# 489

 
# 492

 
# 495

 
# 501

 
# 504

 
# 507

 
# 513

 
 

 
 

 
 

 
 

 
 

 
 


 
# 539
 
 

 
 

 
 

 
# 550

 
# 553

 
# 569

 
# 572

 
# 575

 
# 578

 
# 581


 
# 586
 
# 589
  
# 597

# 601


# 48 "../../include/c.h"


# 1 "/usr/include/stdio.h"
 
# 22
 
 


 
# 30

 
# 34

# 1 "/usr/include/stdlib.h"
 
# 21
 
# 25

 
 


# 1 "/usr/include/string.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/stddef.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)stddef.h	1.22	05/08/18 SMI"

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 1 "/usr/include/iso/stddef_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)stddef_iso.h	1.4	05/06/08 SMI"

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 49 "/usr/include/iso/stddef_iso.h"

# 53

# 57

# 65

# 74

# 83

# 87

# 93

# 97

# 38 "/usr/include/stddef.h"

 
# 47

# 51

 
# 75

# 79

# 1 "/usr/include/stdarg.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)stdarg.h	1.49	05/06/08 SMI"

 
# 47

# 49

# 1 "/usr/include/iso/stdarg_iso.h"
 
# 22
 
 


 
# 30

 
# 42

# 45

#ident	"@(#)stdarg_iso.h	1.6	05/06/08 SMI"

 
# 58

# 1 "/usr/include/sys/va_impl.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)va_impl.h	1.3	05/06/08 SMI"

 
# 51

 
# 67

 
# 76

 
# 91

 
# 104

# 1 "/usr/include/sys/va_list.h"
 
# 22
 
 


 
# 30

# 106 "/usr/include/sys/va_impl.h"

# 110

# 142

# 149

# 171

# 175

# 60 "/usr/include/iso/stdarg_iso.h"

# 64

# 71
typedef __va_list va_list;
# 73

# 77

# 81

# 1 "/usr/include/iso/stdarg_c99.h"
 
# 22
 
 


 
# 30

# 33

#ident	"@(#)stdarg_c99.h	1.4	05/06/08 SMI"

 
# 51

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 53 "/usr/include/iso/stdarg_c99.h"

# 57

 
# 66

# 68

# 70

# 74

# 52 "/usr/include/stdarg.h"

 
# 60

# 66

# 57 "../../include/c.h"

# 61

 
# 66
 
# 73
typedef char bool;

# 83
typedef bool *BoolPtr;

# 88

# 92

 
# 100

 
# 108

 
# 119

# 122

# 139

 
# 149

 
# 154

 
# 162
typedef char *Pointer;

 
# 170
typedef signed char int8;		 
typedef signed short int16;		 
typedef signed int int32;		 
typedef signed long long int64;
 
# 180
typedef unsigned char uint8;	 
typedef unsigned short uint16;	 
typedef unsigned int uint32;	 
typedef unsigned long long uint64;
 
# 192
typedef float float32data;
typedef double float64data;
typedef float *float32;
typedef double *float64;

 
# 201
typedef uint8 bool8;			 
typedef uint16 bool16;			 
typedef uint32 bool32;			 

 
# 209
typedef uint8 bits8;			 
typedef uint16 bits16;			 
typedef uint32 bits32;			 

 
# 218
typedef uint8 word8;			 
typedef uint16 word16;			 
typedef uint32 word32;			 

 
# 226
typedef size_t Size;

 
# 235
typedef unsigned int Index;

# 238
typedef struct
{
	int			indx[ 6 ];
} IntArray;

 
# 251
typedef signed int Offset;

 
# 257
 
# 279
 
typedef unsigned long Datum;	 
typedef Datum TupleCount;
typedef Datum *DatumPtr;

# 321
 
# 325

# 327

 
# 332

# 334

 
# 339

# 341

 
# 346

# 348

 
# 353

# 355

 
# 360

# 362

 
# 367

# 369

 
# 374

# 376

 
# 381

# 383

 
# 388

# 390

 
# 395

# 397

 
# 402

# 404


 
# 410

# 412

# 414
 
# 418

# 420

 
# 425

# 427

 
# 432

# 434


 
# 440

# 442

# 447


 
# 454
 
# 459

# 480



 
# 487

# 489

 
# 494

# 496

 
# 501

# 503

 
# 508

# 510


 
# 517

# 519

 
# 525

# 527

 
# 533

# 535

 
# 541

# 543

 
# 548
 
# 553

 
# 559

 
# 566

 
# 571
 
# 581

 
# 587

 
# 593

 
# 599
 
# 602

typedef char *ExcMessage;
typedef struct Exception
{
	ExcMessage	message;
} Exception;

 
# 615

 
# 627

 
# 646
                                                                  
# 656

# 659

# 662

# 665

extern int	assert_enabled;

# 669

 
# 681

 
# 692

# 701

# 704

# 707

# 710

extern int	assertEnable(int val);

# 718

 
# 723
 
# 728

 
# 734

 
# 740

 
# 761


 
# 765

 
# 798

# 800


 
# 806

extern Exception FailedAssertion;
extern Exception BadArg;
extern Exception BadState;

 
extern int ExceptionalCondition(char *conditionName,
					 Exception *exceptionP, char *details,
					 char *fileName, int lineNumber);


 
# 821
extern char *vararg_format(const char *fmt,...);



 
# 832

 
# 843



 
# 855

# 861

# 867

 
# 871

 
# 885

 
# 890

# 895

# 900

# 904

 
# 909
 
# 911

# 917

 
# 16 "../../include/env/connectionutil.h"

# 20

extern void initweaverbackend(char* dbname);
extern bool isinitialized();
extern void prepareforshutdown(void);
extern void wrapupweaverbackend(void);
extern void singleusershutdown(int code);

extern char* GetProperty(char* key);
extern int GetMaxBackends();

# 33

# 1 "../../include/env/WeaverConnection.h"
 
# 12



# 18

# 21

# 1 "/usr/include/stdlib.h"
 
# 21
 
# 25

 
 


# 1 "/usr/include/unistd.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 25 "../../include/env/WeaverConnection.h"

# 1 "../../include/env/env.h"
 
# 9

# 12

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 1 "/usr/include/semaphore.h"
 
# 22
 
# 26

# 29

#ident	"@(#)semaphore.h	1.15	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 33 "/usr/include/semaphore.h"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/fcntl.h"
 
# 21
 
# 25

 
 

 
# 38

# 41

#ident	"@(#)fcntl.h	1.55	06/04/18 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 45 "/usr/include/sys/fcntl.h"

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 47 "/usr/include/sys/fcntl.h"

# 51

 
# 68
				 
# 77

 
# 88

 
# 100

 
# 120

# 123

# 130
 
# 135

# 139

# 141
				 

 
# 149

# 151
 
# 167

# 169

# 191

# 193

# 197

# 199

 
# 203

 
typedef struct flock {
	short	l_type;
	short	l_whence;
	off_t	l_start;
	off_t	l_len;		 
	int	l_sysid;
	pid_t	l_pid;
	long	l_pad[4];		 
} flock_t;

# 230

 

# 234

typedef struct flock64 {
	short	l_type;
	short	l_whence;
	off64_t	l_start;
	off64_t	l_len;		 
	int	l_sysid;
	pid_t	l_pid;
	long	l_pad[4];		 
} flock64_t;

# 280

# 282

# 294

 
# 302

 
# 306

# 309

 
# 316

 
# 320
typedef struct fshare {
	short	f_access;
	short	f_deny;
	int	f_id;
} fshare_t;

 
# 332

 
# 343

 
# 353

# 357

# 36 "/usr/include/semaphore.h"

# 40

typedef struct {
	 
	uint32_t	sem_count;	 
	uint16_t	sem_type;
	uint16_t	sem_magic;
	upad64_t	sem_pad1[3];	 
	upad64_t 	sem_pad2[2];	 
} sem_t;

# 51

 
# 56
int	sem_init(sem_t *, int, unsigned int);
int	sem_destroy(sem_t *);
sem_t	*sem_open(const char *, int, ...);
int	sem_close(sem_t *);
int	sem_unlink(const char *);
int	sem_wait(sem_t *);
 
# 69
struct timespec;
int	sem_timedwait(sem_t *,
		const struct timespec *);
int	sem_reltimedwait_np(sem_t *,
		const struct timespec *);
# 75
int	sem_trywait(sem_t *);
int	sem_post(sem_t *);
int	sem_getvalue(sem_t *, int *);
# 93

# 97

# 1 "/usr/include/stdio.h"
 
# 22
 
 


 
# 30

 
# 34

# 1 "/usr/include/stdlib.h"
 
# 21
 
# 25

 
 


# 1 "/usr/include/inttypes.h"
 
# 22
 
# 26

# 29

#ident	"@(#)inttypes.h	1.7	05/08/18 SMI"

 
# 40

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/inttypes.h"
 
# 22
 
# 26

# 29

#ident	"@(#)inttypes.h	1.4	05/06/08 SMI"

 
# 41

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/int_types.h"
 
# 22
 
# 26

# 1 "/usr/include/sys/int_limits.h"
 
# 22
 
# 26

# 29

#ident	"@(#)int_limits.h	1.10	05/06/08 SMI"

 
# 55

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 57 "/usr/include/sys/int_limits.h"

# 61

 
# 93

# 102

# 108

# 114

# 123

# 130

# 139

# 146

 
# 160

 
# 167

 
# 180

 
# 185

 
# 194

 
# 199

 
# 206

# 217

# 223

# 232

# 241

 
# 248

 
# 255

 
# 260

 
# 269

 
# 274

# 276

# 280

# 1 "/usr/include/sys/int_const.h"
 
# 22
 
# 26

# 29

#ident	"@(#)int_const.h	1.6	05/06/08 SMI"

 
# 53

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 55 "/usr/include/sys/int_const.h"

# 59

 
# 76
 
# 82

# 89
 
# 97

 
# 100
 
# 102
 
# 105
 
# 113

# 115
 
# 117
 
# 130

# 134

# 1 "/usr/include/sys/int_fmtio.h"
 
# 22
 
# 26

# 29

#ident	"@(#)int_fmtio.h	1.7	05/06/08 SMI"

 
# 50

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 52 "/usr/include/sys/int_fmtio.h"

# 56

 
# 78

 
# 89

# 96

# 119

# 142

 
# 146

# 167

# 188

# 209

# 230

 
# 234

# 250

 
# 271

# 289

 
# 308

# 324

# 340

# 356

 
# 375

# 382

# 386

# 49 "/usr/include/sys/inttypes.h"

# 43 "/usr/include/inttypes.h"

# 1 "/usr/include/sys/stdint.h"
 
# 22
 
# 26

# 29

#ident	"@(#)stdint.h	1.2	05/06/08 SMI"

 
# 37

# 1 "/usr/include/sys/int_types.h"
 
# 22
 
# 26

# 1 "/usr/include/sys/int_limits.h"
 
# 22
 
# 26

# 1 "/usr/include/sys/int_const.h"
 
# 22
 
# 26

# 41 "/usr/include/sys/stdint.h"

# 48 "/usr/include/inttypes.h"

# 52

 

 
# 78

# 81
typedef struct {
	intmax_t quot;
	intmax_t rem;
} imaxdiv_t;
# 86

# 104

# 107

# 109
extern intmax_t  imaxabs(intmax_t);
extern imaxdiv_t imaxdiv(intmax_t, intmax_t);
extern intmax_t  strtoimax(const char *, char **,
	int);
extern uintmax_t strtoumax(const char *, char **,
	int);
extern intmax_t  wcstoimax(const wchar_t *,
	wchar_t **, int);
extern uintmax_t wcstoumax(const wchar_t *,
	wchar_t **, int);
# 127

# 129

# 133

# 1 "/usr/include/setjmp.h"
 
# 22
 
 


 
# 30

# 19 "../../include/env/env.h"

# 1 "../../include/storage/fd.h"
 
# 14

# 1 "../../include/postgres.h"
 
# 14
 
# 38

# 1 "../../include/postgres_ext.h"
 
# 24

# 28

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 32 "../../include/postgres_ext.h"

# 35

 
# 40
 
# 43

typedef unsigned long Oid;

 
# 40 "../../include/postgres.h"

# 1 "../../include/c.h"
 
# 15
 
# 1 "../../include/utils/elog.h"
 
# 16

# 25

# 30
 void coded_elog(int lev, int code, const char *fmt,...);
 void elog(int lev, const char *fmt,...);
 int my_system(const char* cmd);
# 39

# 41

 int	DebugFileOpen(void);
# 46

# 48

# 1 "../../include/utils/palloc.h"
 
# 30


# 1 "../../include/utils/mcxt.h"
 
# 16

# 1 "../../include/c.h"
 
# 15
 
# 18 "../../include/utils/mcxt.h"

 
# 23

typedef struct MemoryContextData *MemoryContext;
typedef struct GlobalMemoryData *GlobalMemory;

typedef struct mem_manager_globals {
	MemoryContext ErrorContext;
	MemoryContext PostmasterContext;
	MemoryContext CacheMemoryContext;
	MemoryContext QueryContext;
	MemoryContext TopTransactionContext;
	MemoryContext TransactionCommandContext;
 
	MemoryContext PortalExecutorHeapMemory;
} MemoryContextGlobals;

 
# 51
  		 

 
# 59
 MemoryContextGlobals* MemoryContextGetEnv();
 void EnableMemoryContext(bool on);
 void* MemoryContextAlloc(MemoryContext context, Size size);
 
# 67
 void MemoryContextFree(MemoryContext context, Pointer pointer);
 MemoryContext MemoryContextSwitchTo(MemoryContext context);
 MemoryContext MemoryContextGetCurrentContext(void);
 GlobalMemory CreateGlobalMemory(char *name);
 void GlobalMemoryDestroy(GlobalMemory context);
 void GlobalMemoryStats(void);


# 78




# 33 "../../include/utils/palloc.h"

 
# 39
  
# 42
 
# 47
 
# 50
  
# 60


# 63

# 65

 void pfree(void *pointer);

 void *repalloc(void *pointer, Size size);

 
# 74
extern char *MemoryContextStrdup(MemoryContext context, const char *string);

# 81

# 44 "../../include/postgres.h"

 
# 49

typedef int16 int2;
typedef int32 int4;
typedef float float4;
typedef double float8;

typedef int4 aclitem;

# 59

 
typedef Oid regproc;
typedef Oid RegProcedure;

 
# 79
typedef char *((*func_ptr) ());

# 82


# 85

 
# 90
 
# 94
struct varlena
{
	int32		vl_len;
	char		vl_dat[1];
};

# 108

typedef struct varlena bytea;
typedef struct varlena text;
typedef struct varlena wrapped;

typedef int2 int2vector[ 16 ];
typedef Oid oidvector[ 16 ];

# 117
 
# 123

# 187


 
# 193
typedef union nameData
{
	char		data[ 64 ];
	int			alignmentDummy;
} NameData;
typedef NameData *Name;

# 201

 
# 206
typedef uint64_t TransactionId;


# 210
typedef uint32_t CommandId;

# 213

 
# 221

 
# 227

# 230

# 233

 
# 239

 
# 243

 
# 246

# 256

 
# 265

# 16 "../../include/storage/fd.h"

 
# 39

 
# 43

typedef char *FileName;

typedef int File;

 
# 51

 

# 57


 File FileNameOpenFile(FileName fileName, int fileFlags, int fileMode);
 File PathNameOpenFile(FileName fileName, int fileFlags, int fileMode);

 int FileOptimize(File file);
 int FileNormalize(File file);

 File OpenTemporaryFile(void);
 void FileClose(File file);
 void FileUnlink(File file);
 int	FileRead(File file, char *buffer, int amount);
 int	FileWrite(File file, char *buffer, int amount);
 long FileSeek(File file, long offset, int whence);
 int	FileTruncate(File file, long offset);
 int   FileBaseSync(File file, long offset);    
 int	FileSync(File file);
 int	FilePin(File file,int key);
 int	FileUnpin(File file,int key);
 void FileMarkDirty(File file);

 
 void InitVirtualFileSystem();
 void ShutdownVirtualFileSystem();

 
 FILE *AllocateFile(char *name, char *mode);
 void FreeFile(FILE *);

 
 bool ReleaseDataFile(void);
 void AtEOXact_Files(void);
 int	pg_fsync(int fd);

# 1 "../../include/utils/hsearch.h"
 
# 16


 
# 37

# 40


 
# 47
typedef struct HASHELEMENT
{
	struct HASHELEMENT *link;	 
    bool    freeable;
} HASHELEMENT;

 
typedef HASHELEMENT *HASHBUCKET;

 
typedef HASHBUCKET *HASHSEGMENT;

 
typedef struct HASHHDR
{
	long		dsize;			 
	long		ssize;			 
	long		sshift;			 
	long		max_bucket;		 
	long		high_mask;		 
	long		low_mask;		 
	long		ffactor;		 
	long		nentries;		 
	long		nsegs;			 
	long		keysize;		 
	long		entrysize;		 
	long		max_dsize;		 
# 75
	HASHELEMENT *freeList;		 
# 80
} HASHHDR;

 
# 86
typedef struct HTAB
{
	HASHHDR    *hctl;			 
	HASHSEGMENT *dir;			 
	long		(*hash) (void *key, int keysize);		 
	void	   *(*alloc) (Size,void*);	 
	void	   (*free) (void*,void*);	 
	MemoryContext hcxt;			 
# 95
	char	   *tabname;		 
	bool		isshared;		 
} HTAB;

 
 
typedef struct HASHCTL
{
	long		ssize;			 
	long		dsize;			 
	long		ffactor;		 
	long		(*hash) (void *key, int keysize);		 
	long		keysize;		 
	long		entrysize;		 
	long		max_dsize;		 
# 111
	void	   *(*alloc) (Size,void*);	 
	void	   (*free) (void*,void*);	 
	HASHSEGMENT *dir;			 
	HASHHDR    *hctl;			 
	MemoryContext hcxt;			 
} HASHCTL;

 
# 128


 
# 132
 
# 134

 
typedef enum
{
	HASH_FIND,
	HASH_ENTER,
	HASH_REMOVE
} HASHACTION;

 
typedef struct
{
	HTAB	   *hashp;
	long		curBucket;		 
	HASHELEMENT *curEntry;		 
} HASH_SEQ_STATUS;

 
# 154
 HTAB *hash_create(const char *tabname, long nelem,
			HASHCTL *info, int flags);
 void hash_destroy(HTAB *hashp);
 void hash_stats(const char *where, HTAB *hashp);
 void *hash_search(HTAB *hashp, void *keyPtr, HASHACTION action,
			bool *foundPtr);
 void hash_seq_init(HASH_SEQ_STATUS *status, HTAB *hashp);
 void *hash_seq_search(HASH_SEQ_STATUS *status);
 long hash_estimate_size(long num_entries, long entrysize);
 long hash_select_dirsize(long num_entries);

 
# 168
 long string_hash(void *key, int keysize);
 long tag_hash(void *key, int keysize);

# 22 "../../include/env/env.h"


# 27

typedef char SectionId[4];

# 31

# 34

typedef enum ProcessingMode
{
	BootstrapProcessing,		 
	InitProcessing,				 
	NormalProcessing,			 
	ShutdownProcessing			 
} ProcessingMode;

 
# 45

typedef enum CommitType 
{
	DEFAULT_COMMIT,
	SOFT_COMMIT,
	CAREFUL_COMMIT,
        FAST_CAREFUL_COMMIT,
        SYNCED_COMMIT,
	USER_SOFT_COMMIT,
	USER_CAREFUL_COMMIT,
	USER_FAST_CAREFUL_COMMIT,
	TRANSACTION_SOFT_COMMIT,
	TRANSACTION_CAREFUL_COMMIT,
	TRANSACTION_FAST_CAREFUL_COMMIT,
	TRANSACTION_SYNCED_COMMIT
} CommitType;


typedef struct modifiedrwlock {
	int			waitcount;
	int  			readcount;
	int			transcount;
	bool			writelock;
        pthread_t               owner;
	bool			blocked;
	pthread_mutex_t		guard;
	pthread_cond_t		gate;
} masterlock_t;

 
# 78
typedef struct Environment* EnvPointer;

typedef void*  GlobalsCache;

typedef struct Environment {
        double                  version;   
        int                     eid;
        
        pthread_mutex_t*	env_guard;
        pthread_t               owner;
        
        bool                    print_memory;
     
	bool                    fe_eof;
	int                     lineno;			 
	Oid                     LastOidProcessed;
 
	int                     holdLock;
 
        bool                    cancelled;
	bool			InError;
	char			errortext[256];
	char			state[40];
	int 			errorcode;
	int 			tupleSize;
        jmp_buf			errorContext;
 
	char* 			DatabaseName;  
	char* 			DatabasePath;  
	Oid			DatabaseId;
	char* 			UserName;
	Oid			UserId;
 
	ProcessingMode  	Mode;           
 
	char*			saved_str;
 
	char			value[256];
 
	int			TotalExpr;
 
        sigjmp_buf		errenv;
	int			insleep;
 
	int 			masterlock;
        bool			in_transaction;
	int 			cartposition;

    void*			pipeout;
    void*			pipein;

  
    File			temps[ 8 ];
    FILE*			falloc[ 8 ];	
 
    char			CommandInfo[32];
    CommitType                  system_type;
    CommitType                  user_type;
    int*   			stackmark;
        
    HTAB*			PortalHashTable;    
 
   MemoryContext 		global_context;
   MemoryContext                current_context;
# 143
   GlobalsCache                  stats_global;
   GlobalsCache                  transaction_info;
   GlobalsCache                  snapshot_holder;
   GlobalsCache                  memory_globals;
   GlobalsCache                  syscache_global;
   GlobalsCache                  relationcache_global;
   GlobalsCache                  cache_global;
   GlobalsCache                  thread_globals;
   GlobalsCache                  parser_info;   
   GlobalsCache                  cost_info;   
   GlobalsCache                  parse_expr_global;
   GlobalsCache                  temp_globals;
   GlobalsCache                  optimizer_globals;
   GlobalsCache                  buffers_global;
   GlobalsCache                  index_globals;
   GlobalsCache                  heap_globals;
   GlobalsCache                  operator_globals;
   GlobalsCache                  type_globals;
   GlobalsCache                  sequence_globals;
   GlobalsCache                  trigger_globals;
   GlobalsCache                  analyze_globals;
   GlobalsCache                  dol_globals;
   GlobalsCache                  platcat_globals;
    GlobalsCache                 parseranalyze_globals;
    GlobalsCache                 localbuffer_globals;
    GlobalsCache                 destination_globals;
    GlobalsCache                 regexp_globals;
    GlobalsCache                 invalidation_globals;
    GlobalsCache                 hash_globals;
    GlobalsCache                 tuplesort_globals;
    GlobalsCache                 xlog_globals;
    GlobalsCache                 pathcat_globals;
    GlobalsCache                 smgr_globals;    
# 177
    HTAB*   			global_hash;
    EnvPointer                  parent;
} Env;   

 

extern pthread_condattr_t	process_cond_attr;
extern pthread_mutexattr_t	process_mutex_attr;
extern masterlock_t*		masterlock;



# 193

 
# 202

Env* CreateEnv(Env* parent);
Env* GetEnv(void);
void SetEnv(void* env);
void DestroyEnv(void* env);

void* AllocateEnvSpace(SectionId id,size_t size);
int   ReleaseEnvSpace(SectionId id);
void* GetEnvSpace(SectionId id);

int InitSystem(bool  isPrivate);
int DestroySystem(void);

void DiscardAllInvalids(void);

int MasterWriteLock(void);
int MasterReadLock(void);
int MasterUnLock(void);
int MasterUpgradeLock(void);
int MasterDowngradeLock(void);
int TransactionLock(void);
int TransactionUnlock(void);

void GoMultiuser(void);
bool IsMultiuser(void);

void clearerror(Env* env);
bool CheckForCancel();
void CancelEnvAndJoin(Env* env);
pthread_t FindChildThread(Env* env);

bool IsLoggable(void);
bool IsTransactionCareful(void);
bool IsTransactionFriendly(void);
void SetTransactionCommitType(CommitType careful);
CommitType GetTransactionCommitType(void);
void ResetTransactionCommitType(void);

MemoryContext GetEnvMemoryContext(void);
void PrintEnvMemory(void);
void PrintUserMemory(void);

ProcessingMode GetProcessingMode(void);
void SetProcessingMode(ProcessingMode mode);

long prandom(void);
void sprandom(unsigned int seed);

void user_log(char* pattern, ...);

# 255

# 257

# 1 "../../include/env/WeaverInterface.h"


# 5

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/setjmp.h"
 
# 22
 
 


 
# 30

# 1 "../../include/config.h"
 
 
# 14

# 9 "../../include/env/WeaverInterface.h"


 
# 13

# 15

# 34

# 38

typedef struct error {
	int rc;
	short place;
	char  state[40];
	char text[256];
} Error;

typedef int (*pipefunc)(int,int,char*,int,int);
# 48


typedef struct Connection* OpaqueWConn;
typedef struct commbuffer*   Pipe;


 extern OpaqueWConn WCreateConnection(const char* name, const char * paslong, const char* connect);
 extern OpaqueWConn WCreateSubConnection(OpaqueWConn  conn);
 extern long WDestroyConnection(OpaqueWConn  conn);
 extern long WBegin(OpaqueWConn conn,long trans);
 extern long WParsingFunc(OpaqueWConn conn,const char* Statement);
 extern long WBindWithIndicate(OpaqueWConn conn,const char* var, void* varAdd, int varSize, short* indAdd, int varType, int cType); 
 extern long WOutputLinkInd( OpaqueWConn conn,short pos, void* varAdd,int varSize, int varType, short* ind, int* clength);
 extern long WExec(OpaqueWConn conn );
 extern long WFetch( OpaqueWConn conn );
 extern long WPrepare(OpaqueWConn conn );
 extern long WCommit( OpaqueWConn conn );
 extern long WRollback(OpaqueWConn conn );
 extern long WCancel( OpaqueWConn conn );
 extern long WBeginProcedure(OpaqueWConn conn );
 extern long WEndProcedure( OpaqueWConn conn );
 extern long WUserLock(OpaqueWConn conn, const char* group,uint32_t val,char lockit);
 extern long WIsValidConnection(OpaqueWConn conn);
 extern long WGetErrorCode(OpaqueWConn conn);
 extern long WGetTransactionId(OpaqueWConn conn);
 extern const char* WGetErrorText(OpaqueWConn conn);
 extern const char* WGetErrorState(OpaqueWConn conn);

 extern long WStreamExec(OpaqueWConn conn,char* statement);
 extern Pipe WPipeConnect(OpaqueWConn conn,int pipeid,int streamid,int size,pipefunc func);
 extern long WPipeDisconnect(OpaqueWConn conn,Pipe pipe);
 extern int WPipeSize(OpaqueWConn conn);
# 83

# 1 "../../include/catalog/pg_attribute.h"
 
# 26

 
# 33

 
# 42
 typedef struct FormData_pg_attribute  
{
	Oid			attrelid;		 
# 46
	NameData	attname;
	Oid			atttypid;

	 
# 56

	float4		attdisbursion;

	 
# 70

	int2		attlen;

	 
# 78

	int2		attnum;

	 
# 94

	int4		attnelems;		 

	int4		attcacheoff;

	 
# 106

	int4		atttypmod;

	 
# 116

	bool		attbyval;

	 
# 124

	char		attstorage;

	 
# 137

	bool		attisset;
	char		attalign;

	 
# 146

	bool		attnotnull;

	 
	bool		atthasdef;

	 
} FormData_pg_attribute;

 
# 161

 
# 167
typedef FormData_pg_attribute *Form_pg_attribute;

 
# 173

# 190


# 206
 
# 220

 
# 225

 
# 247

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 275

# 281

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 297
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 330

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 358
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;

 
# 378
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 408

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 455


 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 487
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 502
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 517
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;


 
# 544
 extern int errno ;
 extern int errno ;
 extern int errno ;
 
# 555

 extern int errno ;

 
# 566

 extern int errno ;

 
# 577

 extern int errno ;

# 1 "../../include/nodes/execnodes.h"
 
# 16

# 1 "../../include/access/funcindex.h"
 
# 16

# 1 "../../include/postgres.h"
 
# 14
 
# 18 "../../include/access/funcindex.h"

typedef struct
{
	int			nargs;
	Oid			arglist[ 16 ];
	Oid			procOid;
	NameData	funcName;
} FuncIndexInfo;

typedef FuncIndexInfo *FuncIndexInfoPtr;

 
# 32
 
# 38

# 42

# 44

# 1 "../../include/access/relscan.h"
 
# 16

# 1 "../../include/utils/tqual.h"
 
# 17


# 1 "../../include/access/htup.h"
  
# 16

# 1 "../../include/storage/bufpage.h"
 
# 16


# 1 "../../include/storage/buf.h"
 
# 16


# 20

typedef long Buffer;

 
# 28

 
# 34

 
# 40

 
# 48

# 1 "../../include/storage/page.h"
 
# 16

typedef Pointer Page;

 
# 24

# 1 "../../include/storage/item.h"
 
# 16

typedef Pointer Item;

# 1 "../../include/storage/itemid.h"
 
# 16

typedef uint32 ItemOffset;
typedef uint16 ItemLength;

typedef bits16 ItemIdFlags;



typedef struct ItemIdData
{								 
	uint32	lp_off;		 
	 
	uint16	lp_len;		 
	unsigned char	lp_flags;		 
	unsigned char	lp_overflow;		 
} ItemIdData;

typedef struct ItemIdData *ItemId;

# 38

 
# 43
 
# 48

 
# 54

 
# 60

 
# 66

 
# 79

# 1 "../../include/storage/off.h"
 
# 16

# 1 "../../include/storage/itemid.h"
 
# 18 "../../include/storage/off.h"
 
# 24
typedef uint16 OffsetNumber;

# 29


 
# 35

 
# 43

 
# 57

# 1 "../../include/storage/bufmgr.h"
 
# 16

# 1 "../../include/storage/ipc.h"
 
# 24

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/ipc.h"
 
# 22
 
# 26

 
 



# 34

#ident	"@(#)ipc.h	1.25	05/06/08 SMI"

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 40 "/usr/include/sys/ipc.h"

# 44

 

struct ipc_perm {
	uid_t		uid;	 
	gid_t		gid;	 
	uid_t		cuid;	 
	gid_t		cgid;	 
	mode_t		mode;	 
	uint_t		seq;	 
	key_t		key;	 
# 58
};


 

 
# 68

 
# 71


 
# 77


# 82
key_t ftok(const char *, int);
# 87

# 91

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 28 "../../include/storage/ipc.h"

# 1 "../../include/config.h"
 
 
# 14

# 30 "../../include/storage/ipc.h"

# 40

typedef uint16 SystemPortAddress;

 

# 46

# 51

# 56

typedef int IpcSemaphoreId;
typedef uint32 IpcSemaphoreKey;  


 

# 66

typedef uint32 IPCKey;

# 71

typedef uint32 IpcMemoryKey;	 
typedef int IpcMemoryId;



 
# 81

 void proc_exit(int code);
 void shmem_exit(int code);
 int	on_shmem_exit(void (*function) (), caddr_t arg);
 int	on_proc_exit(void (*function) (), caddr_t arg);
 void on_exit_reset(void);

 IpcSemaphoreId IpcSemaphoreCreate(IpcSemaphoreKey semKey,
				   int semNum, int permission, int semStartValue,
				   int removeOnExit);
 void IpcSemaphoreKill(IpcSemaphoreKey key);
 void IpcSemaphoreLock(IpcSemaphoreId semId, int sem, int lock);
 void IpcSemaphoreUnlock(IpcSemaphoreId semId, int sem, int lock);
 int	IpcSemaphoreGetCount(IpcSemaphoreId semId, int sem);
 int	IpcSemaphoreGetValue(IpcSemaphoreId semId, int sem);

 IpcMemoryId IpcMemoryCreate(IpcMemoryKey memKey, uint32 size,
				int permission);
 IpcMemoryId IpcMemoryIdGet(IpcMemoryKey memKey, uint32 size);
 char *IpcMemoryAttach(IpcMemoryId memId);
 void IpcMemoryKill(IpcMemoryKey memKey);
 void CreateAndInitSLockMemory(IPCKey key);
 void AttachSLockMemory(IPCKey key);

# 108

# 110

# 114

typedef enum _LockId_
{
	HEAPBUFLOCKID,
	INDEXBUFLOCKID,
	FREEBUFMGRLOCKID,
	LOCKLOCKID,
	OIDGENLOCKID,
	XIDGENLOCKID,
	CNTLFILELOCKID,
	SHMEMLOCKID,
	SHMEMINDEXLOCKID,
	SINVALLOCKID,

# 131

	PROCSTRUCTLOCKID,
	XIDSETLOCKID,
	FIRSTFREELOCKID
} _LockId_;

# 138

typedef pthread_mutex_t SLock;

# 165

 
# 172

 
# 179

 
# 186

# 189

# 192

# 199

 
# 209


 

SLock*		SLockArray;

 
# 219

 IPCKey SystemPortAddressCreateIPCKey(SystemPortAddress address);
 void CreateSharedMemoryAndSemaphores(IPCKey key, int maxBackends);
 void AttachSharedMemoryAndSemaphores(IPCKey key);
# 226

# 1 "../../include/storage/block.h"
 
# 16

 
# 31
typedef unsigned long  BlockNumber;

# 40

 
# 57
 
 typedef BlockNumber BlockIdData;
  
# 66
typedef BlockIdData *BlockId;	 

 
# 72

 
# 79

 
# 86

 
# 91
  
# 103

 
# 108
  
# 121

 
# 126
  
# 133
  
# 137
  
# 146

# 1 "../../include/storage/buf.h"
 
# 1 "../../include/storage/buf_internals.h"
 
# 16

# 1 "../../include/storage/buf.h"
 
# 1 "../../include/storage/lmgr.h"
 
# 16

# 1 "../../include/storage/lock.h"
 
# 16

# 1 "/usr/include/unistd.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 19 "../../include/storage/lock.h"

# 1 "../../include/storage/ipc.h"
 
# 1 "../../include/storage/itemptr.h"
 
# 16

# 1 "../../include/storage/block.h"
 
# 1 "../../include/storage/off.h"
 
# 19 "../../include/storage/itemptr.h"

 
# 27
 
# 31
typedef union ItemPointerData
{
	BlockIdData ip_blkid;
	OffsetNumber ip_posid;
} ItemPointerData;

# 38
	
# 45

# 48

# 50

# 62

# 64

typedef ItemPointerData *ItemPointer;
 
# 70

 
# 77

 
# 86

 
# 96

# 101
 
# 111
 
# 119
 
# 123
  
# 130
 
# 134
  
# 141
 
# 151

 
# 162

 
# 167

 bool ItemPointerEquals(ItemPointer pointer1, ItemPointer pointer2);

# 1 "../../include/storage/shmem.h"
 
# 16

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 1 "../../include/storage/spin.h"
 
# 16

# 1 "../../include/storage/ipc.h"
 
# 18 "../../include/storage/spin.h"

 
# 28

typedef int SPINLOCK;
# 33

 void CreateSpinlocks(IPCKey key);
 void InitSpinLocks(void);
 void SpinAcquire(SPINLOCK lockid);
 void SpinRelease(SPINLOCK lockid);
# 41

# 1 "../../include/utils/hsearch.h"
 
# 20 "../../include/storage/shmem.h"


 
# 26
typedef unsigned long SHMEM_OFFSET;

# 30

 
# 34
extern SHMEM_OFFSET ShmemBase;


 
# 40

 
# 44

# 47

 
# 51


extern SPINLOCK ShmemLock;
extern SPINLOCK ShmemIndexLock;

 
typedef struct SHM_QUEUE
{
	SHMEM_OFFSET        prev;
	SHMEM_OFFSET        next;
        pthread_mutex_t*    lock;   
} SHM_QUEUE;

 
 void ShmemIndexReset(void);
 void ShmemCreate(unsigned int key, unsigned int size);
 int	InitShmem(unsigned int key, unsigned int size, int maxBackends);
 void *ShmemAlloc(Size size,void* cxt);
 int	ShmemIsValid(unsigned long addr);
 HTAB *ShmemInitHash(char *name, long init_size, long max_size,
			  HASHCTL *infoP, int hash_flags);
 bool ShmemPIDLookup(int pid, SHMEM_OFFSET *locationPtr);
 SHMEM_OFFSET ShmemPIDDestroy(int pid);
 long *ShmemInitStruct(char *name, unsigned long size,
				bool *foundPtr);


typedef int TableID;

 
  
# 83
  
# 86
  
# 88

 
typedef struct
{
	char		key[ ( 50 )];		 
	unsigned long location;		 
	unsigned long size;			 
} ShmemIndexEnt;

 
# 100
 void SHMQueueInit(SHM_QUEUE *queue, pthread_mutex_t* mutex);
 void SHMQueueElemInit(SHM_QUEUE *queue);
 void SHMQueueDelete(SHM_QUEUE *queue);
 void SHMQueueInsertTL(SHM_QUEUE *queue, SHM_QUEUE *elem);
 void SHMQueueFirst(SHM_QUEUE *queue, Pointer *nextPtrPtr,
			  SHM_QUEUE *nextQueue);
 bool SHMQueueEmpty(SHM_QUEUE *queue);
 int SHMQueueLock(SHM_QUEUE  *queue);
 int SHMQueueRelease(SHM_QUEUE  *queue);

# 23 "../../include/storage/lock.h"


 
typedef struct THREAD_QUEUE
{
	SHM_QUEUE	links;
	int			size;
} THREAD_QUEUE;

typedef struct threadid {
    pid_t 	proc;
    pthread_t	thread;
} ThreadId;

typedef enum ThreadType {
        NORMAL_THREAD,
        POOLSWEEP_THREAD,
        DBWRITER_THREAD,
        DAEMON_THREAD,
        DOL_THREAD
} ThreadType;


# 53


 
# 67

typedef int LOCKMASK;

typedef int LOCKMODE;
typedef int LOCKMETHOD;

 
# 75

 
# 82

# 84

# 90

# 92

 
# 113
typedef struct LOCKMETHODCTL
{
	LOCKMETHOD              lockmethod;
	int			numLockModes;
	int			conflictTab[ 10 ];
	int			prio[ 10 ];
	pthread_mutex_t         lock_guard;
	pthread_mutex_t         holder_guard;
} LOCKMETHODCTL;

 
# 130
typedef struct LOCKMETHODTABLE
{
	HTAB	   *    lockHash;
	HTAB	   *    holderHash;
	LOCKMETHODCTL * ctl;
} LOCKMETHODTABLE;


 
# 142
typedef struct LOCKTAG
{
	Oid			relId;
	Oid			dbId;
	union
	{
		BlockNumber blkno;
		TransactionId xid;
	}			objId;

	 
# 157
	OffsetNumber offnum;

	uint16		lockmethod;		 
} LOCKTAG;


 
# 174
typedef struct LOCK
{
	 
	LOCKTAG		tag;

	 
	int			mask;
	int			waitMask;
	THREAD_QUEUE		waitThreads;
	int			holders[ 10 ];
	int			nHolding;
	int			activeHolders[ 10 ];
	int			nActive;
        int                     refs;
        int                     removing;
        pthread_mutex_t         protection;
} LOCK;

# 195

# 197


 
# 215
typedef struct HOLDERTAG
{
	SHMEM_OFFSET 			lock;			 
	ThreadId			pid;			 
	TransactionId 			xid;			 
} HOLDERTAG;

typedef struct HOLDER
{
	 
	HOLDERTAG	tag;

	 
	int			holders[ 10 ];
	int			nHolding;

	SHM_QUEUE	queue;
} HOLDER;

# 237

# 240


typedef struct th
{
	SHM_QUEUE		links;			 		

	pthread_mutex_t			gate;
	pthread_cond_t			sem;			 

	int			locked;			 
	int			errType;		 

	int			isSoft;		 
# 255

	int			prio;			 

	volatile TransactionId 		xid;			 
# 260

	volatile TransactionId 		xmin;			 
# 264
	volatile int					state;
	SHMEM_OFFSET	   	waitLock;		 
	SHMEM_OFFSET	   	waitHolder;		 
	LOCKMODE		waitLockMode;	 
	int			token;			 
	int			holdLock;		 
	ThreadId		tid;			 
        ThreadType		ttype;
	Oid			databaseId;		 
	short			sLocks[ FIRSTFREELOCKID ];	 
	SHM_QUEUE		lockQueue;		
} THREAD;

# 280
 
# 283
 void InitLocks(void);
 void LockDisable(bool status);
 bool LockingDisabled(void);
 LOCKMETHOD LockMethodTableInit(char *tabName, LOCKMASK *conflictsP,
					int *prioP, int numModes, int maxBackends);
 LOCKMETHOD LockMethodTableRename(LOCKMETHOD lockmethod);
 bool LockAcquire(LOCKMETHOD lockmethod, LOCKTAG *locktag,
						TransactionId xid, LOCKMODE lockmode,bool failfast);
 bool LockRelease(LOCKMETHOD lockmethod, LOCKTAG *locktag,
						TransactionId xid, LOCKMODE lockmode);
 bool LockReleaseAll(LOCKMETHOD lockmethod, THREAD *proc,
						   bool allxids, TransactionId xid);
 int LockResolveConflicts(LOCKMETHOD lockmethod, LOCKMODE lockmode,
								LOCK *lock, HOLDER *holder, THREAD *proc,
								int *myHolders);
 void GrantLock(LOCK *lock, HOLDER *holder, LOCKMODE lockmode);
 int	LockShmemSize(int maxBackends);
 bool DeadLockCheck(THREAD *thisProc, LOCK *findlock);
# 305

# 309

# 1 "../../include/utils/rel.h"
 
# 16

# 1 "../../include/access/strat.h"
 
# 17

# 1 "../../include/access/skey.h"
 
# 19

# 1 "../../include/access/attnum.h"
 
# 16

# 1 "../../include/c.h"
 
# 15
 
# 18 "../../include/access/attnum.h"

 
# 22

typedef int16 AttrNumber;

# 26

 
# 31
 
# 37

 
# 44

 
# 57

 
# 64

# 1 "../../include/fmgr.h"
 
# 23

typedef struct {
    char *data[ 16 ];
} FmgrValues;

typedef struct {
    func_ptr	fn_addr;
    func_ptr	fn_plhandler;
    Oid		fn_oid;
	char	fn_javaname[128];
    char	fn_javasig[128];
    Oid  	fn_javarettype;
    int		fn_nargs;
} FmgrInfo;

 
# 44

extern char *fmgr_c(FmgrInfo *finfo, FmgrValues *values, bool *isNull);
extern void fmgr_info(Oid procedureId, FmgrInfo *finfo);
extern char *fmgr(Oid procedureId,... );
extern char *fmgr_ptr(FmgrInfo *finfo, ... );
extern char *fmgr_array_args(Oid procedureId, int nargs, 
			     char *args[], bool *isNull);

# 55

 
# 59
 
# 64
 
# 71

 
 
# 76

# 81

# 87

 
# 93

 
# 1040

# 22 "../../include/access/skey.h"


typedef struct ScanKeyData
{
	bits16		sk_flags;		 
	AttrNumber	sk_attno;		 
	RegProcedure sk_procedure;	 
	FmgrInfo	sk_func;
	int32		sk_nargs;
	Datum		sk_argument;	 
} ScanKeyData;

typedef ScanKeyData *ScanKey;


# 41

# 45


 
# 50
  void ScanKeyEntrySetIllegal ( ScanKey entry ) ;
  void ScanKeyEntryInitialize ( ScanKey entry , bits16 flags ,
	 AttrNumber attributeNumber, RegProcedure procedure, Datum argument);

# 19 "../../include/access/strat.h"

typedef uint16 StrategyNumber;

# 23

typedef struct StrategyTransformMapData
{
	StrategyNumber strategy[1];  
} StrategyTransformMapData;		 
# 41

typedef StrategyTransformMapData *StrategyTransformMap;

typedef struct StrategyOperatorData
{
	StrategyNumber strategy;
	bits16		flags;			 
} StrategyOperatorData;

typedef StrategyOperatorData *StrategyOperator;

typedef struct StrategyTermData
{								 
	uint16		degree;
	StrategyOperatorData operatorData[1];		 
} StrategyTermData;				 

typedef StrategyTermData *StrategyTerm;

typedef struct StrategyExpressionData
{								 
	StrategyTerm term[1];		 
} StrategyExpressionData;		 

typedef StrategyExpressionData *StrategyExpression;

typedef struct StrategyEvaluationData
{
	StrategyNumber maxStrategy;
	StrategyTransformMap negateTransform;
	StrategyTransformMap commuteTransform;
	StrategyTransformMap negateCommuteTransform;
	StrategyExpression* expression;	 
} StrategyEvaluationData;		 

typedef StrategyEvaluationData *StrategyEvaluation;

 
# 83


# 86

typedef struct StrategyMapData
{
	ScanKeyData entry[1];		 
} StrategyMapData;				 

typedef StrategyMapData *StrategyMap;

typedef struct IndexStrategyData
{
	StrategyMapData strategyMapData[1];  
} IndexStrategyData;			 

typedef IndexStrategyData *IndexStrategy;

# 1 "../../include/access/tupdesc.h"
 
# 16

# 1 "../../include/access/attnum.h"
 
# 1 "../../include/catalog/pg_attribute.h"
 
# 1 "../../include/nodes/pg_list.h"
 
# 16

# 1 "../../include/nodes/nodes.h"
 
# 16

 
# 24
typedef enum NodeTag
{
	T_Invalid = 0,

	 
# 32
	T_Plan = 10,
	T_Result,
	T_Append,
	T_Scan,
	T_SeqScan,
        T_DelegatedSeqScan,
	T_IndexScan,
        T_DelegatedIndexScan,
	T_Join,
	T_NestLoop,
	T_MergeJoin,
	T_HashJoin,
	T_Noname,
	T_Material,
	T_Sort,
	T_Agg,
	T_Unique,
	T_Hash,
	T_Choose,
	T_Group,
	T_SubPlan,
	T_TidScan,

	 
# 59
	T_Resdom = 100,
	T_Fjoin,
	T_Expr,
	T_Var,
	T_Oper,
	T_Const,
	T_Param,
	T_Aggref,
	T_SubLink,
	T_Func,
	T_Array,
	T_ArrayRef,
	T_Iter,
	T_RelabelType,
	T_Java,

	 
# 79
	T_RelOptInfo = 200,
	T_Path,
	T_IndexPath,
	T_NestPath,
	T_MergePath,
	T_HashPath,
	T_PathKeyItem,
	T_RestrictInfo,
	T_JoinInfo,
	T_Stream,
	T_TidPath,
	T_IndexOptInfo,

	 
# 96
	T_IndexInfo = 300,
	T_RelationInfo,
	T_TupleCount,
	T_TupleTableSlot,
	T_ExprContext,
	T_ProjectionInfo,
	T_JunkFilter,
	T_EState,
	T_BaseNode,
	T_CommonState,
	T_ResultState,
	T_AppendState,
	T_CommonScanState,
	T_ScanState,
	T_IndexScanState,
	T_JoinState,
	T_NestLoopState,
	T_MergeJoinState,
	T_HashJoinState,
	T_MaterialState,
	T_AggState,
	T_GroupState,
	T_SortState,
	T_UniqueState,
	T_HashState,
	T_TidScanState,

	 
# 127
	T_MemoryContext = 400,
	T_AllocSetContext,
	T_SubSetContext,
        T_UmemSetContext,

	 
# 136
	T_Value = 500,
	T_List,
	T_Integer,
	T_Float,
	T_String,
	T_Null,

	 
# 147
	T_Query = 600,
	T_InsertStmt,
	T_DeleteStmt,
	T_UpdateStmt,
	T_SelectStmt,
	T_AlterTableStmt,
	T_AggregateStmt,
	T_ChangeACLStmt,
	T_ClosePortalStmt,
	T_ClusterStmt,
	T_CopyStmt,
	T_CreateStmt,
	T_VersionStmt,
	T_DefineStmt,
	T_DropStmt,
	T_TruncateStmt,
	T_CommentStmt,
	T_ExtendStmt,
	T_FetchStmt,
	T_IndexStmt,
	T_ProcedureStmt,
	T_RemoveAggrStmt,
	T_RemoveFuncStmt,
	T_RemoveOperStmt,
	T_RemoveStmt,
	T_RenameStmt,
	T_RuleStmt,
	T_NotifyStmt,
	T_ListenStmt,
	T_UnlistenStmt,
	T_TransactionStmt,
	T_ViewStmt,
	T_LoadStmt,
	T_CreatedbStmt,
	T_CreateSchemaStmt,
	T_DropdbStmt,
	T_VacuumStmt,
	T_ExplainStmt,
	T_CreateSeqStmt,
	T_VariableSetStmt,
	T_VariableShowStmt,
	T_VariableResetStmt,
	T_CreateTrigStmt,
	T_DropTrigStmt,
	T_CreatePLangStmt,
	T_DropPLangStmt,
	T_CreateUserStmt,
	T_AlterUserStmt,
	T_DropUserStmt,
	T_LockStmt,
	T_ConstraintsSetStmt,
	T_CreateGroupStmt,
	T_AlterGroupStmt,
	T_DropGroupStmt,
	T_ReindexStmt,

	T_A_Expr = 700,
	T_Attr,
	T_A_Const,
	T_ParamName,
	T_ParamNo,
	T_Ident,
	T_FuncCall,
	T_A_Indices,
	T_ResTarget,
	T_TypeCast,
	T_RelExpr,
	T_SortGroupBy,
	T_RangeVar,
	T_TypeName,
	T_IndexElem,
	T_ColumnDef,
	T_Constraint,
	T_DefElem,
	T_TargetEntry,
	T_RangeTblEntry,
	T_SortClause,
	T_GroupClause,
	T_SubSelect,
	T_JoinExpr,
	T_CaseExpr,
	T_CaseWhen,
	T_RowMark,
	T_FkConstraint
} NodeTag;

 
# 239
typedef struct Node
{
	NodeTag		type;
} Node;

# 245

# 248

# 250

 
# 257

# 261

# 265

# 268

 
# 273

 
# 277
 Node *newNode(Size size, NodeTag tag);

 
# 282
 char *nodeToString(void *obj);

 
# 287
 void *stringToNode(char *str);

 
# 292
 void *copyObject(void *obj);

 
# 297
 bool equal(void *a, void *b);


 
# 308
typedef double Selectivity;		 
# 310
typedef double Cost;			 


 
# 320
typedef enum CmdType
{
	CMD_UNKNOWN,
	CMD_SELECT,					 
	CMD_UPDATE,					 
	CMD_INSERT,					 
	CMD_DELETE,
	CMD_UTILITY,				 
# 329
	CMD_NOTHING					 
# 331
} CmdType;


# 18 "../../include/nodes/pg_list.h"

 
# 23

 
# 43
typedef struct Value
{
	NodeTag		type;			 
	union ValUnion
	{
		long		ival;		 
		char	   *str;		 
	}			val;
} Value;

# 56


 
# 62
typedef struct List
{
	NodeTag		type;
	union
	{
		void	   *ptr_value;
		long	    int_value;
	}			elem;
	struct List *next;
} List;

# 74

 
# 79

 
 
# 85

# 87

 
# 94


 
# 102
 
 long	length(List *list);
 List *nconc(List *list1, List *list2);
 List *lcons(void *datum, List *list);
 List *lconsi(long datum, List *list);
 bool member(void *datum, List *list);
 bool intMember(long datum, List *list);
 Value *makeInteger(long i);
 Value *makeFloat(char *numericStr);
 Value *makeString(char *str);
 List *makeList(void *elem,...);
 List *lappend(List *list, void *datum);
 List *lappendi(List *list, long datum);
 List *lremove(void *elem, List *list);
 List *LispRemove(void *elem, List *list);
 List *ltruncate(long n, List *list);

 void *nth(long n, List *l);
 long	nthi(long n, List *l);
 void set_nth(List *l, long n, void *elem);

 List *set_difference(List *list1, List *list2);
 List *set_differencei(List *list1, List *list2);
 List *LispUnion(List *list1, List *list2);
 List *LispUnioni(List *list1, List *list2);

 bool sameseti(List *list1, List *list2);
 bool nonoverlap_setsi(List *list1, List *list2);
 bool is_subseti(List *list1, List *list2);

 void freeList(List *list);

 

 
 List *listCopy(List *list);
# 141

# 20 "../../include/access/tupdesc.h"


typedef struct attrDefault
{
	AttrNumber	adnum;
	char	   *adbin;			 
} AttrDefault;

typedef struct constrCheck
{
	char	   *ccname;
	char	   *ccbin;			 
} ConstrCheck;


 
typedef struct tupleConstr
{
	AttrDefault *defval;		 
	ConstrCheck *check;			 
	uint16		num_defval;
	uint16		num_check;
	bool		has_not_null;
} TupleConstr;

 
# 49
typedef struct tupleDesc
{
	int			natts;			 
	int			blobatt;
	Form_pg_attribute *attrs;
	 
	TupleConstr *constr;
}		   *TupleDesc;

  TupleDesc CreateTemplateTupleDesc ( int natts ) ;

  TupleDesc CreateTupleDesc ( int natts , Form_pg_attribute * attrs ) ;

  TupleDesc CreateTupleDescCopy ( TupleDesc tupdesc ) ;

  TupleDesc CreateTupleDescCopyConstr ( TupleDesc tupdesc ) ;

  void FreeTupleDesc ( TupleDesc tupdesc ) ;

  bool equalTupleDescs ( TupleDesc tupdesc1 , TupleDesc tupdesc2 ) ;

  bool TupleDescInitEntry ( TupleDesc desc ,
				   AttrNumber attributeNumber,
				   char *attributeName,
				   Oid oidtypeid,
				   int32 typmod,
				   int attdim,
				   bool attisset);

  TupleDesc BuildDescForRelation ( List * schema , char * relname ) ;

# 1 "../../include/catalog/pg_am.h"
 
# 24

 
# 31

 
# 37
 typedef struct FormData_pg_am 
{
	NameData	amname;			 
	int4		amowner;		 
	int2		amstrategies;	 
# 43
	int2		amsupport;		 
# 45
	int2		amorderstrategy; 
# 48
	regproc		amgettuple;		 
	regproc		aminsert;		 
	regproc		amdelete;		 
	regproc		ambulkdelete;		
	regproc		amsetlock;		 
	regproc		amsettid;		 
	regproc		amfreetuple;	 
	regproc		ambeginscan;	 
	regproc		amrescan;		 
	regproc		amendscan;		 
	regproc		ammarkpos;		 
	regproc		amrestrpos;		 
	regproc		amopen;			 
	regproc		amclose;		 
	regproc		ambuild;		 
	regproc		amcreate;		 
	regproc		amdestroy;		 
	regproc		amcostestimate;  
} FormData_pg_am;

 
# 73
typedef FormData_pg_am *Form_pg_am;

 
# 103

 
# 108

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
# 114
 extern int errno ;
 extern int errno ;
# 117
 extern int errno ;
 extern int errno ;

# 1 "../../include/catalog/pg_class.h"
 
# 26

 
# 33

 
# 44

 
# 54
 typedef struct FormData_pg_class  
{
	NameData	relname;
	Oid			reltype;
	int4		relowner;
	Oid			relam;
	long		relpages;
	long		reltuples;
	Oid			rellongrelid;
	bool		relhasindex;
	bool		relisshared;
	char		relkind;
	int2		relnatts;

	 
# 73
	int2		relchecks;		 
# 75
	int2		reltriggers;	 
	int2		relukeys;		 
	int2		relfkeys;		 
	int2		relrefs;		 
	bool		relhaspkey;		 
	bool		relhasrules;
	text		relacl;		 
} FormData_pg_class;

# 86

 
# 92
typedef FormData_pg_class *Form_pg_class;

 
# 98

 
# 126

 
# 131

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;

# 175

 
# 178

# 187

# 1 "../../include/rewrite/prs2lock.h"
 
# 15


# 1 "../../include/access/attnum.h"
 
# 1 "../../include/nodes/pg_list.h"
 
# 1 "../../include/nodes/nodes.h"
 
# 20 "../../include/rewrite/prs2lock.h"

 
# 26
typedef struct RewriteRule
{
	Oid			ruleId;
	CmdType		event;
	AttrNumber	attrno;
	Node	   *qual;
	List	   *actions;
	bool		isInstead;
} RewriteRule;

 
# 42
typedef struct RuleLock
{
	int			numLocks;
	RewriteRule **rules;
} RuleLock;

# 1 "../../include/storage/fd.h"
 
# 14

# 1 "../../include/postgres.h"
 
# 14
 
# 16 "../../include/storage/fd.h"

 
# 1 "../../include/storage/block.h"
 
# 1 "../../include/storage/smgr.h"
 
# 16

# 1 "../../include/storage/block.h"
 
# 1 "../../include/storage/spin.h"
 
# 1 "../../include/nodes/pg_list.h"
 
# 20 "../../include/storage/smgr.h"

# 23

# 25

typedef struct recoveredpage {
    Oid          dbid;
    Oid          relid;
    BlockNumber  block;
    char         dbname[64];
} RecoveredPage;

typedef struct smgrdata* SmgrInfo;

 int	smgrinit(void);
 int	smgrshutdown(void);
 SmgrInfo  smgrcreate(int16 which, char *dbname, char *relname, 
			  Oid dbid, Oid relid);
 int	smgrunlink(SmgrInfo info);
 long	smgrextend(SmgrInfo info, char *buffer, long count);
 SmgrInfo  smgropen(int16 which, char *dbname, char *relname,
			  Oid dbid, Oid relid);
 int	smgrclose(SmgrInfo info);
 int smgrread(SmgrInfo info, BlockNumber blocknum,
		 char *buffer);
 int smgrwrite(SmgrInfo info, BlockNumber blocknum,
		  char *buffer);
 int smgrflush(SmgrInfo info, BlockNumber blocknum,
		  char *buffer);
 int	smgrmarkdirty(SmgrInfo info, BlockNumber blkno);
 long	smgrnblocks(SmgrInfo info);
 long	smgrtruncate(SmgrInfo info, long nblocks);
 int	smgrsync(SmgrInfo info);
 int	smgrcommit(void);
 int	smgrabort(void);

 int   smgrbeginlog();
 int   smgrlog(int which, char *dbname, char *relname,
	Oid dbid, Oid relid, BlockNumber blocknum, char relkind, char* buffer);
 int   smgrcommitlog();

 int   smgrexpirelogs();
 int   smgrreplaylogs();

 void smgrcompleterecovery();
 List* smgrgetrecoveredlist(Oid dbid);
 List* smgrdbrecoverylist(void);
 char* smgrdbrecoveryname(Oid dbid);
 
# 89

 
 int	vfdinit(void);
 int	vfdshutdown(void);
 int	vfdcreate(SmgrInfo info);
 int	vfdunlink(SmgrInfo info);
 int	vfdextend(SmgrInfo info, char *buffer, long count);
 int	vfdopen(SmgrInfo info);
 int	vfdclose(SmgrInfo info);
 int	vfdread(SmgrInfo info, BlockNumber blocknum, char *buffer);
 int	vfdwrite(SmgrInfo info, BlockNumber blocknum, char *buffer);
 int	vfdflush(SmgrInfo info, BlockNumber blocknum, char *buffer);
 int	vfdmarkdirty(SmgrInfo info, BlockNumber blkno);
 int	vfdnblocks(SmgrInfo info);
 int	vfdtruncate(SmgrInfo info, long nblocks);
 int	vfdsync(SmgrInfo info);
 int	vfdcommit(void);
 int	vfdabort(void);
 int	vfdbeginlog(void);
 int	vfdlog(SmgrInfo info, BlockNumber, char* buffer);
 int	vfdcommitlog(void);
 int	vfdexpirelogs(void);
 int	vfdreplaylogs(void);

# 156

 
 char *smgrout(int2 i);
 int2 smgrin(char *s);
 bool smgreq(int2 a, int2 b);
 bool smgrne(int2 a, int2 b);


# 25 "../../include/utils/rel.h"


 
 char *get_temp_rel_by_physicalname(const char *relname);

 
# 34
typedef int (*trigger_func)(void*);

typedef struct BufferTrigger {
    trigger_func        call;
    void*               args;
} BufferTrigger;

typedef struct bufenv   *BufferCxt;
typedef struct SnapshotHolder   *SnapshotCxt;

typedef struct LockRelId
{
	Oid			relId;			 
	Oid			dbId;			 
} LockRelId;

typedef struct LockInfoData
{
	LockRelId	lockRelId;
} LockInfoData;

typedef LockInfoData *LockInfo;

 
# 61

typedef struct Trigger
{
	Oid			tgoid;
	char	   *tgname;
	Oid			tgfoid;
	FmgrInfo	tgfunc;
	int16		tgtype;
	bool		tgenabled;
	bool		tgisconstraint;
	bool		tgdeferrable;
	bool		tginitdeferred;
	int16		tgnargs;
	int16		tgattr[ 16 ];
	char	  **tgargs;
} Trigger;

typedef struct TriggerDesc
{
	 
	uint16		n_before_statement[4];
	uint16		n_before_row[4];
	uint16		n_after_row[4];
	uint16		n_after_statement[4];
	Trigger   **tg_before_statement[4];
	Trigger   **tg_before_row[4];
	Trigger   **tg_after_row[4];
	Trigger   **tg_after_statement[4];
	 
	Trigger    *triggers;
	int			numtriggers;
} TriggerDesc;

 
# 97

typedef struct RelationData
{
	SmgrInfo        rd_smgr;		 
        long            rd_nblocks;
	uint16		rd_refcnt;		 
	bool		rd_myxactonly;	 
	bool		rd_isnailed;	 
	bool		rd_isnoname;	 
	bool		rd_unlinked;	 
	bool		rd_indexfound;	 
	Form_pg_am	rd_am;			 
	Form_pg_class   rd_rel;		 
	Oid		rd_id;			 
	LockInfoData    rd_lockInfo;	 
# 113
	TupleDesc	rd_att;			 
        BufferCxt       buffer_cxt;              
        SnapshotCxt     snapshot_cxt;              
	RuleLock   *    rd_rules;		 
	List*		rd_indexlist;
	IndexStrategy   rd_istrat;
	RegProcedure *  rd_support;
	TriggerDesc *   trigdesc;		 
        BufferTrigger * readtrigger;
} RelationData;

typedef RelationData *Relation;


 
# 133
typedef Relation *RelationPtr;


 
# 141

# 143

 
# 153

 
# 159

 
# 165

 
# 173

 
# 182

 
# 189

 
# 205

 
# 212

 
# 219

 
# 225

 
# 235

# 238


 void RelationSetIndexSupport(Relation relation,
						IndexStrategy strategy,
						RegProcedure *support);

# 19 "../../include/storage/lmgr.h"

 

 
# 33


 LOCKMETHOD LockTableId;


 LOCKMETHOD InitLockTable(int partitions, int maxBackends);
 void RelationInitLockInfo(Relation relation);

 
 void LockRelation(Relation relation, LOCKMODE lockmode);
 void UnlockRelation(Relation relation, LOCKMODE lockmode);
 bool NoWaitLockRelation(Relation relation, LOCKMODE lockmode);

 void LockRelationForSession(LockRelId *relid, LOCKMODE lockmode);
 void UnlockRelationForSession(LockRelId *relid, LOCKMODE lockmode);

 
 void LockPage(Relation relation, BlockNumber blkno, LOCKMODE lockmode);
 void UnlockPage(Relation relation, BlockNumber blkno, LOCKMODE lockmode);

 
 void XactLockTableInsert(TransactionId xid);
 void XactLockTableWait(TransactionId xid);

# 19 "../../include/storage/buf_internals.h"

 
 
extern int	NBuffers;
extern int	Data_Descriptors;
extern int	Free_List_Descriptor;
extern int	Lookup_List_Descriptor;
extern int	Num_Descriptors;

 
# 39

# 44

# 46

typedef bits16 BufFlags;

 
typedef long **BufferBlock;

typedef struct BufferTable {
        pthread_mutex_t     lock;
        HTAB*               table;
} BufferTable;

typedef struct buftag
{
	LockRelId	relId;
	BlockNumber blockNum;		 
} BufferTag;

typedef struct lookup
{
	BufferTag	key;
	Buffer		id;
} BufferLookupEnt;

# 75

# 82

 
# 87
typedef struct bufblindid
{
	char		dbname[ 64 ];	 
	char		relname[ 64 ];	 
}			BufferBlindId;

# 96

typedef struct iogate {
	pthread_mutex_t		guard;
	pthread_cond_t		gate;
} IOGate;


 
# 115
typedef struct sbufdesc
{
	Buffer		freeNext;		 
	SHMEM_OFFSET 	data;			 
	SHMEM_OFFSET 	shadow;			 

	 
	BufferTag	tag;			 
        char            kind;
	int		buf_id;			 

	BufFlags	locflags;			 
	unsigned	refCount;		 
	unsigned	pageaccess;		 
        
	BufFlags	ioflags;			 
	IOGate		io_in_progress_lock;
	IOGate		cntx_lock;		 

	bool            used;
        bool		w_lock;			 
        bool		e_lock;
        unsigned        w_owner;
	unsigned	r_locks;		 
        unsigned	e_waiting;
        unsigned	w_waiting;
        unsigned	r_waiting;
        unsigned	p_waiting;        

        unsigned        bias;

	BufferBlindId blind;		 
} BufferDesc;

 
# 160
 
# 163

 
# 184


 
# 189

 

 


 int ManualPin(BufferDesc* buf, bool pageaccess);
 int ManualUnpin(BufferDesc* buf, bool pageaccess);

 int BiasPinned(BufferDesc* buf);

 bool IsWaitingForFlush(unsigned owner);
 BufferDesc *GetFreeBuffer(Relation rel);
 void PutFreeBuffer(BufferDesc* bufHdr);
 void InitFreeList(bool init);

 

 void InitBufTable(int tables);
 BufferDesc *BufTableLookup(char kind, BufferTag *tagPtr);
 bool BufTableDelete(BufferDesc *buf);
 bool BufTableInsert(BufferDesc *buf);
 bool  BufTableReplace(BufferDesc *buf, Relation rel, BlockNumber block);
 
 BufferDesc *BufferDescriptors;
 BufferBlock BufferBlocks;

 SPINLOCK HeapBufLock;
 SPINLOCK IndexBufLock;
 SPINLOCK FreeBufMgrLock;

 
 
# 225
 const int	NLocBuffer;

 BufferDesc *LocalBufferAlloc(Relation reln, BlockNumber blockNum,bool *foundPtr);
 int	WriteLocalBuffer(Buffer buffer, bool release);
 int	FlushLocalBuffer(Buffer buffer, bool release);

 void LocalBufferSync(void);
 void ResetLocalBufferPool(void);

# 1 "../../include/utils/rel.h"
 
# 22 "../../include/storage/bufmgr.h"

 
# 34

# 36

typedef void* Block;

 
# 41

typedef bits16 BufferLock;


 
# 50

 
# 56

 int	ShowPinTrace;

 
# 66

 
# 70


 
# 94

 
# 114


 
# 119
 
# 123

 Buffer ReadBuffer(Relation reln, BlockNumber blockNum);
 int	WriteBuffer(Relation reln, Buffer buffer);
 int	WriteNoReleaseBuffer(Relation reln, Buffer buffer);     
 Buffer ReleaseAndReadBuffer(Buffer buffer, Relation relation,
					 BlockNumber blockNum);
 int	ReleaseBuffer(Relation reln, Buffer buffer);

 int	FlushBuffer(Relation reln,Buffer buffer, bool release);
 int	PrivateWriteBuffer(Relation rel, Buffer buffer, bool release);
 int	SyncRelation(Relation rel);

 void InitBufferPool(IPCKey key);
 void InitThreadBuffer(void);

 void ResetBufferUsage(void);
 void ResetBufferPool(bool isCommit);
 int	BufferPoolCheckLeak(void);
 int BufferPoolCountHolds();

 BlockNumber BufferGetBlockNumber(Buffer buffer);
 
# 147
 void InvalidateRelationBuffers(Relation rel);

 void DropBuffers(Oid dbid);
 void PrintPinnedBufs(void);
 int	BufferShmemSize(void);

 int BiasBuffer(Relation rel, Buffer buffer);

 void SetBufferCommitInfoNeedsSave(Buffer buffer);

 void UnlockBuffers(void);
 int LockBuffer(Relation rel, Buffer buffer, int mode);

 bool BufferHasError(Buffer buf);

 void AbortBufferIO(void);
 bool ErrorBufferIO(BufferDesc* buf);
 bool IsDirtyBufferIO(BufferDesc* buf);
        
 bool ReadBufferIO(BufferDesc *buf);
 bool WriteBufferIO(BufferDesc *buf, bool flush);
 bool LogBufferIO(BufferDesc *buf);
 void TerminateBufferIO(BufferDesc *buf);

 Block BufferGetBlock(Buffer buffer);

 void IncrBufferRefCount(Relation rel, Buffer buffer);
 bool CheckBufferId(BufferDesc* buf, BlockNumber block, int relid, int dbid);
 BufferCxt GetBufferCxt();


# 181


# 1 "../../include/env/pg_crc.h"
 
# 24

# 1 "../../include/config.h"
 
 
# 14

# 26 "../../include/env/pg_crc.h"


# 30


typedef uint32 pg_crc32;

 
# 36

 
# 39

 
# 52

 
# 55

 
extern const uint32 pg_crc32_table[];


# 61

 
# 70

# 118

typedef struct pg_crc64
{
	uint64		crc0;
}	pg_crc64;


# 126

typedef uint64 crc64;

 
# 131

 
# 134

 
# 149

 
# 152

 
extern const uint64 pg_crc64_table[];
# 157

 bool eq_crc64(crc64 c1,crc64 c2);
 crc64 checksum_block(unsigned char* block,int len);

# 25 "../../include/storage/bufpage.h"
 
# 81

 
# 87


 
# 95
typedef uint32 LocationIndex;


 
# 108
typedef struct OpaqueData
{
	uint32		od_pagesize;
 
} OpaqueData;

typedef OpaqueData *Opaque;


 
# 120
typedef struct PageHeaderData
{
    	uint64			checksum;
	LocationIndex pd_lower;		 
	LocationIndex pd_upper;		 
	LocationIndex pd_special;	 
	OpaqueData	pd_opaque;	 
	ItemIdData	pd_linp[1];		 
} PageHeaderData;

typedef PageHeaderData *PageHeader;

typedef enum
{
	ShufflePageManagerMode,
	OverwritePageManagerMode
} PageManagerMode;

 
# 142
 
# 145

 
# 158

 
# 163
  
# 168
 
# 172

# 174

 
# 179

# 182


 
# 188

 
# 200

 
# 211

 
# 218

 
# 223
 
# 232

 
# 245

 
# 261

 
# 272
 
# 278

 
# 284

# 287
        
 
# 298
 
# 304

 
# 309
 OffsetNumber PageGetMaxOffsetNumber(Page page);
 bool PageIsEmpty(Page page);

 void PageInit(Page page, Size pageSize, Size specialSize);
 OffsetNumber PageAddItem(Page page, Item item, Size size,
			OffsetNumber offsetNumber, ItemIdFlags flags);
 Page PageGetTempPage(Page page, Size specialSize);
 void PageRestoreTempPage(Page tempPage, Page oldPage);
 int PageRepairFragmentation(Page page);
 int PageCompactPage(Page page);
 Size PageGetFreeSpace(Page page);
 void PageManagerModeSet(PageManagerMode mode);
 void PageIndexTupleDelete(Page page, OffsetNumber offset);
 crc64 PageInsertChecksum(Page page);
 crc64 PageInsertInvalidChecksum(Page page);
 bool PageConfirmChecksum(Page page);

# 18 "../../include/access/htup.h"


# 21

 

# 25

 
# 30
typedef struct HeapTupleHeaderData
{
	Oid             t_oid;			 
        union {
           TransactionId   t_vtran;
			struct {
            CommandId	t_cmin;			 
            CommandId	t_cmax;			 
			} cmd;
        } progress;
        
	TransactionId t_xmin;		 
	TransactionId t_xmax;		 

	ItemPointerData t_ctid;		 

	int16		t_natts;		 

	uint16		t_infomask;		 

	uint8		t_hoff;			 

        bits8		t_bits[ 32 / 8];
	 

	 
} HeapTupleHeaderData;

typedef HeapTupleHeaderData *HeapTupleHeader;

# 63

# 65

# 67

# 76


 
 extern  long heap_sysoffset[];

 
# 95
typedef struct HeapTupleData
{
	uint32              t_len;			 
	ItemPointerData     t_self;		 
	MemoryContext       t_datamcxt;	 
	void*               t_datasrc;		 
        int                 t_info;              
	HeapTupleHeader     t_data;		 
} HeapTupleData;

typedef HeapTupleData *HeapTuple;

# 108


 
# 116


 
# 125

 
# 131

 
# 137
                  
 
# 146
  
# 149
  
# 151

# 156

# 163


# 166

# 169

# 172

# 175

# 178

# 1 "../../include/access/xact.h"
 
# 16

# 1 "../../include/access/transam.h"
 
# 20


# 1 "../../include/storage/bufmgr.h"
 
# 1 "../../include/storage/block.h"
 
# 1 "../../include/storage/buf_internals.h"
 
# 1 "../../include/access/xact.h"
 
# 26 "../../include/access/transam.h"

 
# 41

 
# 53

# 59




 
# 66

typedef unsigned char XidStatus; 

 
# 76

 
# 82

 
# 89

 
# 102
typedef struct LogRelationContentsData
{
	double			TransSystemVersion;
} LogRelationContentsData;

typedef LogRelationContentsData *LogRelationContents;

 
# 125
typedef struct VariableRelationContentsData
{
	double			TransSystemVersion;
	TransactionId 		nextXidData;
	TransactionId 		lastXidData;	 
	Oid			nextOid;
} VariableRelationContentsData;

typedef VariableRelationContentsData *VariableRelationContents;

 
# 143
typedef struct VariableCacheData
{
	int32		xid_count;
	TransactionId 	nextXid;
	int32		oid_count;		 
	Oid		nextOid;
	int 		buffers;
	int 		maxbackends;
        int             numberOfLockTables;
        TransactionId   xid_low_water_mark;
	TransactionId   xid_checkpoint;
} VariableCacheData;

typedef VariableCacheData *VariableCache;



 
# 164

 
# 171

 bool InitializeTransactionLog(void);
 bool TransactionIdDidCommit(TransactionId transactionId);
 bool TransactionIdDidSoftCommit(TransactionId transactionId);
 bool TransactionIdDidHardCommit(TransactionId transactionId);
 bool TransactionIdDidAbort(TransactionId transactionId);
 bool TransactionIdDidCrash(TransactionId transactionId);

 void SetRecoveryCheckingEnabled(bool state);

 
 void AmiTransactionOverride(bool flag);
 BlockNumber TransComputeBlockNumber(Relation relation,
			  TransactionId transactionId);
 XidStatus TransBlockNumberGetXidStatus(Relation relation,TransactionId xid, bool *failP);
 void TransBlockNumberSetXidStatus(Relation relation, TransactionId xid, XidStatus xstatus);
 void TransBlockSetXidStatus(Block tb,TransactionId transactionId, XidStatus xstatus);
 
 void VariableRelationPutNextXid(TransactionId xid);
 TransactionId GetNewTransactionId(void);
 TransactionId ReadNewTransactionId(void);
 Oid GetNewObjectId(void);

 Oid GetGenId(void);

 bool TransactionIdBeforeCheckpoint(TransactionId xid);
 void  SetCheckpointId(TransactionId xid);
 TransactionId GetCheckpointId(void);
 void InitTransactionLowWaterMark(void);
 void SetTransactionLowWaterMark(TransactionId lowwater);
 TransactionId GetTransactionLowWaterMark(void);
 TransactionId GetTransactionRecoveryCheckpoint();
 void SetTransactionRecoveryCheckpoint(TransactionId recover);
 void VacuumTransactionLog(void);

# 209
 
# 213

 

extern TransactionId NullTransactionId;
extern TransactionId AmiTransactionId;
extern TransactionId FirstTransactionId;

 

extern bool AMI_OVERRIDE;

 

extern int	OidGenLockId;

# 1 "../../include/utils/nabstime.h"
 
# 16

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 1 "../../include/utils/timestamp.h"
 
# 15

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/math.h"
 
# 21
 
# 25

# 28

#ident	"@(#)math.h	2.25	05/10/06 SMI"

# 1 "/usr/include/iso/math_iso.h"
 
# 21
 
# 25

# 28

#ident	"@(#)math_iso.h	1.10	05/10/06 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 32 "/usr/include/iso/math_iso.h"

# 36

# 44

# 59

# 63

extern double acos  ( double );
extern double asin  ( double );
extern double atan  ( double );
extern double atan2  ( double , double );
extern double cos  ( double );
extern double sin  ( double );
extern double tan  ( double );

extern double cosh  ( double );
extern double sinh  ( double );
extern double tanh  ( double );

extern double exp  ( double );
extern double frexp  ( double , int * );
extern double ldexp  ( double , int );
extern double log  ( double );
extern double log10  ( double );
extern double modf  ( double , double * );

extern double pow  ( double , double );
extern double sqrt  ( double );

extern double ceil  ( double );
extern double fabs  ( double );
extern double floor  ( double );
extern double fmod  ( double , double );

# 108

# 222

# 226

# 230

# 1 "/usr/include/iso/math_c99.h"
 
# 21
 
# 25

# 28

#ident	"@(#)math_c99.h	1.12	07/01/21 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 32 "/usr/include/iso/math_c99.h"

# 36

# 44

# 135

 
# 151

 
# 169

# 174
typedef float float_t;
typedef double double_t;
# 189

# 200

# 213

# 218

# 225

extern double acosh  ( double );
extern double asinh  ( double );
extern double atanh  ( double );

extern double exp2  ( double );
extern double expm1  ( double );
extern int ilogb  ( double );
extern double log1p  ( double );
extern double log2  ( double );
extern double logb  ( double );
extern double scalbn  ( double , int );
extern double scalbln  ( double , long int );

extern double cbrt  ( double );
extern double hypot  ( double , double );

extern double erf  ( double );
extern double erfc  ( double );
extern double lgamma  ( double );
extern double tgamma  ( double );

extern double nearbyint  ( double );
extern double rint  ( double );
extern long int lrint  ( double );
extern double round  ( double );
extern long int lround  ( double );
extern double trunc  ( double );

extern double remainder  ( double , double );
extern double remquo  ( double , double , int * );

extern double copysign  ( double , double );
extern double nan  ( const char * );
extern double nextafter  ( double , double );
extern double nexttoward  ( double , long double );

extern double fdim  ( double , double );
extern double fmax  ( double , double );
extern double fmin  ( double , double );

extern double fma  ( double , double , double );

extern float acosf  ( float );
extern float asinf  ( float );
extern float atanf  ( float );
extern float atan2f  ( float , float );
extern float cosf  ( float );
extern float sinf  ( float );
extern float tanf  ( float );

extern float acoshf  ( float );
extern float asinhf  ( float );
extern float atanhf  ( float );
extern float coshf  ( float );
extern float sinhf  ( float );
extern float tanhf  ( float );

extern float expf  ( float );
extern float exp2f  ( float );
extern float expm1f  ( float );
extern float frexpf  ( float , int * );
extern int ilogbf  ( float );
extern float ldexpf  ( float , int );
extern float logf  ( float );
extern float log10f  ( float );
extern float log1pf  ( float );
extern float log2f  ( float );
extern float logbf  ( float );
extern float modff  ( float , float * );
extern float scalbnf  ( float , int );
extern float scalblnf  ( float , long int );

extern float cbrtf  ( float );
extern float fabsf  ( float );
extern float hypotf  ( float , float );
extern float powf  ( float , float );
extern float sqrtf  ( float );

extern float erff  ( float );
extern float erfcf  ( float );
extern float lgammaf  ( float );
extern float tgammaf  ( float );

extern float ceilf  ( float );
extern float floorf  ( float );
extern float nearbyintf  ( float );
extern float rintf  ( float );
extern long int lrintf  ( float );
extern float roundf  ( float );
extern long int lroundf  ( float );
extern float truncf  ( float );

extern float fmodf  ( float , float );
extern float remainderf  ( float , float );
extern float remquof  ( float , float , int * );

extern float copysignf  ( float , float );
extern float nanf  ( const char * );
extern float nextafterf  ( float , float );
extern float nexttowardf  ( float , long double );

extern float fdimf  ( float , float );
extern float fmaxf  ( float , float );
extern float fminf  ( float , float );

extern float fmaf  ( float , float , float );

extern long double acosl  ( long double );
extern long double asinl  ( long double );
extern long double atanl  ( long double );
extern long double atan2l  ( long double , long double );
extern long double cosl  ( long double );
extern long double sinl  ( long double );
extern long double tanl  ( long double );

extern long double acoshl  ( long double );
extern long double asinhl  ( long double );
extern long double atanhl  ( long double );
extern long double coshl  ( long double );
extern long double sinhl  ( long double );
extern long double tanhl  ( long double );

extern long double expl  ( long double );
extern long double exp2l  ( long double );
extern long double expm1l  ( long double );
extern long double frexpl  ( long double , int * );
extern int ilogbl  ( long double );
extern long double ldexpl  ( long double , int );
extern long double logl  ( long double );
extern long double log10l  ( long double );
extern long double log1pl  ( long double );
extern long double log2l  ( long double );
extern long double logbl  ( long double );
extern long double modfl  ( long double , long double * );
extern long double scalbnl  ( long double , int );
extern long double scalblnl  ( long double , long int );

extern long double cbrtl  ( long double );
extern long double fabsl  ( long double );
extern long double hypotl  ( long double , long double );
extern long double powl  ( long double , long double );
extern long double sqrtl  ( long double );

extern long double erfl  ( long double );
extern long double erfcl  ( long double );
extern long double lgammal  ( long double );
extern long double tgammal  ( long double );

extern long double ceill  ( long double );
extern long double floorl  ( long double );
extern long double nearbyintl  ( long double );
extern long double rintl  ( long double );
extern long int lrintl  ( long double );
extern long double roundl  ( long double );
extern long int lroundl  ( long double );
extern long double truncl  ( long double );

extern long double fmodl  ( long double , long double );
extern long double remainderl  ( long double , long double );
extern long double remquol  ( long double , long double , int * );

extern long double copysignl  ( long double , long double );
extern long double nanl  ( const char * );
extern long double nextafterl  ( long double , long double );
extern long double nexttowardl  ( long double , long double );

extern long double fdiml  ( long double , long double );
extern long double fmaxl  ( long double , long double );
extern long double fminl  ( long double , long double );

extern long double fmal  ( long double , long double , long double );

# 400
extern long long int llrint  ( double );
extern long long int llround  ( double );

extern long long int llrintf  ( float );
extern long long int llroundf  ( float );

extern long long int llrintl  ( long double );
extern long long int llroundl  ( long double );
# 409

#pragma	does_not_read_global_data(asinh, exp2, expm1)
#pragma	does_not_read_global_data(ilogb, log2)
#pragma	does_not_read_global_data(scalbn, scalbln, cbrt)
#pragma	does_not_read_global_data(erf, erfc, tgamma)
#pragma	does_not_read_global_data(nearbyint, rint, lrint, round, lround, trunc)
#pragma	does_not_read_global_data(remquo)
#pragma	does_not_read_global_data(copysign, nan, nexttoward)
#pragma	does_not_read_global_data(fdim, fmax, fmin, fma)
#pragma	does_not_write_global_data(asinh, exp2, expm1)
#pragma	does_not_write_global_data(ilogb, log2)
#pragma	does_not_write_global_data(scalbn, scalbln, cbrt)
#pragma	does_not_write_global_data(erf, erfc, tgamma)
#pragma	does_not_write_global_data(nearbyint, rint, lrint, round, lround, trunc)
#pragma	does_not_write_global_data(copysign, nan, nexttoward)
#pragma	does_not_write_global_data(fdim, fmax, fmin, fma)
# 426

#pragma	does_not_read_global_data(acosf, asinf, atanf, atan2f)
#pragma	does_not_read_global_data(cosf, sinf, tanf)
#pragma	does_not_read_global_data(acoshf, asinhf, atanhf, coshf, sinhf, tanhf)
#pragma	does_not_read_global_data(expf, exp2f, expm1f, frexpf, ilogbf, ldexpf)
#pragma	does_not_read_global_data(logf, log10f, log1pf, log2f, logbf)
#pragma	does_not_read_global_data(modff, scalbnf, scalblnf)
#pragma	does_not_read_global_data(cbrtf, fabsf, hypotf, powf, sqrtf)
#pragma	does_not_read_global_data(erff, erfcf, lgammaf, tgammaf)
#pragma	does_not_read_global_data(ceilf, floorf, nearbyintf)
#pragma	does_not_read_global_data(rintf, lrintf, roundf, lroundf, truncf)
#pragma	does_not_read_global_data(fmodf, remainderf, remquof)
#pragma	does_not_read_global_data(copysignf, nanf, nextafterf, nexttowardf)
#pragma	does_not_read_global_data(fdimf, fmaxf, fminf, fmaf)
#pragma	does_not_write_global_data(acosf, asinf, atanf, atan2f)
#pragma	does_not_write_global_data(cosf, sinf, tanf)
#pragma	does_not_write_global_data(acoshf, asinhf, atanhf, coshf, sinhf, tanhf)
#pragma	does_not_write_global_data(expf, exp2f, expm1f, ilogbf, ldexpf)
#pragma	does_not_write_global_data(logf, log10f, log1pf, log2f, logbf)
#pragma	does_not_write_global_data(cbrtf, fabsf, hypotf, powf, sqrtf)
#pragma	does_not_write_global_data(erff, erfcf, tgammaf)
#pragma	does_not_write_global_data(ceilf, floorf, nearbyintf)
#pragma	does_not_write_global_data(rintf, lrintf, roundf, lroundf, truncf)
#pragma	does_not_write_global_data(fmodf, remainderf)
#pragma	does_not_write_global_data(copysignf, nanf, nextafterf, nexttowardf)
#pragma	does_not_write_global_data(fdimf, fmaxf, fminf, fmaf)
# 452

#pragma	does_not_read_global_data(acosl, asinl, atanl, atan2l)
#pragma	does_not_read_global_data(cosl, sinl, tanl)
#pragma	does_not_read_global_data(acoshl, asinhl, atanhl, coshl, sinhl, tanhl)
#pragma	does_not_read_global_data(expl, exp2l, expm1l, frexpl, ilogbl, ldexpl)
#pragma	does_not_read_global_data(logl, log10l, log1pl, log2l, logbl)
#pragma	does_not_read_global_data(modfl, scalbnl, scalblnl)
#pragma	does_not_read_global_data(cbrtl, fabsl, hypotl, powl, sqrtl)
#pragma	does_not_read_global_data(erfl, erfcl, lgammal, tgammal)
#pragma	does_not_read_global_data(ceill, floorl, nearbyintl)
#pragma	does_not_read_global_data(rintl, lrintl, roundl, lroundl, truncl)
#pragma	does_not_read_global_data(fmodl, remainderl, remquol)
#pragma	does_not_read_global_data(copysignl, nanl, nextafterl, nexttowardl)
#pragma	does_not_read_global_data(fdiml, fmaxl, fminl, fmal)
#pragma	does_not_write_global_data(acosl, asinl, atanl, atan2l)
#pragma	does_not_write_global_data(cosl, sinl, tanl)
#pragma	does_not_write_global_data(acoshl, asinhl, atanhl, coshl, sinhl, tanhl)
#pragma	does_not_write_global_data(expl, exp2l, expm1l, ilogbl, ldexpl)
#pragma	does_not_write_global_data(logl, log10l, log1pl, log2l, logbl)
#pragma	does_not_write_global_data(cbrtl, fabsl, hypotl, powl, sqrtl)
#pragma	does_not_write_global_data(erfl, erfcl, tgammal)
#pragma	does_not_write_global_data(ceill, floorl, nearbyintl)
#pragma	does_not_write_global_data(rintl, lrintl, roundl, lroundl, truncl)
#pragma	does_not_write_global_data(fmodl, remainderl)
#pragma	does_not_write_global_data(copysignl, nanl, nextafterl, nexttowardl)
#pragma	does_not_write_global_data(fdiml, fmaxl, fminl, fmal)
# 478

#pragma	does_not_read_global_data(llrint, llround)
#pragma	does_not_read_global_data(llrintf, llroundf, llrintl, llroundl)
#pragma	does_not_write_global_data(llrint, llround)
#pragma	does_not_write_global_data(llrintf, llroundf, llrintl, llroundl)
# 487

# 535

# 539

# 33 "/usr/include/math.h"

# 59

# 63

# 67

# 75

# 78
 
# 94

extern int signgam;

# 98

# 100
 
# 103
enum version {libm_ieee = -1, c_issue_4, ansi_1, strict_ansi};

# 106
extern const enum version _lib_version;
# 110

struct exception {
	int type;
	char *name;
	double arg1;
	double arg2;
	double retval;
};

# 120

# 122

# 126

# 133

# 144

 
# 148
 
extern double erf  ( double );
extern double erfc  ( double );
extern double hypot  ( double , double );
extern double lgamma  ( double );

# 159

# 167
 

# 170
extern double gamma  ( double );		 
# 172
extern double j0  ( double );
extern double j1  ( double );
extern double jn  ( int , double );
extern double y0  ( double );
extern double y1  ( double );
extern double yn  ( int , double );

# 187
 
# 190
extern double scalb  ( double , double );

# 197

 
extern double acosh  ( double );
extern double asinh  ( double );
extern double atanh  ( double );
extern double cbrt  ( double );
extern double logb  ( double );
extern double nextafter  ( double , double );
extern double remainder  ( double , double );

 
# 210
extern double expm1  ( double );
extern int ilogb  ( double );
extern double log1p  ( double );
extern double rint  ( double );

# 226
 
# 228

# 230
 
# 233
extern int matherr  ( struct exception * );

 
# 238
extern double significand  ( double );

# 245

extern int signgamf;				 
extern int signgaml;				 

extern int isnanf  ( float );
extern int isnanl  ( long double );
extern float gammaf  ( float );		 
extern float gammaf_r  ( float , int * );	 
extern float j0f  ( float );
extern float j1f  ( float );
extern float jnf  ( int , float );
extern float lgammaf_r  ( float , int * );
extern float scalbf  ( float , float );
extern float significandf  ( float );
extern float y0f  ( float );
extern float y1f  ( float );
extern float ynf  ( int , float );
extern long double gammal  ( long double );	 
extern long double gammal_r  ( long double , int * );	 
extern long double j0l  ( long double );
extern long double j1l  ( long double );
extern long double jnl  ( int , long double );
extern long double lgammal_r  ( long double , int * );
extern long double scalbl  ( long double , long double );
extern long double significandl  ( long double );
extern long double y0l  ( long double );
extern long double y1l  ( long double );
extern long double ynl  ( int , long double );

# 291

 
# 295
extern void sincos  ( double , double * , double * );
extern void sincosf  ( float , float * , float * );
extern void sincosl  ( long double , long double * , long double * );

# 302

 
 
# 307
extern double copysign  ( double , double );
extern double scalbn  ( double , int );

# 315
 

 
# 321
extern double gamma_r  ( double , int * );	 
extern double lgamma_r  ( double , int * );

# 327

 
extern float modff  ( float , float * );

# 334
 

# 1 "/usr/include/floatingpoint.h"
 
# 21
 
 

 
# 28

# 31

#ident	"@(#)floatingpoint.h	2.12	07/05/17 SMI"

# 1 "/usr/include/sys/ieeefp.h"
 
# 21
 
# 25

# 28

#ident	"@(#)ieeefp.h	2.13	05/10/06 SMI"

# 34

 
# 39
enum fp_direction_type {	 
	fp_nearest	= 0,
	fp_tozero	= 1,
	fp_positive	= 2,
	fp_negative	= 3
};

enum fp_precision_type {	 
	fp_extended	= 0,
	fp_single	= 1,
	fp_double	= 2,
	fp_precision_3	= 3
};

enum fp_exception_type {	 
	fp_inexact	= 0,
	fp_division	= 1,
	fp_underflow	= 2,
	fp_overflow	= 3,
	fp_invalid	= 4
};

enum fp_trap_enable_type {	 
	fp_trap_inexact	= 0,
	fp_trap_division	= 1,
	fp_trap_underflow	= 2,
	fp_trap_overflow	= 3,
	fp_trap_invalid	= 4
};
# 69

# 103

enum fp_class_type {		 
	fp_zero		= 0,
	fp_subnormal	= 1,
	fp_normal	= 2,
	fp_infinity   	= 3,
	fp_quiet	= 4,
	fp_signaling	= 5
};

# 116

# 35 "/usr/include/floatingpoint.h"

# 39

 
# 47

# 55

# 1 "/usr/include/stdio_tag.h"
 
# 22
 
# 26

# 72 "/usr/include/floatingpoint.h"

# 74

typedef int sigfpe_code_type;	 

typedef void (*sigfpe_handler_type)();	 

# 82

extern sigfpe_handler_type sigfpe  ( sigfpe_code_type , sigfpe_handler_type );

 
# 88
typedef float single;

# 92
typedef unsigned extended[3];
# 94

typedef long double quadruple;	 

typedef unsigned fp_exception_field_type;
				 
# 102
 
# 106

typedef char decimal_string[ 512 ];
				 

typedef struct {
	enum fp_class_type fpclass;
	int	sign;
	int	exponent;
	decimal_string ds;	 
				 
				 
	int	more;		 
				 
				 
	int 	ndigits;	 
				 
				 
} decimal_record;

enum decimal_form {
	fixed_form,		 
				 
				 
				 
	floating_form		 
				 
};

typedef struct {
	enum fp_direction_type rd;
				 
	enum decimal_form df;	 
				 
	int ndigits;		 
} decimal_mode;

enum decimal_string_form {	 
	invalid_form,		 
	whitespace_form,	 
	fixed_int_form,		 
	fixed_intdot_form,	 
	fixed_dotfrac_form,	 
	fixed_intdotfrac_form,	 
	floating_int_form,	 
	floating_intdot_form,	 
	floating_dotfrac_form,	 
	floating_intdotfrac_form,  
	inf_form,		 
	infinity_form,		 
	nan_form,		 
	nanstring_form		 
};

extern void single_to_decimal  ( single * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 161
extern void double_to_decimal  ( double * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 163
extern void extended_to_decimal  ( extended * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 165
extern void quadruple_to_decimal  ( quadruple * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 167

extern void decimal_to_single  ( single * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 170
extern void decimal_to_double  ( double * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 172
extern void decimal_to_extended  ( extended * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 174
extern void decimal_to_quadruple  ( quadruple * , decimal_mode * , decimal_record * , fp_exception_field_type * ) ;
# 176

extern void string_to_decimal  ( char * * , int , int , decimal_record * , enum decimal_string_form * , char * * ) ;
# 179
extern void func_to_decimal  ( char * * , int , int , decimal_record * , enum decimal_string_form * , char * * , int ( * ) ( void ) , int * , int ( * ) ( int ) ) ;
# 182
extern void file_to_decimal  ( char * * , int , int , decimal_record * , enum decimal_string_form * , char * * , FILE * , int * ) ;
# 185

extern char *seconvert  ( single * , int , int * , int * , char * );
extern char *sfconvert  ( single * , int , int * , int * , char * );
extern char *sgconvert  ( single * , int , int , char * );
extern char *econvert  ( double , int , int * , int * , char * );
extern char *fconvert  ( double , int , int * , int * , char * );
extern char *gconvert  ( double , int , int , char * );
extern char *qeconvert  ( quadruple * , int , int * , int * , char * );
extern char *qfconvert  ( quadruple * , int , int * , int * , char * );
extern char *qgconvert  ( quadruple * , int , int , char * );

extern char *ecvt  ( double , int , int * , int * );
extern char *fcvt  ( double , int , int * , int * );
extern char *gcvt  ( double , int , char * );

 
# 204
extern double atof  ( const char * );
extern double strtod  ( const char * , char * * );

# 208

# 212

# 341 "/usr/include/math.h"

# 345

# 349

# 1 "/usr/include/limits.h"
 
# 22
 
# 26

 
 


# 33

#ident	"@(#)limits.h	1.61	05/06/08 SMI"

# 1 "/usr/include/sys/feature_tests.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/isa_defs.h"
 
# 21

 
# 26

# 1 "/usr/include/iso/limits_iso.h"
 
# 22
 
# 26

 
 


 
# 42

# 45

#ident	"@(#)limits_iso.h	1.4	05/06/08 SMI"

# 51

 
# 59

# 61

# 71

# 80
					 
# 82
					 
# 84
					 
# 93
					 
# 95
					 
# 97
					 
# 99

# 103

# 39 "/usr/include/limits.h"

 
# 1 "/usr/include/sys/int_limits.h"
 
# 22
 
# 26

# 52 "/usr/include/limits.h"

# 56

# 59

# 61

 
# 74

# 78

# 82

# 84

# 88

# 90

# 92

# 96

 
# 140
 
# 146
 
# 151

 
# 155

# 164
 
# 166

# 179

# 181

# 185

 
# 191

# 197

# 199

# 201
				 
# 208

# 215

 
# 220
							 
# 223
							 
# 225

 
# 229
							 
# 231
							 
# 233

# 235

# 239

# 241

# 244

# 247

 
# 264

# 269

# 271

# 276

# 280

# 292

# 295

# 297

 
# 322

# 326

# 19 "../../include/utils/timestamp.h"

 
# 29

typedef double Timestamp;

typedef struct
{
	double		time;			 
# 36
	int4		month;			 
# 38
} Interval;


# 55

# 62

# 65

# 68

# 77

# 86

# 91

# 99

# 102


 
# 107

 Timestamp *timestamp_in(char *str);
 char *timestamp_out(Timestamp *dt);
 bool timestamp_eq(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_ne(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_lt(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_le(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_ge(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_gt(Timestamp *dt1, Timestamp *dt2);
 bool timestamp_finite(Timestamp *timestamp);
 int	timestamp_cmp(Timestamp *dt1, Timestamp *dt2);
 Timestamp *timestamp_smaller(Timestamp *dt1, Timestamp *dt2);
 Timestamp *timestamp_larger(Timestamp *dt1, Timestamp *dt2);

 Interval *interval_in(char *str);
 char *interval_out(Interval *span);
 bool interval_eq(Interval *span1, Interval *span2);
 bool interval_ne(Interval *span1, Interval *span2);
 bool interval_lt(Interval *span1, Interval *span2);
 bool interval_le(Interval *span1, Interval *span2);
 bool interval_ge(Interval *span1, Interval *span2);
 bool interval_gt(Interval *span1, Interval *span2);
 bool interval_finite(Interval *span);
 int	interval_cmp(Interval *span1, Interval *span2);
 Interval *interval_smaller(Interval *span1, Interval *span2);
 Interval *interval_larger(Interval *span1, Interval *span2);

 text *timestamp_text(Timestamp *timestamp);
 Timestamp *text_timestamp(text *str);
 text *interval_text(Interval *interval);
 Interval *text_interval(text *str);
 Timestamp *timestamp_trunc(text *units, Timestamp *timestamp);
 Interval *interval_trunc(text *units, Interval *interval);
 float64 timestamp_part(text *units, Timestamp *timestamp);
 float64 interval_part(text *units, Interval *interval);
 text *timestamp_zone(text *zone, Timestamp *timestamp);

 Interval *interval_um(Interval *span);
 Interval *interval_pl(Interval *span1, Interval *span2);
 Interval *interval_mi(Interval *span1, Interval *span2);
 Interval *interval_mul(Interval *span1, float8 *factor);
 Interval *mul_d_interval(float8 *factor, Interval *span1);
 Interval *interval_div(Interval *span1, float8 *factor);

 Interval *timestamp_mi(Timestamp *dt1, Timestamp *dt2);
 Timestamp *timestamp_pl_span(Timestamp *dt, Interval *span);
 Timestamp *timestamp_mi_span(Timestamp *dt, Interval *span);
 Interval *timestamp_age(Timestamp *dt1, Timestamp *dt2);
 bool overlaps_timestamp(Timestamp *dt1, Timestamp *dt2, Timestamp *dt3, Timestamp *dt4);

 int	tm2timestamp(struct tm * tm, double fsec, int *tzp, Timestamp *dt);
 int	timestamp2tm(Timestamp dt, int *tzp, struct tm * tm, double *fsec, char **tzn);

 Timestamp SetTimestamp(Timestamp timestamp);
 Timestamp dt2local(Timestamp dt, int timezone);
 void dt2time(Timestamp dt, int *hour, int *min, double *sec);
 int	EncodeSpecialTimestamp(Timestamp dt, char *str);
 int	interval2tm(Interval span, struct tm * tm, float8 *fsec);
 int	tm2interval(struct tm * tm, double fsec, Interval *span);
 Timestamp *now(void);

# 1 "../../include/utils/datetime.h"
 
# 18

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/math.h"
 
# 21
 
# 25

# 1 "/usr/include/limits.h"
 
# 22
 
# 26

 
 


# 1 "../../include/utils/timestamp.h"
 
# 23 "../../include/utils/datetime.h"


 
# 34

# 46

# 63

 
# 70

# 74

# 77

 
# 83

# 101
 
# 105

 
# 116

# 119

# 124

# 136

# 151

# 156

 
# 160

# 162

# 165

# 172

 
typedef struct
{
# 179
	char		token[ 10 ];
# 181
	char		type;
	char		value;			 
} datetkn;


 
# 195


 
# 201

 int	day_tab[2][13];

# 205

 
# 210

# 214

# 218

# 225

# 232


 void GetCurrentTime(struct tm * tm);
 void j2date(int jd, int *year, int *month, int *day);
 int	date2j(int year, int month, int day);

 int ParseDateTime(char *timestr, char *lowstr,
			  char **field, int *ftype,
			  int maxfields, int *numfields);
 int DecodeDateTime(char **field, int *ftype,
			   int nf, int *dtype,
			   struct tm * tm, double *fsec, int *tzp);

 int DecodeTimeOnly(char **field, int *ftype,
			   int nf, int *dtype,
			   struct tm * tm, double *fsec, int *tzp);

 int DecodeDateDelta(char **field, int *ftype,
				int nf, int *dtype,
				struct tm * tm, double *fsec);

 int	EncodeDateOnly(struct tm * tm, int style, char *str);
 int	EncodeTimeOnly(struct tm * tm, double fsec, int *tzp, int style, char *str);
 int	EncodeDateTime(struct tm * tm, double fsec, int *tzp, char **tzn, int style, char *str);
 int	EncodeTimeSpan(struct tm * tm, double fsec, int style, char *str);

 int	DecodeDate(char *str, int fmask, int *tmask, struct tm * tm);
 int DecodeNumber(int flen, char *field,
			 int fmask, int *tmask,
			 struct tm * tm, double *fsec, int *is2digits);
 int DecodeNumberField(int len, char *str,
				  int fmask, int *tmask,
				  struct tm * tm, double *fsec, int *is2digits);
 int	DecodeSpecial(int field, char *lowtoken, int *val);
 int DecodeTime(char *str, int fmask, int *tmask,
		   struct tm * tm, double *fsec);
 int	DecodeTimezone(char *str, int *tzp);
 int	DecodeUnits(int field, char *lowtoken, int *val);
 datetkn *datebsearch(char *key, datetkn *base, unsigned int nel);

 int	j2day(int jd);

# 20 "../../include/utils/nabstime.h"


 
# 28
 
# 34
typedef int32 AbsoluteTime;
typedef int32 RelativeTime;

typedef struct
{
	int32		status;
	AbsoluteTime data[2];
} TimeIntervalData;
typedef TimeIntervalData *TimeInterval;

 
# 59

# 71

# 73

# 76

# 80

 
# 85

# 90

# 93

 AbsoluteTime GetCurrentAbsoluteTime(void);

 
# 102


 
# 107
 AbsoluteTime nabstimein(char *timestr);
 char *nabstimeout(AbsoluteTime time);

 bool abstimeeq(AbsoluteTime t1, AbsoluteTime t2);
 bool abstimene(AbsoluteTime t1, AbsoluteTime t2);
 bool abstimelt(AbsoluteTime t1, AbsoluteTime t2);
 bool abstimegt(AbsoluteTime t1, AbsoluteTime t2);
 bool abstimele(AbsoluteTime t1, AbsoluteTime t2);
 bool abstimege(AbsoluteTime t1, AbsoluteTime t2);
 bool abstime_finite(AbsoluteTime time);

 AbsoluteTime timestamp_abstime(Timestamp *timestamp);
 Timestamp *abstime_timestamp(AbsoluteTime abstime);

 bool AbsoluteTimeIsBefore(AbsoluteTime time1, AbsoluteTime time2);

 void abstime2tm(AbsoluteTime time, int *tzp, struct tm * tm, char *tzn);

 RelativeTime reltimein(char *timestring);
 char *reltimeout(RelativeTime timevalue);
 TimeInterval tintervalin(char *intervalstr);
 char *tintervalout(TimeInterval interval);
 RelativeTime interval_reltime(Interval *interval);
 Interval *reltime_interval(RelativeTime reltime);
 TimeInterval mktinterval(AbsoluteTime t1, AbsoluteTime t2);
 AbsoluteTime timepl(AbsoluteTime t1, RelativeTime t2);
 AbsoluteTime timemi(AbsoluteTime t1, RelativeTime t2);

 
 int	intinterval(AbsoluteTime t, TimeInterval interval);
 RelativeTime tintervalrel(TimeInterval interval);
 AbsoluteTime timenow(void);
 bool reltimeeq(RelativeTime t1, RelativeTime t2);
 bool reltimene(RelativeTime t1, RelativeTime t2);
 bool reltimelt(RelativeTime t1, RelativeTime t2);
 bool reltimegt(RelativeTime t1, RelativeTime t2);
 bool reltimele(RelativeTime t1, RelativeTime t2);
 bool reltimege(RelativeTime t1, RelativeTime t2);
 bool tintervalsame(TimeInterval i1, TimeInterval i2);
 bool tintervaleq(TimeInterval i1, TimeInterval i2);
 bool tintervalne(TimeInterval i1, TimeInterval i2);
 bool tintervallt(TimeInterval i1, TimeInterval i2);
 bool tintervalgt(TimeInterval i1, TimeInterval i2);
 bool tintervalle(TimeInterval i1, TimeInterval i2);
 bool tintervalge(TimeInterval i1, TimeInterval i2);
 bool tintervalleneq(TimeInterval i, RelativeTime t);
 bool tintervallenne(TimeInterval i, RelativeTime t);
 bool tintervallenlt(TimeInterval i, RelativeTime t);
 bool tintervallengt(TimeInterval i, RelativeTime t);
 bool tintervallenle(TimeInterval i, RelativeTime t);
 bool tintervallenge(TimeInterval i, RelativeTime t);
 bool tintervalct(TimeInterval i1, TimeInterval i2);
 bool tintervalov(TimeInterval i1, TimeInterval i2);
 AbsoluteTime tintervalstart(TimeInterval i);
 AbsoluteTime tintervalend(TimeInterval i);
 int32 int4reltime(int32 timevalue);
 text *timeofday(void);

# 19 "../../include/access/xact.h"

 
# 24
typedef struct TransactionStateData {
	TransactionId   transactionIdData;
	CommandId	commandId;
	CommandId	scanCommandId;
	AbsoluteTime    startTime;
	int             state;
	int             blockState;
} TransactionStateData;


typedef TransactionStateData *TransactionState;

typedef struct TransactionInfoStruct {
	TransactionState	CurrentTransactionState;
	int			XactIsoLevel;   
        bool 			SharedBufferChanged;
        bool 			CommitTime;
 
	unsigned char   	cachedTestXidStatus; 
	TransactionId 		cachedTestXid;
	int			RecoveryCheckingEnableState;
	bool			CommandIdCounterOverflowFlag;
        int               backupState;
         
 	Relation		LogRelation;
} TransactionInfo;
 
# 59

extern int	DefaultXactIsoLevel;
extern TransactionId DisabledTransactionId;

 
# 72

 
# 78
 
# 90

# 92


 
# 102


 
# 111

 bool IsAbortedTransactionBlockState(void);
 bool IsTransactionSystemDisabled(void);

 TransactionId GetCurrentTransactionId(void);
 CommandId GetCurrentCommandId(void);
 CommandId GetScanCommandId(void);
 void SetScanCommandId(CommandId);
 AbsoluteTime GetCurrentTransactionStartTime(void);
 bool TransactionIdIsCurrentTransactionId(TransactionId xid);
 bool CommandIdIsCurrentCommandId(CommandId cid);
 bool CommandIdGEScanCommandId(CommandId cid);
 void CommandCounterIncrement(void);
 void InitializeTransactionSystem(void);
 bool CurrentXactInProgress(void);
 void StartTransactionCommand(void);
 void CommitTransactionCommand(void);
 void AbortTransactionBlock(void);
 void SetAbortOnly(void);
 void BeginTransactionBlock(void);
 void CommitTransactionBlock(void);
 bool IsTransactionBlock(void);

 void CycleTransactionId(void);
 void StartTransaction(void);
 void CloneParentTransaction(void);
 void CloseSubTransaction(void);
 void AbortTransaction(void);
 void CommitTransaction(void);

 
 TransactionId xidin(char *representation);
 char *xidout(TransactionId* transactionId);
 bool xideq(TransactionId* xid1, TransactionId* xid2);
 void TransactionIdAdd(TransactionId *xid, int value);

 bool xidint8_equals(TransactionId* xid,int64 comp);
 bool xidint8_lt(TransactionId* xid,int64 comp);
 bool xidint8_gt(TransactionId* xid,int64 comp);
 bool xidint8_lteq(TransactionId* xid,int64 comp);
 bool xidint8_gteq(TransactionId* xid,int64 comp);
 bool xidint8_noteq(TransactionId* xid,int64 comp);

 bool xidint4_equals(TransactionId* xid,int32 comp);
 bool xidint4_lt(TransactionId* xid,int32 comp);
 bool xidint4_gt(TransactionId* xid,int32 comp);
 bool xidint4_lteq(TransactionId* xid,int32 comp);
 bool xidint4_gteq(TransactionId* xid,int32 comp);
 bool xidint4_noteq(TransactionId* xid,int32 comp);

 TransactionInfo* GetTransactionInfo(void);

# 166

# 21 "../../include/utils/tqual.h"

typedef struct SnapshotData
{
	TransactionId xmin;			 
	TransactionId xmax;			 
	uint32		xcnt;			 
	bool		isUser;
	TransactionId *xip;			 
	ItemPointerData tid;		 
} SnapshotData;

typedef SnapshotData * Snapshot;


typedef struct SnapshotHolder {
    Snapshot 		SnapshotDirty;    
    Snapshot            UserSnapshot;
    Snapshot 		QuerySnapshot;
    Snapshot 		SerializableSnapshot;
    bool                ReferentialIntegritySnapshotOverride;
} SnapshotHolder;



# 48

# 53

# 56
 
# 88

# 94

# 98
 SnapshotHolder* GetSnapshotHolder(void);
 bool HeapTupleSatisfiesItself(HeapTupleHeader tuple);
 bool HeapTupleSatisfiesNow(void* env,HeapTupleHeader tuple);
 bool HeapTupleSatisfiesDirty(void* env,HeapTupleHeader tuple, Snapshot snapshot);
 bool HeapTupleSatisfiesSnapshot(void* env,HeapTupleHeader tuple,
						   Snapshot snapshot);
 int	HeapTupleSatisfiesUpdate(void* env,HeapTuple tuple, Snapshot snapshot);

 Snapshot GetSnapshotData(bool serializable);
 void SetQuerySnapshot(void);
 void FreeXactSnapshot(void);
 void TakeUserSnapshot(void);
 void DropUserSnapshot(void);
 void CopySnapshot(Snapshot source, Snapshot dest);

 
typedef enum
{
	HEAPTUPLE_DEAD,				 
	HEAPTUPLE_LIVE,				 
	HEAPTUPLE_HARDENED,			 
	HEAPTUPLE_RECENTLY_DEAD,		 
	HEAPTUPLE_STILLBORN,
	HEAPTUPLE_INSERT_IN_PROGRESS,	 
	HEAPTUPLE_DELETE_IN_PROGRESS		 
} HTSV_Result;

 HTSV_Result HeapTupleSatisfiesVacuum(HeapTupleHeader tuple,
						 TransactionId OldestXmin);


# 132

# 18 "../../include/access/relscan.h"

typedef ItemPointerData MarkData;

typedef struct HeapScanDescData
{
	Relation	rs_rd;			 
	HeapTupleData rs_ctup;		 
	Buffer		rs_cbuf;		 
	ItemPointerData rs_mctid;	 
	ItemPointerData rs_mcd;		 
	Snapshot	rs_snapshot;	 
	uint16		rs_cdelta;		 
	uint16		rs_nkeys;		 
	ScanKey		rs_key;			 
} HeapScanDescData;

typedef HeapScanDescData *HeapScanDesc;

typedef struct IndexScanDescData
{
	Relation	relation;		 
	Relation	heapRelation;		 
	void	   	*opaque;			 

	ItemPointerData currentItemData;	 
	MarkData	currentMarkData; 

	uint8		flags;			 
	bool		scanFromEnd;	 
	uint16		numberOfKeys;	 
	ScanKey		keyData;		 
	
        HeapTupleData 	xs_ctup;		 
        
        FmgrInfo	fn_getnext;		 
        bool		keys_are_unique;
} IndexScanDescData;

typedef IndexScanDescData *IndexScanDesc;

 
# 64
typedef IndexScanDesc *IndexScanDescPtr;

 
# 71

 
# 77

# 1 "../../include/access/sdir.h"
 
# 16


 
# 22
typedef enum ScanDirection
{
	BackwardScanDirection = -1,
	NoMovementScanDirection = 0,
	ForwardScanDirection = 1
} ScanDirection;

 
# 36

 
# 43

 
# 50

 
# 57

# 1 "../../include/executor/hashjoin.h"
 
# 16

# 1 "../../include/access/htup.h"
  
# 1 "../../include/storage/buffile.h"
 
# 25

# 28

# 1 "../../include/storage/fd.h"
 
# 14

# 1 "../../include/postgres.h"
 
# 14
 
# 16 "../../include/storage/fd.h"

 
# 30 "../../include/storage/buffile.h"

 

typedef struct BufFile BufFile;

 
# 38

 BufFile *BufFileCreateTemp(void);
 BufFile *BufFileCreate(File file);
 void BufFileClose(BufFile *file);
 size_t BufFileRead(BufFile *file, void *ptr, size_t size);
 size_t BufFileWrite(BufFile *file, void *ptr, size_t size);
 int	BufFileSeek(BufFile *file, long offset, int whence);
 void BufFileTell(BufFile *file, long *offset);
 int	BufFileSeekBlock(BufFile *file, long blknum);
 long BufFileTellBlock(BufFile *file);

# 19 "../../include/executor/hashjoin.h"

 
# 41

typedef struct HashJoinTupleData
{
	struct HashJoinTupleData *next;		 
# 46
	HeapTupleData htup;			 
} HashJoinTupleData;

typedef HashJoinTupleData *HashJoinTuple;

typedef struct HashTableData
{
	int			nbuckets;		 
	int			totalbuckets;	 
	HashJoinTuple *buckets;		 
	 

	int			nbatch;			 
	int			curbatch;		 

	 
# 65
	BufFile   **innerBatchFile;  
	BufFile   **outerBatchFile;  
	long	   *outerBatchSize;  
# 69
	long	   *innerBatchSize;  
# 71

	 
# 77
	int16		typLen;
	bool		typByVal;

	 
# 90

	MemoryContext hashCxt;		 
	MemoryContext batchCxt;		 
} HashTableData;

typedef HashTableData *HashJoinTable;

# 1 "../../include/executor/tuptable.h"
 
# 20

# 1 "../../include/access/htup.h"
  
# 22 "../../include/executor/tuptable.h"

 
# 51
typedef struct TupleTableSlot
{
	NodeTag		type;
	HeapTuple	val;
	TupleDesc	ttc_tupleDescriptor;
        MemoryContext   ttc_cxt;
	bool		ttc_descIsNew;
	bool            ttc_shouldfree;
	int		ttc_whichplan;
} TupleTableSlot;

 
# 66
typedef struct TupleTableData
{
	int			size;			 
	int			next;			 
	TupleTableSlot *array;		 
        MemoryContext           cxt;
} TupleTableData;

typedef TupleTableData *TupleTable;

# 1 "../../include/nodes/params.h"
 
# 16

# 1 "../../include/access/attnum.h"
 
# 18 "../../include/nodes/params.h"

 
# 44

# 51


 
# 80

typedef struct ParamListInfoData
{
	int			kind;
	char	   *name;
	AttrNumber	id;
	Oid			type;
	Size		length;
	bool		isnull;
	bool		byval;
	Datum		value;
} ParamListInfoData;

typedef ParamListInfoData *ParamListInfo;

typedef struct ParamExecData
{
	void	   *execPlan;		 
# 99
	Datum		value;
	bool		isnull;
} ParamExecData;

# 1 "../../include/nodes/primnodes.h"
 
# 16

# 1 "../../include/access/attnum.h"
 
# 1 "../../include/nodes/pg_list.h"
 
# 1 "../../include/utils/fcache.h"
 
# 16

# 1 "../../include/fmgr.h"
 
# 18 "../../include/utils/fcache.h"


typedef struct
{
	int			typlen;			 
	int			typbyval;		 
	FmgrInfo	func;			 
# 26
	Oid			foid;			 
	Oid			language;		 
	int			nargs;			 

	 

	Oid		   *argOidVect;		 
	bool	   *nullVect;		 

	char	   *src;			 
	char	   *bin;			 
	char	   *func_state;		 

	bool		oneResult;		 
# 41
	bool		hasSetArg;		 
# 44

	Pointer		funcSlot;		 
# 48

	char	   *setArg;			 
# 53

	bool		istrusted;		 
} FunctionCache,
		   *FunctionCachePtr;

# 20 "../../include/nodes/primnodes.h"

 
# 25

 
# 58
typedef struct Resdom
{
	NodeTag		type;
	AttrNumber	resno;
	Oid			restype;
	int32		restypmod;
	char	   *resname;
	Index		ressortgroupref;
	Index		reskey;
	Oid			reskeyop;
	bool		resjunk;
} Resdom;

 
# 88
typedef struct Fjoin
{
	NodeTag		type;
	bool		fj_initialized;
	int			fj_nNodes;
	List	   *fj_innerNode;
	DatumPtr	fj_results;
	BoolPtr		fj_alwaysDone;
} Fjoin;

 
# 106
typedef enum OpType
{
	OP_EXPR, FUNC_EXPR, OR_EXPR, AND_EXPR, NOT_EXPR, SUBPLAN_EXPR
} OpType;

typedef struct Expr
{
	NodeTag		type;
	Oid			typeOid;		 
	OpType		opType;			 
	Node	   *oper;			 
	List	   *args;			 
} Expr;

 
# 144

# 147

typedef struct Var
{
	NodeTag		type;
	Index		varno;
	AttrNumber	varattno;
	Oid		vartype;
	int32		vartypmod;
	Index		varlevelsup;	 
	Index		varnoold;		 
	AttrNumber	varoattno;
} Var;

 
# 180
typedef struct Oper
{
	NodeTag		type;
	Oid			opno;
	Oid			opid;
	Oid			opresulttype;
	int			opsize;
	FunctionCachePtr op_fcache;
} Oper;


 
# 207
typedef struct Const
{
	NodeTag		type;
	Oid			consttype;
	int			constlen;
	Datum		constvalue;
	bool		constisnull;
	bool		constbyval;
	bool		constisset;
	bool		constiscast;
} Const;

 
# 246
typedef struct Param
{
	NodeTag		type;
	int			paramkind;
	AttrNumber	paramid;
	char	   *paramname;
	Oid			paramtype;
	List	   *param_tlist;
} Param;


 
# 272
typedef struct Func
{
	NodeTag		type;
	Oid			funcid;
	Oid			functype;
	bool		funcisindex;
	int			funcsize;
	FunctionCachePtr func_fcache;
	List	   *func_tlist;
	List	   *func_planlist;
} Func;

typedef struct Java
{
	NodeTag		type;
	Oid			funcid;
	Oid			functype;
	char*		funcname;
	char*		funcsig;
	char*		funcclazz;
	int			funcnargs;
 
	Oid*		funcargtypes;
	Node* 		java_target;
} Java;


 
# 305
typedef struct Iter
{
	NodeTag		type;
	Node	   *iterexpr;
	Oid			itertype;		 
# 311
} Iter;

 
# 325
typedef struct Aggref
{
	NodeTag		type;
	char	   *aggname;
	Oid			basetype;
	Oid			aggtype;
	Node	   *target;
	bool		usenulls;
	bool		aggstar;
	bool		aggdistinct;
	int			aggno;
} Aggref;

 
# 393
typedef enum SubLinkType
{
	EXISTS_SUBLINK, ALL_SUBLINK, ANY_SUBLINK, MULTIEXPR_SUBLINK, EXPR_SUBLINK
} SubLinkType;


typedef struct SubLink
{
	NodeTag		type;
	SubLinkType subLinkType;
	bool		useor;
	List	   *lefthand;
	List	   *oper;
	Node	   *subselect;
} SubLink;

 
# 424
typedef struct Array
{
	NodeTag		type;
	Oid			arrayelemtype;
	int			arrayelemlength;
	bool		arrayelembyval;
	int			arrayndim;
	IntArray	arraylow;
	IntArray	arrayhigh;
	int			arraylen;
} Array;

 
# 472
typedef struct ArrayRef
{
	NodeTag		type;
	int			refattrlength;
	int			refelemlength;
	Oid			refelemtype;
	bool		refelembyval;
	List	   *refupperindexpr;
	List	   *reflowerindexpr;
	Node	   *refexpr;
	Node	   *refassgnexpr;
} ArrayRef;

 
# 500

typedef struct RelabelType
{
	NodeTag		type;
	Node	   *arg;
	Oid			resulttype;
	int32		resulttypmod;
} RelabelType;

# 24 "../../include/nodes/execnodes.h"



 
# 38
typedef struct IndexInfo
{
	NodeTag		type;
	int			ii_NumKeyAttributes;
	AttrNumber *ii_KeyAttributeNumbers;
	FuncIndexInfoPtr ii_FuncIndexInfo;
	Node	   *ii_Predicate;
} IndexInfo;
 
# 61
typedef struct RelationInfo
{
	NodeTag		type;
	Index		ri_RangeTableIndex;
	Relation	ri_RelationDesc;
	int			ri_NumIndices;
	RelationPtr ri_IndexRelationDescs;
	IndexInfo **ri_IndexRelationInfo;
} RelationInfo;

 
# 82
typedef struct ExprContext
{
	NodeTag		type;
	TupleTableSlot *ecxt_scantuple;
	TupleTableSlot *ecxt_innertuple;
	TupleTableSlot *ecxt_outertuple;
	Relation	ecxt_relation;
	Index		ecxt_relid;
	ParamListInfo ecxt_param_list_info;
	ParamExecData *ecxt_param_exec_vals;		 
	List	   *ecxt_range_table;
	Datum	   *ecxt_aggvalues;  
	bool	   *ecxt_aggnulls;	 
} ExprContext;

 
# 113
typedef struct ProjectionInfo
{
	NodeTag		type;
	List	   *pi_targetlist;
	int			pi_len;
	Datum	   *pi_tupValue;
	ExprContext *pi_exprContext;
	TupleTableSlot *pi_slot;
} ProjectionInfo;

 
# 152
typedef struct JunkFilter
{
	NodeTag		type;
	List	   *jf_targetList;
	int			jf_length;
	TupleDesc	jf_tupType;
	List	   *jf_cleanTargetList;
	int			jf_cleanLength;
	TupleDesc	jf_cleanTupType;
	AttrNumber *jf_cleanMap;
} JunkFilter;

 
# 196
typedef struct EState
{
	NodeTag		type;
	ScanDirection es_direction;
	Snapshot	es_snapshot;
	List	   *es_range_table;
	RelationInfo *es_result_relation_info;
	List	  **es_result_relation_constraints;
	Relation	es_into_relation_descriptor;
	ParamListInfo es_param_list_info;
	ParamExecData *es_param_exec_vals;	 
	int			es_BaseId;
	TupleTable	es_tupleTable;
	JunkFilter *es_junkFilter;
	uint32		es_processed;	 
	Oid			es_lastoid;		 
	List	   *es_rowMark;		 
	 
	struct Plan *es_origPlan;
	Pointer		es_evalPlanQual;
	bool	   *es_evTupleNull;
	HeapTuple  *es_evTuple;
	bool		es_useEvalPlan;
} EState;

 
# 247

 
# 252

 

 
# 270
typedef struct CommonState
{
	NodeTag		type;			 
	int			cs_base_id;
	TupleTableSlot *cs_OuterTupleSlot;
	TupleTableSlot *cs_ResultTupleSlot;
	ExprContext *cs_ExprContext;
	ProjectionInfo *cs_ProjInfo;
	bool		cs_TupFromTlist;
} CommonState;


 
# 286

 
# 303
typedef struct ResultState
{
	CommonState cstate;			 
	bool		rs_done;
	bool		rs_checkqual;
} ResultState;

 
# 334
typedef struct AppendState
{
	CommonState cstate;			 
	int			as_whichplan;
	int			as_nplans;
	bool	   *as_initialized;
	List	   *as_rtentries;
	List	   *as_result_relation_info_list;
	List	   *as_junkFilter_list;
} AppendState;

 
# 349

 
# 371
typedef struct CommonScanState
{
	CommonState cstate;			 
	Relation	css_currentRelation;
	HeapScanDesc css_currentScanDesc;
	TupleTableSlot *css_ScanTupleSlot;
} CommonScanState;

 
# 405
typedef struct IndexScanState
{
	CommonState cstate;			 
	int			iss_NumIndices;
	int			iss_IndexPtr;
	int			iss_MarkIndexPtr;
	ScanKey    *iss_ScanKeys;
	int		   *iss_NumScanKeys;
	Pointer		iss_RuntimeKeyInfo;
	RelationPtr iss_RelationDescs;
	IndexScanDescPtr iss_ScanDescs;
} IndexScanState;

 
# 440
typedef struct TidScanState
{
	CommonState cstate;			 
	int			tss_NumTids;
	int			tss_TidPtr;
	int			tss_MarkTidPtr;
	ItemPointer *tss_TidList;
	HeapTupleData tss_htup;
} TidScanState;

 
# 454

 
# 468
typedef CommonState JoinState;

 
# 487
typedef struct NestLoopState
{
	JoinState	jstate;			 
	bool		nl_PortalFlag;
} NestLoopState;

 
# 513
typedef struct MergeJoinState
{
	JoinState	jstate;			 
	List	   *mj_OuterSkipQual;
	List	   *mj_InnerSkipQual;
	int			mj_JoinState;
	TupleTableSlot *mj_MarkedTupleSlot;
} MergeJoinState;

 
# 547
typedef struct HashJoinState
{
	JoinState	jstate;			 
	HashJoinTable hj_HashTable;
	int			hj_CurBucketNo;
	HashJoinTuple hj_CurTuple;
	Var		   *hj_InnerHashKey;
	TupleTableSlot *hj_OuterTupleSlot;
	TupleTableSlot *hj_HashTupleSlot;
} HashJoinState;


 
# 563

 
# 590
typedef struct MaterialState
{
	CommonScanState csstate;	 
	bool		mat_Flag;
	Relation	mat_TempRelation;
} MaterialState;

 
# 605
typedef struct AggStatePerAggData *AggStatePerAgg;		 

typedef struct AggState
{
	CommonScanState csstate;	 
	List	   *aggs;			 
	int			numaggs;		 
	AggStatePerAgg peragg;		 
	bool		agg_done;		 
} AggState;

 
# 621
typedef struct GroupState
{
	CommonScanState csstate;	 
	FmgrInfo   *eqfunctions;	 
	bool		grp_useFirstTuple;		 
	bool		grp_done;
	HeapTuple	grp_firstTuple;
} GroupState;

 
# 653
typedef struct SortState
{
	CommonScanState csstate;	 
	bool		sort_Done;
	ScanKey		sort_Keys;
	void	   *tuplesortstate;
} SortState;

 
# 681
typedef struct UniqueState
{
	CommonState cstate;			 
	FmgrInfo   *eqfunctions;	 
	HeapTuple	priorTuple;		 
        MemoryContext   save_cxt;
} UniqueState;


 
# 705
typedef struct HashState
{
	CommonState cstate;			 
	HashJoinTable hashtable;
} HashState;

# 740

# 1 "../../include/executor/executor.h"
 
# 16

# 1 "../../include/executor/execdesc.h"
 
# 17

# 1 "../../include/nodes/parsenodes.h"
 
# 16

# 1 "../../include/nodes/primnodes.h"
 
# 18 "../../include/nodes/parsenodes.h"

 
# 22

 
# 34
typedef struct Query
{
	NodeTag		type;

	CmdType		commandType;	 

	Node	   *utilityStmt;	 
# 42

	int			resultRelation;  
	char	   *into;			 
	bool		isPortal;		 
	bool		isBinary;		 
	bool		isTemp;			 
	bool		unionall;		 
	bool		hasAggs;		 
	bool		hasSubLinks;	 

	List	   *rtable;			 
	List	   *targetList;		 
	Node	   *qual;			 
	List	   *rowMark;		 

	List	   *distinctClause;  

	List	   *sortClause;		 

	List	   *groupClause;	 

	Node	   *havingQual;		 

	List	   *intersectClause;
	List	   *unionClause;	 
# 68

	Node	   *limitOffset;	 
	Node	   *limitCount;		 

	 
	List	   *base_rel_list;	 
	List	   *join_rel_list;	 
	List	   *equi_key_list;	 
# 77
	List	   *query_pathkeys;  
} Query;


 
# 89

 
# 94
 
typedef struct AlterTableStmt
{
	NodeTag		type;
	char		subtype;		 
# 100
	char	   *relname;		 
	bool		inh;			 
	char	   *name;			 
	Node	   *def;			 
	int			behavior;		 
} AlterTableStmt;

 
# 111
typedef struct ChangeACLStmt
{
	NodeTag		type;
	struct AclItem *aclitem;
	unsigned	modechg;
	List	   *relNames;
} ChangeACLStmt;

 
# 123
typedef struct ClosePortalStmt
{
	NodeTag		type;
	char	   *portalname;		 
} ClosePortalStmt;

 
# 133
typedef struct CopyStmt
{
	NodeTag		type;
	bool		binary;			 
	char	   *relname;		 
	bool		oids;			 
	int			direction;		 
	char	   *filename;		 
	char	   *delimiter;		 
	char	   *null_print;		 
} CopyStmt;

 
# 149
typedef struct CreateStmt
{
	NodeTag		type;
	bool		istemp;			 
	char	   *relname;		 
	List	   *tableElts;		 
	List	   *inhRelnames;	 
# 157
	List	   *constraints;	 
# 159
} CreateStmt;

 
# 179

typedef enum ConstrType			 
{
	CONSTR_NULL,				 
# 184
	CONSTR_NOTNULL,
	CONSTR_DEFAULT,
	CONSTR_CHECK,
	CONSTR_PRIMARY,
	CONSTR_UNIQUE,
	CONSTR_ATTR_DEFERRABLE,		 
	CONSTR_ATTR_NOT_DEFERRABLE,
	CONSTR_ATTR_DEFERRED,
	CONSTR_ATTR_IMMEDIATE,
	CONSTR_ATTR_STORAGE
} ConstrType;

typedef struct Constraint
{
	NodeTag		type;
	ConstrType	contype;
	char	   *name;			 
	Node	   *raw_expr;		 
	char	   *cooked_expr;	 
	List	   *keys;			 
} Constraint;


 
# 216

# 219

# 222

typedef struct FkConstraint
{
	NodeTag		type;
	char	   *constr_name;	 
	char	   *pktable_name;	 
	List	   *fk_attrs;		 
	List	   *pk_attrs;		 
	char	   *match_type;		 
	int32		actions;		 
	bool		deferrable;		 
	bool		initdeferred;	 
} FkConstraint;


 
# 241

typedef struct CreateTrigStmt
{
	NodeTag		type;
	char	   *trigname;		 
	char	   *relname;		 
	char	   *funcname;		 
	List	   *args;			 
	bool		before;			 
	bool		row;			 
	char		actions[4];		 
	char	   *lang;			 
	char	   *text;			 
	List	   *attr;			 
	char	   *when;			 

	 
	 
	bool		isconstraint;	 
	bool		deferrable;		 
	bool		initdeferred;	 
	char	   *constrrelname;	 
} CreateTrigStmt;

typedef struct DropTrigStmt
{
	NodeTag		type;
	char	   *trigname;		 
	char	   *relname;		 
} DropTrigStmt;


 
# 277
typedef struct CreatePLangStmt
{
	NodeTag		type;
	char	   *plname;			 
	char	   *plhandler;		 
	char	   *plcompiler;		 
	bool		pltrusted;		 
} CreatePLangStmt;

typedef struct DropPLangStmt
{
	NodeTag		type;
	char	   *plname;			 
} DropPLangStmt;


 
# 297
typedef struct CreateUserStmt
{
	NodeTag		type;
	char	   *user;			 
	char	   *password;		 
	int			sysid;			 
	bool		createdb;		 
	bool		createuser;		 
	List	   *groupElts;		 
	char	   *validUntil;		 
} CreateUserStmt;

typedef struct AlterUserStmt
{
	NodeTag		type;
	char	   *user;			 
	char	   *password;		 
	int			createdb;		 
	int			createuser;		 
	char	   *validUntil;		 
} AlterUserStmt;

typedef struct DropUserStmt
{
	NodeTag		type;
	List	   *users;			 
} DropUserStmt;


 
# 330
typedef struct CreateGroupStmt
{
	NodeTag		type;
	char	   *name;			 
	int			sysid;			 
	List	   *initUsers;		 
} CreateGroupStmt;

typedef struct AlterGroupStmt
{
	NodeTag		type;
	char	   *name;			 
	int			action;			 
	int			sysid;			 
	List	   *listUsers;		 
} AlterGroupStmt;

typedef struct DropGroupStmt
{
	NodeTag		type;
	char	   *name;
} DropGroupStmt;


 
# 358

typedef struct CreateSeqStmt
{
	NodeTag		type;
	char	   *seqname;		 
	List	   *options;
} CreateSeqStmt;

 
# 370
typedef struct VersionStmt
{
	NodeTag		type;
	char	   *relname;		 
	int			direction;		 
	char	   *fromRelname;	 
	char	   *date;			 
} VersionStmt;

 
# 383
typedef struct DefineStmt
{
	NodeTag		type;
	int			defType;		 
	char	   *defname;
	List	   *definition;		 
} DefineStmt;

 
# 395
typedef struct DropStmt
{
	NodeTag		type;
	List	   *relNames;		 
	bool		sequence;
	bool		schema;
} DropStmt;

 
# 407
typedef struct TruncateStmt
{
	NodeTag		type;
	char	   *relName;		 
} TruncateStmt;

 
# 417
typedef struct CommentStmt
{
	NodeTag		type;
	int			objtype;		 
	char	   *objname;		 
	char	   *objproperty;	 
	List	   *objlist;		 
	char	   *comment;		 
} CommentStmt;

 
# 431
typedef struct ExtendStmt
{
	NodeTag		type;
	char	   *idxname;		 
	Node	   *whereClause;	 
	List	   *rangetable;		 
# 438
} ExtendStmt;

 
# 444
typedef struct RecipeStmt
{
	NodeTag		type;
	char	   *recipeName;		 
} RecipeStmt;

 
# 454
typedef struct FetchStmt
{
	NodeTag		type;
	int			direction;		 
	int			howMany;		 
	char	   *portalname;		 
	bool		ismove;			 
} FetchStmt;

 
# 467
typedef struct IndexStmt
{
	NodeTag		type;
	char	   *idxname;		 
	char	   *relname;		 
	char	   *accessMethod;	 
	List	   *indexParams;	 
	List	   *withClause;		 
	Node	   *whereClause;	 
	List	   *rangetable;		 
# 478
	bool	   *lossy;			 
	bool		unique;			 
	bool		primary;		 
} IndexStmt;

 
# 487
typedef struct ProcedureStmt
{
	NodeTag		type;
	char	   *funcname;		 
	List	   *defArgs;		 
# 493
	Node	   *returnType;		 
# 495
	List	   *withClause;		 
	List	   *as;				 
	char	   *language;		 
} ProcedureStmt;

 
# 504
typedef struct RemoveAggrStmt
{
	NodeTag		type;
	char	   *aggname;		 
	char	   *aggtype;		 
} RemoveAggrStmt;

 
# 515
typedef struct RemoveFuncStmt
{
	NodeTag		type;
	char	   *funcname;		 
	List	   *args;			 
	Node		*rettype;
} RemoveFuncStmt;

 
# 527
typedef struct RemoveOperStmt
{
	NodeTag		type;
	char	   *opname;			 
	List	   *args;			 
} RemoveOperStmt;

 
# 538
typedef struct RemoveStmt
{
	NodeTag		type;
	int			removeType;		 
	char	   *name;			 
} RemoveStmt;

 
# 549
typedef struct RenameStmt
{
	NodeTag		type;
	char	   *relname;		 
	bool		inh;			 
	char	   *column;			 
# 557
	char	   *newname;		 
} RenameStmt;

 
# 564
typedef struct RuleStmt
{
	NodeTag		type;
	char	   *rulename;		 
	Node	   *whereClause;	 
	CmdType		event;			 
	struct Attr *object;		 
	bool		instead;		 
	List	   *actions;		 
} RuleStmt;

 
# 579
typedef struct NotifyStmt
{
	NodeTag		type;
	char	   *relname;		 
} NotifyStmt;

 
# 589
typedef struct ListenStmt
{
	NodeTag		type;
	char	   *relname;		 
} ListenStmt;

 
# 599
typedef struct UnlistenStmt
{
	NodeTag		type;
	char	   *relname;		 
} UnlistenStmt;

 
# 609
typedef struct TransactionStmt
{
	NodeTag		type;
	int			command;		 
} TransactionStmt;

 
# 619
typedef struct ViewStmt
{
	NodeTag		type;
	char	   *viewname;		 
	List	   *aliases;		 
	Query	   *query;			 
} ViewStmt;

 
# 631
typedef struct LoadStmt
{
	NodeTag		type;
	char	   *filename;		 
} LoadStmt;

 
# 641
typedef struct CreatedbStmt
{
	NodeTag		type;
	char	   *dbname;			 
	char	   *dbpath;			 
	int			encoding;		 
} CreatedbStmt;

 
# 653
typedef struct CreateSchemaStmt
{
	NodeTag		type;
	char	   *schemaname;			 
} CreateSchemaStmt;

 
# 663
typedef struct DropdbStmt
{
	NodeTag		type;
	char	   *dbname;			 
} DropdbStmt;

 
# 673
typedef struct ClusterStmt
{
	NodeTag		type;
	char	   *relname;		 
	char	   *indexname;		 
} ClusterStmt;

 
# 684
typedef struct VacuumStmt
{
	NodeTag		type;
	bool		verbose;		 
	bool		analyze;		 
	bool		fixflags;		 
	bool		exclusive;		 
	char	   *vacrel;			 
	List	   *va_spec;		 
} VacuumStmt;

 
# 699
typedef struct ExplainStmt
{
	NodeTag		type;
	Query	   *query;			 
	bool		verbose;		 
} ExplainStmt;

 
# 710

typedef struct VariableSetStmt
{
	NodeTag		type;
	char	   *name;
	char	   *value;
} VariableSetStmt;

 
# 722

typedef struct VariableShowStmt
{
	NodeTag		type;
	char	   *name;
} VariableShowStmt;

 
# 733

typedef struct VariableResetStmt
{
	NodeTag		type;
	char	   *name;
} VariableResetStmt;

 
# 744
typedef struct LockStmt
{
	NodeTag		type;
	char	   *relname;		 
	int			mode;			 
} LockStmt;


 
# 756
typedef struct ConstraintsSetStmt
{
	NodeTag		type;
	List	   *constraints;
	bool		deferred;
} ConstraintsSetStmt;

 
# 767
typedef struct ReindexStmt
{
	NodeTag		type;
	int			reindexType;	 
	const char *name;			 
	bool		force;
	bool		exclusive;
	bool		all;
} ReindexStmt;


 
# 781

 
# 786
typedef struct InsertStmt
{
	NodeTag		type;
	char	   *relname;		 
	List	   *distinctClause;  
# 793
	List	   *cols;			 
	List	   *targetList;		 
	List	   *fromClause;		 
	Node	   *whereClause;	 
	List	   *groupClause;	 
	Node	   *havingClause;	 
	List	   *unionClause;	 
	bool		unionall;		 
	List	   *intersectClause;
	List	   *forUpdate;		 
} InsertStmt;

 
# 809
typedef struct DeleteStmt
{
	NodeTag		type;
	char	   *relname;		 
	Node	   *whereClause;	 
} DeleteStmt;

 
# 820
typedef struct UpdateStmt
{
	NodeTag		type;
	char	   *relname;		 
	List	   *targetList;		 
	Node	   *whereClause;	 
	List	   *fromClause;		 
} UpdateStmt;

 
# 833
typedef struct SelectStmt
{
	NodeTag		type;
	List	   *distinctClause;  
# 839
	char	   *into;			 
	List	   *targetList;		 
	List	   *fromClause;		 
	Node	   *whereClause;	 
	List	   *groupClause;	 
	Node	   *havingClause;	 
	List	   *intersectClause;
	List	   *exceptClause;

	List	   *unionClause;	 
	List	   *sortClause;		 
	char	   *portalname;		 
	bool		binary;			 
	bool		istemp;			 
	bool		unionall;		 
	Node	   *limitOffset;	 
	Node	   *limitCount;		 
	List	   *forUpdate;		 
} SelectStmt;

 
# 866

 
# 870
typedef struct TypeName
{
	NodeTag		type;
	char	   *name;			 
	bool		timezone;		 
	bool		setof;			 
	int32		typmod;			 
	List	   *arrayBounds;	 
} TypeName;


# 883

 
# 887
typedef struct ParamNo
{
	NodeTag		type;
	int			number;			 
	TypeName   * typeName ;		 
	List	   *indirection;	 
} ParamNo;

typedef struct ParamName
{
	NodeTag		type;
	char*			name;			 
	TypeName   * typeName ;		 
	List	   *indirection;	 
} ParamName;

 
# 906
typedef struct A_Expr
{
	NodeTag		type;
	int			oper;			 
# 911
	char	   *opname;			 
	Node	   *lexpr;			 
	Node	   *rexpr;			 
} A_Expr;

 
# 922
typedef struct Attr
{
	NodeTag		type;
	char	   *relname;		 
	ParamNo    *paramNo;		 
	List	   *attrs;			 
# 929
	List	   *indirection;	 
} Attr;

 
# 935
typedef struct A_Const
{
	NodeTag		type;
	Value		val;			 
	TypeName   * typeName ;		 
} A_Const;

 
# 951
typedef struct TypeCast
{
	NodeTag		type;
	Node	   *arg;			 
	TypeName   * typeName ;		 
} TypeCast;

 
# 961
typedef struct CaseExpr
{
	NodeTag		type;
	Oid			casetype;
	Node	   *arg;			 
	List	   *args;			 
	Node	   *defresult;		 
} CaseExpr;

 
# 973
typedef struct CaseWhen
{
	NodeTag		type;
	Node	   *expr;			 
	Node	   *result;			 
} CaseWhen;

 
# 995
typedef struct ColumnDef
{
	NodeTag		type;
	char	   *colname;		 
	TypeName   * typeName ;		 
	bool		is_not_null;	 
	bool		is_sequence;	 
	Node	   *raw_default;	 
	char	   *cooked_default;  
	List	   *constraints;	 
} ColumnDef;

 
# 1014
typedef struct Ident
{
	NodeTag		type;
	char	   *name;			 
	List	   *indirection;	 
	bool		isRel;			 
# 1021
} Ident;

 
# 1031
typedef struct FuncCall
{
	NodeTag		type;
	char	   *attribute;
	char	   *funcname;		 
	List	   *args;			 
	bool		agg_star;		 
	bool		agg_distinct;	 
	bool      isJava;
} FuncCall;

 
# 1045
typedef struct A_Indices
{
	NodeTag		type;
	Node	   *lidx;			 
	Node	   *uidx;
} A_Indices;

 
# 1066
typedef struct ResTarget
{
	NodeTag		type;
	char	   *name;			 
	List	   *indirection;	 
# 1072
	Node	   *val;			 
# 1074
} ResTarget;

 
# 1079
typedef struct RelExpr
{
	NodeTag		type;
	char	   *relname;		 
	bool		inh;			 
} RelExpr;

 
# 1089
typedef struct SortGroupBy
{
	NodeTag		type;
	char	   *useOp;			 
	Node	   *node;			 
} SortGroupBy;

 
# 1099
typedef struct RangeVar
{
	NodeTag		type;
	RelExpr    *relExpr;		 
	Attr	   *name;			 
} RangeVar;

 
# 1109
typedef struct IndexElem
{
	NodeTag		type;
	char	   *name;			 
	List	   *args;			 
	char	   * aclass ;
	TypeName   * typeName ;		 
	bool		isJava;
} IndexElem;

 
# 1123
typedef struct DefElem
{
	NodeTag		type;
	char	   *defname;
	Node	   *arg;			 
} DefElem;

 
# 1133
typedef struct JoinExpr
{
	NodeTag		type;
	int			jointype;
	bool		isNatural;		 
	Node	   *larg;			 
	Node	   *rarg;			 
	Attr	   *alias;			 
	List	   *quals;			 
} JoinExpr;


 
# 1148

 
# 1156
typedef struct TargetEntry
{
	NodeTag		type;
	Resdom	   *resdom;			 
	Fjoin	   *fjoin;
	Node	   *expr;
} TargetEntry;

 
# 1199
typedef struct RangeTblEntry
{
	NodeTag		type;
	char	   *relname;		 
	Attr	   *ref;			 
	Attr	   *eref;			 
	Oid			relid;			 
	bool		inh;			 
	bool		inFromCl;		 
	bool		inJoinSet;		 
	bool		skipAcl;		 
} RangeTblEntry;

 
# 1227
typedef struct SortClause
{
	NodeTag		type;
	Index		tleSortGroupRef; 
	Oid			sortop;			 
} SortClause;

 
# 1242
typedef SortClause GroupClause;

# 1246

typedef struct RowMark
{
	NodeTag		type;
	Index		rti;			 
	bits8		info;			 
} RowMark;

# 1 "../../include/nodes/plannodes.h"
 
# 16

# 1 "../../include/nodes/execnodes.h"
 
# 1 "../../include/env/delegatedscan.h"
 
# 10


# 1 "../../include/utils/tqual.h"
 
# 1 "../../include/storage/itemptr.h"
 
# 1 "../../include/executor/tuptable.h"
 
# 15 "../../include/env/delegatedscan.h"

typedef struct DelegateData* Delegate;
typedef struct MarkerData* Marker;

 Marker DelegatedScanStart(void*(*scan_method)(Delegate), void* scan_args);
 bool DelegatedScanNext(Marker pointer, ItemPointer  ret_item);
 void DelegatedScanEnd(Marker pointer);

 bool DelegatedGetTuple(Marker marker, Relation rel, Snapshot time, TupleTableSlot* slot, ItemPointer pointer, Buffer * buffer);

 void* DelegatedScanArgs(Delegate delegate);
 bool DelegatedTransferPointers(Delegate delegate,ItemPointer items,int size);
 bool DelegatedCollectorWaiting(Delegate delegate);
 void DelegatedDone(Delegate delegate);

 int DelegatedGetTransferMax();
 void DelegatedSetTransferMax(int max);


# 19 "../../include/nodes/plannodes.h"

 
# 53


 
# 59

 
# 64

typedef struct Plan
{
	NodeTag		type;

	 
	Cost		startup_cost;	 
# 72
	Cost		total_cost;		 
# 74

	 
# 79
	double		plan_rows;		 
	int			plan_width;		 

	EState	   *state;			 
# 85
	List	   *targetlist;
	List	   *qual;			 
	struct Plan *lefttree;
	struct Plan *righttree;
	List	   *extParam;		 
# 95
	List	   *locParam;		 
	List	   *chgParam;		 
	List	   *initPlan;		 
# 99
	List	   *subPlan;		 
	 
# 105
	int			nParamExec;		 
# 108
} Plan;

 
# 119

 
# 125

 
# 130


 
# 137
typedef struct Result
{
	Plan		plan;
	Node	   *resconstantqual;
	ResultState *resstate;
} Result;

 
# 148
typedef struct Append
{
	Plan		plan;
	List	   *appendplans;
	List	   *unionrtables;	 
# 154
	Index		inheritrelid;	 
# 156
	List	   *inheritrtable;
	AppendState *appendstate;
} Append;

 
# 165
typedef struct Scan
{
	Plan		plan;
	Index		scanrelid;		 
	CommonScanState *scanstate;
} Scan;

 
# 176
typedef Scan SeqScan;

typedef struct DelegatedSeqScan {
    Scan                scan;
    void*               scanargs;
    Marker              delegate;
    Buffer              current;
} DelegatedSeqScan;

 
# 189
typedef struct IndexScan
{
	Scan		scan;
	List	   *indxid;
	List	   *indxqual;
	List	   *indxqualorig;
	ScanDirection indxorderdir;
	IndexScanState *indxstate;
} IndexScan;

 
# 203
typedef struct DelegatedIndexScan
{
	Scan		scan;
	Oid	   indexid;
	List	   *indxqual;
	List	   *indxqualorig;
        void*               scanargs;
	ScanDirection   indxorderdir;
        
        Marker               delegate;
        Buffer              current;
} DelegatedIndexScan;

 
# 220
typedef struct TidScan
{
	Scan		scan;
	bool		needRescan;
	List	   *tideval;
	TidScanState *tidstate;
} TidScan;

 
# 233

 
# 238
typedef Plan Join;

 
# 244
typedef struct NestLoop
{
	Join		join;
	NestLoopState *nlstate;
        
} NestLoop;

 
# 255
typedef struct MergeJoin
{
	Join		join;
	List	   *mergeclauses;
	MergeJoinState *mergestate;
} MergeJoin;

 
# 266
typedef struct HashJoin
{
	Join		join;
	List	   *hashclauses;
	Oid			hashjoinop;
	HashJoinState *hashjoinstate;
	bool		hashdone;
} HashJoin;

 
# 279
typedef struct Agg
{
	Plan		plan;
	AggState   *aggstate;
} Agg;

 
# 295
typedef struct Group
{
	Plan		plan;
	bool		tuplePerGroup;	 
	int			numCols;		 
	AttrNumber *grpColIdx;		 
	GroupState *grpstate;
} Group;

 
# 309
typedef struct Noname
{
	Plan		plan;
	Oid			nonameid;
	int			keycount;
} Noname;

 
# 320
typedef struct Material
{
	Plan		plan;			 
	Oid			nonameid;
	int			keycount;
	MaterialState *matstate;
} Material;

 
# 332
typedef struct Sort
{
	Plan		plan;			 
	Oid			nonameid;
	int			keycount;
	SortState  *sortstate;
} Sort;

 
# 344
typedef struct Unique
{
	Plan		plan;			 
	Oid			nonameid;
	int			keycount;
	int			numCols;		 
# 351
	AttrNumber *uniqColIdx;		 
	UniqueState *uniquestate;
} Unique;

 
# 359
typedef struct Hash
{
	Plan		plan;
	Var		   *hashkey;
	HashState  *hashstate;
} Hash;

# 388

 
# 393
typedef struct SubPlan
{
	NodeTag		type;
	Plan	   *plan;			 
	int			plan_id;		 
# 401
	List	   *rtable;			 
	 
	List	   *setParam;		 
# 405
	List	   *parParam;		 
	SubLink    *sublink;		 
# 409

	 
# 414
	bool		shutdown;		 
	HeapTuple	curTuple;		 
} SubPlan;

# 1 "../../include/tcop/dest.h"
 
# 54

# 1 "../../include/access/htup.h"
  
# 56 "../../include/tcop/dest.h"

 
# 62
typedef enum
{
	None,						 
	Debug,						 
	Local,						 
	Remote,						 
	RemoteInternal,				 
# 70
	SPI							 
} CommandDest;

 
# 79
typedef struct _DestReceiver DestReceiver;

struct _DestReceiver
{
	 
	void		(*receiveTuple) (HeapTuple tuple, TupleDesc typeinfo,
											 DestReceiver *self);
	 
	void		(*setup) (DestReceiver *self, TupleDesc typeinfo);
	void		(*cleanup) (DestReceiver *self);
	 
};

 

extern void BeginCommand(char *pname, int operation, TupleDesc attinfo,
			 bool isIntoRel, bool isIntoPortal, char *tag,
			 CommandDest dest);
extern DestReceiver *DestToFunction(CommandDest dest);
extern void EndCommand(char *commandTag, CommandDest dest);

 

extern void SendCopyBegin(void);
extern void ReceiveCopyBegin(void);
extern void NullCommand(CommandDest dest);
extern void ReadyForQuery(CommandDest dest);
extern void UpdateCommandInfo(int operation, Oid lastoid, uint32 tuples);
extern CommandDest WhereToSendOutput();
extern void SetWhereToSendOutput(CommandDest dest);
extern bool DoingCopyout();
extern void SetCopyout(bool in);

# 21 "../../include/executor/execdesc.h"

 
# 28
typedef struct QueryDesc
{
	CmdType		operation;		 
	Query	   *parsetree;
	Plan	   *plantree;
	CommandDest dest;			 
} QueryDesc;

 
# 40

 QueryDesc *CreateQueryDesc(Query *parsetree, Plan *plantree,
				CommandDest dest);
# 46

# 18 "../../include/executor/executor.h"

 
# 26
 
# 29

 
# 36
 
 
 void ExecOpenScanR(Oid relOid, int nkeys, ScanKey skeys, bool isindex,
			  ScanDirection dir, Snapshot snapshot,
			  Relation *returnRelation, Pointer *returnScanDesc);
 void ExecCloseR(Plan *node);
 void ExecReScan(Plan *node, ExprContext *exprCtxt);
 HeapScanDesc ExecReScanR(Relation relDesc, HeapScanDesc scanDesc,
			ScanDirection direction, int nkeys, ScanKey skeys);
 void ExecMarkPos(Plan *node);
 void ExecRestrPos(Plan *node);
 Relation ExecCreatR(TupleDesc tupType, Oid relationOid);

 
# 52
 JunkFilter *ExecInitJunkFilter(List *targetList, TupleDesc tupType);
 bool ExecGetJunkAttribute(JunkFilter *junkfilter, TupleTableSlot *slot,
					 char *attrName, Datum *value, bool *isNull);
 HeapTuple ExecRemoveJunk(JunkFilter *junkfilter, TupleTableSlot *slot);


 
# 61
 TupleDesc ExecutorStart(QueryDesc *queryDesc, EState *estate);
 TupleTableSlot *ExecutorRun(QueryDesc *queryDesc, EState *estate,
			int feature, Node* start,Node* limcount);
 void ExecutorEnd(QueryDesc *queryDesc, EState *estate);
 void ExecConstraints(char *caller, Relation rel, HeapTuple tuple,
				EState *estate);


 void ExecAppend(TupleTableSlot *slot, ItemPointer tupleid,
		   EState *estate);
 void ExecDelete(TupleTableSlot *slot, ItemPointer tupleid,
		   EState *estate);
 void ExecReplace(TupleTableSlot *slot, ItemPointer tupleid,
			EState *estate);

 
# 79
 bool ExecInitNode(Plan *node, EState *estate);
 TupleTableSlot *ExecProcNode(Plan *node);
 int	ExecCountSlotsNode(Plan *node);
 void ExecEndNode(Plan *node);

 
# 87
 Datum ExecEvalVar(Var * variable, ExprContext * econtext, 
                        bool * isNull,bool * byval, int * length);

 Datum ExecEvalParam(Param *expression, ExprContext *econtext,
			  bool *isNull);

 char *GetAttributeByNum(TupleTableSlot *slot, AttrNumber attrno,
				  bool *isNull,bool *freeable);
 char *GetAttributeByName(TupleTableSlot *slot, char *attname, bool *isNull,bool *freeable);
 Datum ExecEvalExpr(Node *expression, ExprContext *econtext, bool *isNull,
			 bool *isDone);
 bool ExecQual(List *qual, ExprContext *econtext, bool resultForNull);
 int	ExecTargetListLength(List *targetlist);
 TupleTableSlot *ExecProject(ProjectionInfo *projInfo, bool *isDone);

 
# 105
 TupleTableSlot *ExecScan(Scan *node, TupleTableSlot *(*accessMtd) ());

 
# 110
 TupleTable ExecCreateTupleTable(int initialSize);
 void ExecDropTupleTable(TupleTable table, bool shouldFree);
 TupleTableSlot *ExecAllocTableSlot(TupleTable table);
 TupleTableSlot *ExecCreateTableSlot();
 TupleTableSlot *ExecStoreTuple(HeapTuple tuple,TupleTableSlot *slot, bool transfer);
 TupleTableSlot *ExecClearTuple(TupleTableSlot *slot);
 TupleDesc ExecSetSlotDescriptor(TupleTableSlot *slot,
					  TupleDesc tupdesc);
 void ExecSetSlotDescriptorIsNew(TupleTableSlot *slot, bool isNew);
 void ExecInitResultTupleSlot(EState *estate, CommonState *commonstate);
 void ExecInitScanTupleSlot(EState *estate,
					  CommonScanState *commonscanstate);
 void ExecInitOuterTupleSlot(EState *estate, HashJoinState *hashstate);

 TupleDesc ExecGetTupType(Plan *node);
 TupleDesc ExecTypeFromTL(List *targetList);
 void SetChangedParamList(Plan *node, List *newchg);

 
# 131
 void ResetTupleCount(void);
 void ExecAssignNodeBaseInfo(EState *estate, CommonState *basenode);
 void ExecAssignExprContext(EState *estate, CommonState *commonstate);
 void ExecAssignResultType(CommonState *commonstate,
					 TupleDesc tupDesc);
 void ExecAssignResultTypeFromOuterPlan(Plan *node,
								  CommonState *commonstate);
 void ExecAssignResultTypeFromTL(Plan *node, CommonState *commonstate);
 TupleDesc ExecGetResultType(CommonState *commonstate);
 void ExecAssignProjectionInfo(Plan *node, CommonState *commonstate);
 void ExecFreeProjectionInfo(CommonState *commonstate);
 void ExecFreeExprContext(CommonState *commonstate);
 void ExecFreeTypeInfo(CommonState *commonstate);
 TupleDesc ExecGetScanType(CommonScanState *csstate);
 void ExecAssignScanType(CommonScanState *csstate,
				   TupleDesc tupDesc);
 void ExecAssignScanTypeFromOuterPlan(Plan *node,
								CommonScanState *csstate);
 Form_pg_attribute ExecGetTypeInfo(Relation relDesc);

 void ExecOpenIndices(Oid resultRelationOid,
				RelationInfo *resultRelationInfo);
 void ExecCloseIndices(RelationInfo *resultRelationInfo);
 void ExecInsertIndexTuples(TupleTableSlot *slot, ItemPointer tupleid,
					  EState *estate, bool is_update);
# 159

# 1 "../../include/utils/palloc.h"
 
# 1 "../../include/utils/portal.h"
 
# 14
 
# 21

# 1 "../../include/executor/execdesc.h"
 
# 1 "../../include/nodes/memnodes.h"
 
# 16

# 1 "../../include/nodes/nodes.h"
 
# 18 "../../include/nodes/memnodes.h"

 
# 35

typedef struct MemoryContextMethods
{
	void	   *(*alloc) (MemoryContext context, Size size);
	 
	void		(*free_p) (MemoryContext context, void *pointer);
	void	   *(*realloc) (MemoryContext context, void *pointer, Size size);
	void		(*init) (MemoryContext context);
	void		(*reset) (MemoryContext context);
	void		(*delete) (MemoryContext context);
# 48
	size_t		(*stats) (MemoryContext context);
} MemoryContextMethods;


typedef struct MemoryContextData
{
	NodeTag		type;			 
	MemoryContextMethods *methods;		 
	MemoryContext parent;		 
	MemoryContext firstchild;	 
	MemoryContext nextchild;	 
	char	   *name;			 
} MemoryContextData;

 


 
# 73

# 24 "../../include/utils/portal.h"


typedef struct PortalData *Portal;

typedef struct PortalData
{
	char	   *name;			 
	MemoryContext heap;			 
	QueryDesc  *queryDesc;		 
	TupleDesc	attinfo;
	CommandId	commandId;		 
	EState	   *state;			 
	bool		atStart;		 
	bool		atEnd;			 
	void		(*cleanup) (Portal);	 
} PortalData;

 
# 46

 
# 55

 
# 61


 void EnablePortalManager(void);
 void AtEOXact_portals(void);
 Portal CreatePortal(char *name);
 void PortalDrop(Portal portal);
 Portal GetPortalByName(char *name);
 void PortalSetQuery(Portal portal, QueryDesc *queryDesc,
			   TupleDesc attinfo, EState *state,
			   void (*cleanup) (Portal portal));

# 33 "../../include/env/WeaverConnection.h"

typedef struct preparedplan {
        List*		querytreelist;
        List*		plantreelist;

       MemoryContext   bindcontext;
       MemoryContext   exec_cxt;
       MemoryContext   fetch_cxt;

        TupleDesc	tupdesc;
        EState*		state;
        QueryDesc*	qdesc;
} PreparedPlan;

typedef struct output {
	short index;
	void* target;
	int	 size;
	Oid	 type;
	short*  isNull;
	int*	length;
} Output;

typedef struct input {
	short 	index;
	char	name[256];
	int 	varSize;
	Oid 	type;
	int 	ctype;
	short*  isNotNull;
	void*	target;
} Binder;


typedef enum stage {
	STMT_NEW,
	STMT_PARSED,
	STMT_EXEC,
	STMT_BOUND,
	STMT_LINKED,
	STMT_SELECT,
	STMT_FETCH,
        STMT_COMMIT,
        STMT_ABORT,
	STMT_INVALID
} Stage;

# 81

typedef struct commcursor {
        int			ptr;
        int                     end;
        int                     size;
        char                    buffer[ 8192 ];
} CommCursor;

typedef struct commbuffer {
	int			header;
        int                     pipeid;
        int                     streamid;
        int			(*pipe)(int pipeid,int streamid,char* buffer,int start,int run);
} CommBuffer;

typedef struct stdcomm {
    CommBuffer          pipe;
    CommCursor          cursor;
} StdComm;

typedef struct Connection {
    double              align;
    Error		CDA;	
    short		validFlag;

    char		password[256];
    char 		name[256];
    char 		connect[256];

    char		statement[8192];
    Stage		stage;

    Binder		input[ 32 ];
    char*		lineup[ 32 ];
    Oid                 targs[ 32 ];
    int                 nargs;

    short		openCursor;
    short		indie;

 		
    PreparedPlan*	plan;
    Output		output[ 32 ];
 
    Env*                            env;
    
    struct Connection*              parent;             
    int                             child_count;
    int                             child_trans;
    pthread_t                       transaction_owner;

    pthread_mutex_t                 child_lock;
    
    int 		cursor;
    int 		processed;
    int                 abortonly;
} * WConn;

# 142
void WHandleError( WConn conn,int sqlError );
void  WResetExecutor(PreparedPlan* plan);
void WResetQuery( WConn conn);
 
bool TransferValue(Output* target, Form_pg_attribute desc, Datum value);

# 151

# 30 "WeaverConnection.c"

# 1 "../../include/access/heapam.h"
 
# 16

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 19 "../../include/access/heapam.h"

# 1 "../../include/access/htup.h"
  
# 1 "../../include/access/relscan.h"
 
# 1 "../../include/access/tupmacs.h"
 
# 16

# 1 "../../include/utils/memutils.h"
 
# 19

# 1 "../../include/nodes/memnodes.h"
 
# 21 "../../include/utils/memutils.h"


 
# 36

# 38

 
# 48
typedef struct StandardChunkHeader
{
	MemoryContext context;		 
	Size		size;			 
# 56
} StandardChunkHeader;

# 59

# 62
		
# 65
 
# 80


# 83

 
# 87
 void MemoryContextInit(void);

 void MemoryContextInitEnv(void);
 void MemoryContextDestroyEnv(void);

 MemoryContext MemoryContextGetTopContext(void);

 void MemoryContextDelete(MemoryContext context);
 void MemoryContextResetChildren(MemoryContext context);
 void MemoryContextDeleteChildren(MemoryContext context);
 void MemoryContextResetAndDeleteChildren(MemoryContext context);
 size_t MemoryContextStats(MemoryContext context);
 void MemoryContextCheck(MemoryContext context);
 bool MemoryContextContains(MemoryContext context, void *pointer);
 bool MemoryContextReset(MemoryContext context);

 
# 108
 MemoryContext MemoryContextCreate(NodeTag tag, Size size,
					MemoryContextMethods *methods,
					MemoryContext parent,
					const char *name);


 
# 117

 
 MemoryContext AllocSetContextCreate(MemoryContext parent,
					  const char *name,
					  Size minContextSize,
					  Size initBlockSize,
					  Size maxBlockSize);
 
 MemoryContext SubSetContextCreate(MemoryContext parent,
					  const char *name);
 
 
# 132
  
# 139

# 18 "../../include/access/tupmacs.h"

 
# 23

 
# 73

# 75

 
# 92

# 104

# 1 "../../include/storage/block.h"
 
# 1 "../../include/storage/lmgr.h"
 
# 1 "../../include/utils/rel.h"
 
# 1 "../../include/utils/tqual.h"
 
# 27 "../../include/access/heapam.h"

 
# 32

typedef struct HeapAccessStatisticsData
{
	time_t		init_global_timestamp;	 
	time_t		local_reset_timestamp;	 
	time_t		last_request_timestamp;  

	int			global_open;
	int			global_openr;
	int			global_close;
	int			global_beginscan;
	int			global_rescan;
	int			global_endscan;
	int			global_getnext;
	int			global_fetch;
	int			global_insert;
	int			global_delete;
	int			global_replace;
	int			global_mark4update;
	int			global_markpos;
	int			global_restrpos;
	int			global_BufferGetRelation;
	int			global_RelationIdGetRelation;
	int			global_RelationIdGetRelation_Buf;
	int			global_RelationNameGetRelation;
	int			global_getreldesc;
	int			global_heapgettup;
	int			global_RelationPutHeapTuple;
	int			global_RelationPutLongHeapTuple;

	int			local_open;
	int			local_openr;
	int			local_close;
	int			local_beginscan;
	int			local_rescan;
	int			local_endscan;
	int			local_getnext;
	int			local_fetch;
	int			local_insert;
	int			local_delete;
	int			local_replace;
	int			local_mark4update;
	int			local_markpos;
	int			local_restrpos;
	int			local_BufferGetRelation;
	int			local_RelationIdGetRelation;
	int			local_RelationIdGetRelation_Buf;
	int			local_RelationNameGetRelation;
	int			local_getreldesc;
	int			local_heapgettup;
	int			local_RelationPutHeapTuple;
	int			local_RelationPutLongHeapTuple;
} HeapAccessStatisticsData;

typedef HeapAccessStatisticsData *HeapAccessStatistics;

# 90

 
# 102

  Datum nocachegetattr ( HeapTuple tup , int attnum ,
			   TupleDesc att, bool *isnull);

# 107

# 143

# 193

 
# 214
 
  
# 254

# 256
 
# 259
 
# 263
 

 

  Relation heap_open ( Oid relationId , LOCKMODE lockmode ) ;
  Relation heap_openr ( const char * relationName , LOCKMODE lockmode ) ;
  void heap_close ( Relation relation , LOCKMODE lockmode ) ;
  HeapScanDesc heap_beginscan ( Relation relation ,
			   Snapshot snapshot, unsigned nkeys, ScanKey key);
  void heap_rescan ( HeapScanDesc scan , ScanKey key ) ;
  void heap_endscan ( HeapScanDesc scan ) ;
  HeapTuple heap_getnext ( HeapScanDesc scandesc ) ;
  bool heap_fetch ( Relation relation , Snapshot snapshot , HeapTuple tup , Buffer * userbuf ) ;
  ItemPointerData heap_get_latest_tid ( Relation relation , Snapshot snapshot , ItemPointer tid ) ;
  Oid	heap_insert ( Relation relation , HeapTuple tup ) ;
  int	heap_delete ( Relation relation , ItemPointer tid , ItemPointer ctid , Snapshot snapshot ) ;
  int heap_update ( Relation relation , ItemPointer otid , HeapTuple tup ,
			ItemPointer ctid, Snapshot snapshot);
  int	heap_mark4update ( Relation relation , Buffer * userbuf , HeapTuple tup , Snapshot snapshot ) ;
  void heap_markpos ( HeapScanDesc scan ) ;
  void heap_restrpos ( HeapScanDesc scan ) ;
 
  int ComputeDataSize ( TupleDesc tupleDesc , Datum * value , char * nulls ) ;
  void DataFill ( char * data , TupleDesc tupleDesc ,
		 Datum *value, char *nulls, uint16 *infomask,
		 bits8 *bit);
  int	heap_attisnull ( HeapTuple tup , int attnum ) ;
  int	heap_sysattrlen ( AttrNumber attno ) ;
  bool heap_sysattrbyval ( AttrNumber attno ) ;
  Datum nocachegetattr ( HeapTuple tup , int attnum ,
			   TupleDesc att, bool *isnull);
  HeapTuple heap_copytuple ( HeapTuple tuple ) ;
  HeapTuple heap_formtuple ( TupleDesc tupleDescriptor ,
			   Datum *value, char *nulls);
  HeapTuple heap_modifytuple ( HeapTuple tuple ,
		Relation relation, Datum *replValue, char *replNull, char *repl);
  void heap_freetuple ( HeapTuple tuple ) ;
HeapTuple	heap_addheader(uint32 natts, int structlen, char *structure);

 bool
HeapKeyTest(HeapTuple tuple, TupleDesc tupdesc, int nkeys, ScanKey keys);
 bool
HeapTupleSatisfies(Relation relation,Buffer buffer,HeapTuple tuple, 
						   Snapshot seeself, 
						   int nKeys, 
						   ScanKey key);
 Datum
HeapGetAttr(HeapTuple tup,int attnum,TupleDesc tupleDesc,bool* isnull);
 Datum
HeapFetchAtt(Form_pg_attribute* ap, void* tupledata);
 
  void PrintHeapAccessStatistics ( HeapAccessStatistics stats ) ;

  void initam ( void ) ;
# 320

# 1 "../../include/access/blobstorage.h"
 
# 16

# 1 "../../include/storage/itemptr.h"
 
# 1 "../../include/utils/rel.h"
 
# 1 "../../include/access/htup.h"
  
# 20 "../../include/access/blobstorage.h"

# 23

int delete_tuple_blob(Relation rel, HeapTuple direct);
BlockNumber store_tuple_blob(Relation rel, HeapTuple direct, int16 attnum);
BlockNumber span_buffered_blob(Relation rel,HeapTuple direct);

HeapTuple vacuum_respan_tuple_blob(Relation rel, HeapTuple tuple, bool exclude_self);
int vacuum_dup_chain_blob(Relation storerel, ItemPointer front, BlockNumber * last_moved);
HeapTuple vacuum_relink_tuple_blob(Relation rel, HeapTuple tuple);

Size sizeof_tuple_blob(Relation rel, HeapTuple tuple);
Size sizeof_max_tuple_blob();

bytea* rebuild_indirect_blob(Datum item);

Datum
open_read_pipeline_blob(Datum pointer, bool read_only);
Datum
open_write_pipeline_blob(Relation rel);
void 
close_read_pipeline_blob(Datum pipe);
Datum 
close_write_pipeline_blob(Datum pipe);
uint32 
sizeof_indirect_blob(Datum pipe);
bool 
read_pipeline_segment_blob(Datum pipe, char* target,int * length, int limit);
bool
write_pipeline_segment_blob(Datum pipe, bytea * data);

# 60


# 1 "../../include/utils/relcache.h"
 
# 16

# 1 "../../include/utils/rel.h"
 
# 1 "../../include/lib/hasht.h"
 
# 17

# 1 "../../include/utils/hsearch.h"
 
# 19 "../../include/lib/hasht.h"

typedef void (*HashtFunc) (void *hashitem, int arg);

 void HashTableWalk(HTAB *hashtable, HashtFunc function, long arg);

# 19 "../../include/utils/relcache.h"


    
typedef struct relidcacheent
{
	Oid	reloid;
	Relation	reldesc;
} RelIdCacheEnt;

typedef struct relnamecacheent
{
	NameData	relname;
	Relation	reldesc;
} RelNameCacheEnt;

# 35
 
# 38
 Relation RelationIdCacheGetRelation(Oid relationId,Oid databaseId);
 Relation RelationIdGetRelation(Oid relationId,Oid databaseId);
 Relation RelationNameGetRelation(const char *relationName,Oid dadtabaseId);

 void RelationClose(Relation relation);
 void RelationForgetRelation(Oid rid,Oid databaseId);

 
# 48
 void RelationIdInvalidateRelationCache(Oid relationId,Oid databaseId);

 void RelationCacheInvalidate(void);
 void RelationCacheShutdown(void);

 MemoryContext RelationGetCacheContext();

 void RelationRegisterRelation(Relation relation);
 void RelationPurgeLocalRelation(bool xactComitted);
 void InitIndexRelations(void);
 void RelationInitialize(void);
 void RelationCacheAbort(void);
 void RelationCacheCommit(void);
 void RelationCacheWalk(HashtFunc func, int arg);
 void ReportTransactionStatus(int level,char* id);

 void RelationSetReadTrigger(Relation rel, BufferTrigger* read);
 void RelationClearReadTrigger(Relation rel);
 void PrintRelcacheMemory(void);

# 1 "../../include/catalog/pg_shadow.h"
 
# 25


 

bool		superuser(void);

 
# 36
 typedef struct FormData_pg_shadow  
{
	NameData	usename;
	int4		usesysid;
	bool		usecreatedb;
	bool		usetrace;
	bool		usesuper;
	bool		usecatupd;
	text		passwd;
	int4		valuntil;
} FormData_pg_shadow;

 
# 53
typedef FormData_pg_shadow *Form_pg_shadow;

 
# 68

 
# 76
 extern int errno ;

# 1 "../../include/lib/stringinfo.h"
 
# 19

 
# 32
typedef struct StringInfoData
{
	char	   *data;
	int			len;
	int			maxlen;
} StringInfoData;

typedef StringInfoData *StringInfo;


 
# 63

 
# 68
 StringInfo makeStringInfo(void);

 
# 75
 void initStringInfo(StringInfo str);

 
# 84
 void appendStringInfo(StringInfo str, const char *fmt,...);

 
# 91
 void appendStringInfoChar(StringInfo str, char ch);

 
# 102

 
# 108
 void appendBinaryStringInfo(StringInfo str,
					   const char *data, int datalen);

# 1 "../../include/tcop/tcopprot.h"
 
# 21

# 1 "/usr/include/setjmp.h"
 
# 22
 
 


 
# 30

# 1 "../../include/executor/execdesc.h"
 
# 1 "../../include/parser/parse_node.h"
 
# 15

# 1 "../../include/nodes/parsenodes.h"
 
# 1 "../../include/utils/rel.h"
 
# 18 "../../include/parser/parse_node.h"

 
# 25
typedef struct ParseState
{
	int			p_last_resno;
	List	   *p_rtable;
	struct ParseState *parentParseState;
	bool		p_hasAggs;
	bool		p_hasSubLinks;
	bool		p_is_insert;
	bool		p_is_update;
	bool		p_is_rule;
	bool		p_in_where_clause;
	Relation	p_target_relation;
	RangeTblEntry *p_target_rangetblentry;
	List	   *p_shape;
	List	   *p_alias;
	List	   *p_join_quals;
} ParseState;

 ParseState *make_parsestate(ParseState *parentParseState);
 Expr *make_op(char *opname, Node *ltree, Node *rtree);
 Node *make_operand(char *opname, Node *tree,
			 Oid orig_typeId, Oid target_typeId);
 Var *make_var(ParseState *pstate, Oid relid, char *refname,
		 char *attrname);
 ArrayRef *transformArraySubscripts(ParseState *pstate,
						 Node *arrayBase,
						 List *indirection,
						 bool forceSlice,
						 Node *assignFrom);
 Const *make_const(Value *value);

# 25 "../../include/tcop/tcopprot.h"

extern  sigjmp_buf Warn_restart;
extern bool Warn_restart_ready;
extern bool InError;
extern bool ExitAfterAbort;

# 35

extern List *pg_parse_and_rewrite(char *query_string,
					 Oid *typev, 
					 char** argnames,
					 int nargs,
					 bool aclOverride);
extern Plan *pg_plan_query(Query *querytree);
extern void pg_exec_query_acl_override(char *query_string);
extern void pg_exec_query_dest(char *query_string,
				   CommandDest dest,
				   bool aclOverride);

# 48

extern void handle_warn( int postgres_signal_arg );
extern void quickdie( int postgres_signal_arg );
extern void die( int postgres_signal_arg );
extern void FloatExceptionHandler( int postgres_signal_arg );
extern void CancelQuery(void);
extern int PostgresMain(int argc, char *argv[],
			 int real_argc, char *real_argv[]);
extern void ResetUsage(void);
extern void ShowUsage(void);
# 61

# 1 "../../include/utils/syscache.h"
 
# 18

# 1 "../../include/access/htup.h"
  
# 20 "../../include/utils/syscache.h"

   


 
# 33

# 63

 
# 68
struct cachedesc
{
	char	   *name;			 
# 72
	int			nkeys;
	int			key[4];
	int			size;			 
	char	   *indname;		 
# 77
	HeapTuple	(*iScanFunc) (); 
};
# 82

 void zerocaches(void);
 void InitCatalogCache(void);
 HeapTuple SearchSysCacheTupleCopy(int cacheId,
						Datum key1, Datum key2, Datum key3, Datum key4);
 HeapTuple SearchSysCacheTuple(int cacheId,
					Datum key1, Datum key2, Datum key3, Datum key4);
 Datum SysCacheGetAttr(int cacheId, HeapTuple tup,
				AttrNumber attributeNumber,
				bool *isnull);
# 95

# 1 "../../include/catalog/pg_type.h"
 
# 21

 
# 28

 
# 39
 typedef struct FormData_pg_type  
{
	NameData	typname;
	int4		typowner;
	int2		typlen;

	 
# 50
	int2		typprtlen;

	 
# 62
	bool		typbyval;
	char		typtype;

	 
# 71
	bool		typisdefined;
	char		typdelim;
	Oid			typrelid;		 
	Oid			typelem;

	 
# 81
	regproc		typinput;
	regproc		typoutput;
	regproc		typreceive;
	regproc		typsend;
	char		typalign;

	 
# 109
	text		typdefault;		 
} FormData_pg_type;

 
# 117
typedef FormData_pg_type *Form_pg_type;

 
# 140

 
# 145
 

 

 
# 153

 
 extern int errno ;
 extern int errno ;
# 158

 extern int errno ;
 extern int errno ;
# 162

 extern int errno ;
 extern int errno ;
# 166

 extern int errno ;
 extern int errno ;

 extern int errno ;
 extern int errno ;
# 173

 extern int errno ;
 extern int errno ;
# 177

 extern int errno ;
 extern int errno ;
# 181

 extern int errno ;
 extern int errno ;
# 185

 extern int errno ;
 extern int errno ;
# 189

 extern int errno ;
 extern int errno ;
# 193

 extern int errno ;
 extern int errno ;
# 197

 extern int errno ;
 extern int errno ;
# 201

 extern int errno ;
 extern int errno ;
# 205
 extern int errno ;
 extern int errno ;
# 208

 extern int errno ;
 extern int errno ;
# 212

 extern int errno ;
 extern int errno ;
# 216

 extern int errno ;
 extern int errno ;
# 220

 extern int errno ;
 extern int errno ;
# 224

 extern int errno ;
 extern int errno ;
# 228

 extern int errno ;
 extern int errno ;
# 232

 extern int errno ;
 extern int errno ;
# 236

 extern int errno ;
 extern int errno ;

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;

 

 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;

 

 extern int errno ;
 extern int errno ;

 

 

 

 
 extern int errno ;
 extern int errno ;
# 273
 extern int errno ;
 extern int errno ;
# 276
 extern int errno ;
 extern int errno ;
# 279
 extern int errno ;
 extern int errno ;
# 282
 extern int errno ;
 extern int errno ;
# 285
 extern int errno ;
 extern int errno ;

 extern int errno ;
 extern int errno ;
# 291

# 296
 

 extern int errno ;
 extern int errno ;
# 301
 extern int errno ;
 extern int errno ;
# 304
 extern int errno ;
 extern int errno ;
# 307
 extern int errno ;
 extern int errno ;
# 310
 extern int errno ;
 extern int errno ;
# 313
 extern int errno ;
 extern int errno ;
# 316

 extern int errno ;
 extern int errno ;
# 320

# 324
 extern int errno ;
 extern int errno ;
# 327

# 331
 
 extern int errno ;
 extern int errno ;
 extern int errno ;
 extern int errno ;
# 337
 extern int errno ;
 extern int errno ;
# 340

 
 extern int errno ;
 extern int errno ;
# 345

# 377
 
# 382

# 384
 extern int errno ;
 extern int errno ;

# 393
 extern int errno ;
 extern int errno ;
# 396
 extern int errno ;
 extern int errno ;
# 399

 extern int errno ;
 extern int errno ;
# 403
 extern int errno ;
 extern int errno ;
# 406
 
# 411
 extern int errno ;
 extern int errno ;
# 417
 extern int errno ;
 extern int errno ;
# 423
 
# 427
 extern int errno ;
 extern int errno ;
# 433
 
 extern int errno ;
 extern int errno ;
# 440
 extern int errno ;
 extern int errno ;
# 446
 
 extern int errno ;
 extern int errno ;
# 450

 
 extern int errno ;
 extern int errno ;
# 455

# 457

  
# 461
extern Oid	TypeGet(char *typeName, bool *defined);
extern Oid	TypeShellMake(char *typeName);
extern Oid TypeCreate(char *typeName,
		   Oid relationOid,
		   int16 internalSize,
		   int16 externalSize,
		   char typeType,
		   char typDelim,
		   char *inputProcedure,
		   char *outputProcedure,
		   char *receiveProcedure,
		   char *sendProcedure,
		   char *elementTypeName,
		   char *defaultTypeValue,
		   bool passedByValue, char alignment);
extern void TypeRename(const char *oldTypeName, const char *newTypeName);
extern char *makeArrayTypeName(char *typeName);


# 1 "../../include/executor/executor.h"
 
# 1 "../../include/tcop/pquery.h"
 
# 16

# 1 "../../include/executor/execdesc.h"
 
# 18 "../../include/tcop/pquery.h"

 
# 27

extern EState *CreateExecutorState(void);


extern void ProcessPortal(char *portalName, Query *parseTree,
			  Plan *plan, EState *state, TupleDesc attinfo,
			  CommandDest dest);

extern void ProcessQuery(Query *parsetree, Plan *plan, CommandDest dest);
# 39

# 1 "../../include/tcop/utility.h"
 
# 16

# 1 "../../include/executor/execdesc.h"
 
# 21 "../../include/tcop/utility.h"

extern void ProcessUtility(Node *parsetree, CommandDest dest);

# 27

# 1 "../../include/nodes/execnodes.h"
 
# 1 "../../include/env/dbwriter.h"


# 5


# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/unistd.h"
 
# 21
 
 


 
# 29

# 10 "../../include/env/dbwriter.h"

# 1 "../../include/c.h"
 
# 15
 
# 12 "../../include/env/dbwriter.h"


# 1 "../../include/storage/buf_internals.h"
 
# 15 "../../include/env/dbwriter.h"

# 19


void DBWriterInit(int maxcount,int timeout,int hgc_threshold,int hgc_updatewt,int hgc_factor);

void DBCreateWriterThread(void);

void CommitDBBufferWrites(TransactionId xid,int state);

void FlushAllDirtyBuffers(void);
void RegisterBufferWrite(BufferDesc * bufHdr,bool release);

void ClearAllDBWrites(BufferDesc* bufHdr);
void ShutdownDBWriter(void);
bool IsDBWriter(void);

void ResetAccessCounts(Oid relid,Oid dbid);

char* RequestSnapshot(char* cmd);

# 41


# 1 "../../include/env/dolhelper.h"


# 5


# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 9 "../../include/env/dolhelper.h"




typedef struct dol_connection_data * DolConnection;

 void InitializeDol(void);

 DolConnection GetDolConnection(void);

 long DestroyDolConnection(DolConnection conn);

 void ProcessDolCommand(DolConnection conn,void*(*start_routine)(void*),void* arg);

 bool IsDolConnectionAvailable(void);

 void ShutdownDolHelpers(void);

 void CancelDolHelpers(void);

 int CheckDolHelperErrors();

 int GetDolHelperErrorMessage(char* state,char* msg);
# 45 "WeaverConnection.c"

# 1 "../../include/storage/sinvaladt.h"
 
# 16

# 1 "../../include/storage/ipc.h"
 
# 1 "../../include/storage/itemptr.h"
 
# 1 "../../include/storage/shmem.h"
 
# 20 "../../include/storage/sinvaladt.h"

 
# 50


 
# 61

# 64

 
typedef struct SharedInvalidData
{
	int			cacheId;		 
	Index		hashIndex;
	ItemPointerData pointerData;
} SharedInvalidData;

typedef SharedInvalidData *SharedInvalid;

 
typedef struct ProcState
{
	 
	int			nextMsgNum;		 
	int                    resetState;		 
	int			tag;			 
	SHMEM_OFFSET procStruct;	 
} ProcState;

 
typedef struct SISeg
{

	 
# 92
	int			minMsgNum;		 
	int			maxMsgNum;		 
	int			maxBackends;	 
	
	int 			nextBackendTag;
	 
# 100
	SharedInvalidData buffer[ 4096 ];

	 
# 108
	ProcState	procState[1];	 
} SISeg;


extern SISeg *shmInvalBuffer;	 
# 114


 
# 122
 
 int SISegmentInit(bool createNewSegment, IPCKey key,
			  int maxBackends);
 int	SIBackendInit(SISeg *segP);
 bool  SIResetProcState(SISeg *segP);
 bool SIInsertDataEntry(SISeg *segP, SharedInvalidData *data);
 int SIGetDataEntry(SISeg *segP, int backendId,
			   SharedInvalidData *data);
 void SIDelExpiredDataEntries(SISeg *segP);
 void CallableCleanupInvalidationState(void); 
 
 void  CallableInitInvalidationState(void);

# 138

# 1 "../../include/storage/multithread.h"
 
# 16

# 18

# 1 "/usr/include/pthread.h"
 
# 21

 
# 26

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/setjmp.h"
 
# 22
 
 


 
# 30

# 1 "../../include/access/xlog.h"
 
# 10

# 1 "../../include/access/rmgr.h"
 
# 10

typedef uint8 RmgrId;

typedef struct RmgrData
{
	char	   *rm_name;
	char	   *(*rm_redo) ();	 
	char	   *(*rm_undo) ();	 
} RmgrData;

extern RmgrData *RmgrTable;

 
# 33

# 1 "../../include/access/transam.h"
 
# 13 "../../include/access/xlog.h"

typedef struct XLogRecPtr
{
	uint32		xlogid;			 
	uint32		xrecoff;		 
} XLogRecPtr;

typedef struct XLogRecord
{
	XLogRecPtr	xl_prev;		 
	XLogRecPtr	xl_xact_prev;	 
	TransactionId xl_xid;		 
	uint16		xl_len;			 
	uint8		xl_info;
	RmgrId		xl_rmid;		 

	 

} XLogRecord;

# 35
 
# 39
typedef struct XLogSubRecord
{
	uint16		xl_len;
	uint8		xl_info;

	 

} XLogSubRecord;

# 49

# 51

# 53

typedef struct XLogPageHeaderData
{
	uint32		xlp_magic;
	uint16		xlp_info;
} XLogPageHeaderData;

# 61

typedef XLogPageHeaderData *XLogPageHeader;

# 65
extern void 
SetControlFilePath(char* path);
extern void 
SetXLogDir(char* path);

extern XLogRecPtr XLogInsert(RmgrId rmid, char *hdr, uint32 hdrlen,
		   char *buf, uint32 buflen);
extern void XLogFlush(XLogRecPtr RecPtr);
extern int XLOGShmemSize(void);
extern void XLOGShmemInit(void);
# 1 "../../include/storage/lock.h"
 
# 1 "../../include/storage/backendid.h"
 
# 16

 
# 21
typedef int16 BackendId;		 
# 23

# 25

typedef int32 BackendTag;		 

# 29
 
# 25 "../../include/storage/multithread.h"

 
# 37
 
# 41

typedef struct procglobal
{
	SHMEM_OFFSET 	freeProcs;
	pid_t		groupleader;
	pid_t		subs[64];
	int		count;
 

	 
# 55
} PROC_HDR;
# 60

# 65

 
# 77

 
# 84

# 87

extern SPINLOCK ThreadStructLock;

 
# 93

 void InitThread(ThreadType tt);
 void InitThreadGlobal(IPCKey key, int maxBackends);
 void ThreadReleaseLocks(bool isCommit);
 bool DestroyThread(void);

 

 void ThreadTransactionStart(TransactionId xid);
 TransactionId ThreadTransactionEnd();
 void ThreadTransactionReset();

 void ThreadQueueInit(THREAD_QUEUE *queue, pthread_mutex_t* lock);
 int ThreadSleep(LOCKMETHODCTL *lockctl,LOCKMODE lockmode,LOCK *lock,HOLDER *holder);
 THREAD *ThreadWakeup(THREAD *proc, int errType);
 int ThreadLockWakeup( LOCKMETHOD lockmethod,LOCK *lock);
 void ThreadAddLock(SHM_QUEUE *elem);
 void ThreadReleaseSpins(THREAD *proc);
 void LockWaitCancel(void); 
 void ShutdownProcess(bool master);

 THREAD* GetMyThread();

 BackendId GetMyBackendId();
 void SetMyBackendId(BackendId in);

 BackendTag GetMyBackendTag();
 void SetMyBackendTag(BackendTag in);


# 1 "../../include/storage/sinval.h"
 
# 16

# 1 "../../include/storage/itemptr.h"
 
# 1 "../../include/storage/spin.h"
 
# 19 "../../include/storage/sinval.h"

extern SPINLOCK SInvalLock;

 void CreateSharedInvalidationState(IPCKey key, int maxBackends);
 void AttachSharedInvalidationState(IPCKey key);
 void InitSharedInvalidationState(void);
 void RegisterSharedInvalid(int cacheId, Index hashIndex,
					  ItemPointer pointer);
 void InvalidateSharedInvalid(void);
 void InvalidateAllCaches(void);

 bool DatabaseHasActiveBackends(Oid databaseId);
 bool TransactionIdIsInProgress(TransactionId xid);


# 1 "../../include/storage/smgr.h"
 
# 1 "../../include/storage/lock.h"
 
# 1 "../../include/miscadmin.h"
 
# 25

# 1 "/usr/include/sys/types.h"
 
# 21
 
 


 
# 29

# 27 "../../include/miscadmin.h"

# 1 "../../include/utils/trace.h"
 
# 11

# 14

# 1 "/usr/include/string.h"
 
# 21
 
 


 
# 29

# 1 "/usr/include/time.h"
 
# 21
 
 


 
# 29

# 17 "../../include/utils/trace.h"

# 25

 int	tprintf(int flag, const char *fmt,...);
 int	eprintf(const char *fmt,...);
 void write_syslog(int level, char *line);
 void show_options(void);
 void parse_options(char *str, bool secure);
 void read_pg_options( int postgres_signal_arg );

 
# 37
enum pg_option_enum
{
	TRACE_ALL,					 
# 41
	TRACE_VERBOSE,
	TRACE_QUERY,
	TRACE_PLAN,
	TRACE_PARSE,
	TRACE_REWRITTEN,
	TRACE_PRETTY_PLAN,			 
	TRACE_PRETTY_PARSE,
	TRACE_PRETTY_REWRITTEN,
	TRACE_PARSERSTATS,
	TRACE_PLANNERSTATS,
	TRACE_EXECUTORSTATS,
	TRACE_SHORTLOCKS,			 
	TRACE_LOCKS,
	TRACE_USERLOCKS,
	TRACE_SPINLOCKS,
	TRACE_NOTIFY,
	TRACE_MALLOC,
	TRACE_PALLOC,
	TRACE_LOCKOIDMIN,
	TRACE_LOCKRELATION,
	OPT_LOCKREADPRIORITY,		 
	OPT_DEADLOCKTIMEOUT,		 
	OPT_NOFSYNC,				 
	OPT_SYSLOG,					 
	OPT_HOSTLOOKUP,				 
	OPT_SHOWPORTNUMBER,			 

	NUM_PG_OPTIONS				 
};

 int	pg_options[NUM_PG_OPTIONS];

# 82

# 84

 
# 29 "../../include/miscadmin.h"

 
# 33

 
# 37
extern int	PostmasterMain(int argc, char *argv[]);

 
# 42
extern bool Noversion;
extern bool Quiet;
extern char *DataDir;

extern int	MyProcPid;

extern struct Port *MyProcPort;
extern long MyCancelKey;

extern char OutputFileName[];

 
# 59

extern bool MyDatabaseIdIsInitialized;
extern Oid	MyDatabaseId;

extern int	DebugLvl;

 
# 81

# 83

# 88

extern int	DateStyle;
extern bool EuroDates;
extern bool HasCTZSet;
extern bool CDayLight;
extern int	CTimeZone;
extern char CTZName[];

extern char FloatFormat[];
extern char DateFormat[];

# 100

extern bool allowSystemTableMods;
extern int	SortMem;
 
# 106
 
# 110
 
# 117

 
extern void GetRawDatabaseInfo(const char *name, Oid *db_id, char *path);
extern Oid GetDatabaseInfo(const char *name,char *path);
extern char *ExpandDatabasePath(const char *path);

 
extern void SetDatabaseName(const char *name);
extern void SetDatabasePath(const char *path);
extern char* GetDatabaseName(void);
extern char* GetDatabasePath(void);
extern Oid	GetDatabaseId( void );

 
# 133
extern const char *getdatabaseencoding(void);
extern const char *pg_encoding_to_char(int);
extern int	pg_char_to_encoding(const char *);

extern char *getpgusername(void);
extern void SetPgUserName(char * name);
extern int	GetUserId(void);
extern void SetUserId(void);
extern int	ValidateBinary(char *path);
extern int	FindExec(char *backend, char *argv0, char *binary_name);
extern int	CheckPathAccess(char *path, char *name, int open_mode);

# 148

 
# 151

 
# 156
 
# 174


 
# 180
 
# 184

typedef int16 ExitStatus;

# 189
 

 
 
# 198
extern  void InitPostgres(const char *dbname);
# 202

 
# 205


# 210

 void IgnoreSystemIndexes(bool mode);
 bool IsIgnoringSystemIndexes(void);
 bool IsCacheInitialized(void);
 void SetWaitingForLock(bool);

# 219

 
# 226

# 230

extern void SetPidFname(char *datadir);
extern char *GetPidFname(void);
extern void UnlinkPidFile(void);
extern int	SetPidFile(pid_t pid);

# 239


# 1 "../../include/access/printtup.h"
 
# 16

# 1 "../../include/tcop/dest.h"
 
# 18 "../../include/access/printtup.h"

# 22

  DestReceiver * printtup_create_DR ( void ) ;
  void showatts ( char * name , TupleDesc attinfo ) ;
  void debugtup ( HeapTuple tuple , TupleDesc typeinfo ,
		 DestReceiver *self);
  void printtup_internal ( HeapTuple tuple , TupleDesc typeinfo ,
				  DestReceiver *self);

 
  void spi_printtup ( HeapTuple tuple , TupleDesc tupdesc ,
			 DestReceiver *self);

  int	getTypeOutAndElem ( Oid type , Oid * typOutput , Oid * typElem ) ;
# 38

# 1 "../../include/access/htup.h"
  
# 1 "../../include/parser/gramparse.h"
 
# 14

# 17


# 22
 
 void init_io(void);
 
 void yyerror(const char *message);

 
 Oid	param_type(int t);
 Oid	param_type_name(char* t);
 void parser_init(Oid *typev, char** names, int nargs);
 int	yyparse(void);

# 36

# 1 "../../include/executor/executor.h"
 
# 1 "../../include/catalog/heap.h"
 
# 16

# 1 "../../include/utils/rel.h"
 
# 18 "../../include/catalog/heap.h"

typedef struct RawColumnDefault
{
	AttrNumber	attnum;			 
	Node	   *raw_default;	 
# 24
} RawColumnDefault;

 Oid	RelnameFindRelid(const char *relname);
 Relation heap_create(char *relname, TupleDesc att,
			bool isnoname, bool istemp, bool storage_create);
 bool heap_storage_create(Relation rel);

 Oid heap_create_with_catalog(char *relname, TupleDesc tupdesc,
						 char relkind, bool istemp);

 void heap_drop_with_catalog(const char *relname);
 void heap_truncate(char *relname);
 void heap_drop(Relation rel);

 void AddRelationRawConstraints(Relation rel,
						  List *rawColDefaults,
						  List *rawConstraints);
 void AddRelationStorageDirectives(Relation rel,
						  List *rawConstraints);
 void RemoveSchemaInheritance(char* name);
 bool IsExternalStore(Relation rel);
 void InitNoNameRelList(void);
 void DropNoNameRels(void);

# 1 "../../include/utils/temprel.h"
 
# 16

# 1 "../../include/access/htup.h"
  
# 18 "../../include/utils/temprel.h"

void		create_temp_relation(const char *relname, HeapTuple pg_class_tuple);
void		remove_all_temp_relations(void);
void		invalidate_temp_relations(void);
void		remove_temp_relation(Oid relid);
char	   *get_temp_rel_by_username(const char *user_relname);
char	   *get_temp_rel_by_physicalname(const char *relname);

# 1 "../../include/parser/parse_coerce.h"
 
# 16

# 1 "../../include/catalog/pg_type.h"
 
# 1 "../../include/parser/parse_node.h"
 
# 19 "../../include/parser/parse_coerce.h"

typedef enum CATEGORY
{
	INVALID_TYPE,
	UNKNOWN_TYPE,
	BOOLEAN_TYPE,
	STRING_TYPE,
	NUMERIC_TYPE,
	DATETIME_TYPE,
	TIMESPAN_TYPE,
	GEOMETRIC_TYPE,
	NETWORK_TYPE,
	USER_TYPE,
	MIXED_TYPE
} CATEGORY;


 
# 73



 
# 109


 
# 121

 
# 132


 bool IsPreferredType(CATEGORY category, Oid type);
 CATEGORY TypeCategory(Oid type);

 bool can_coerce_type(int nargs, Oid *input_typeids, Oid *func_typeids);
 Node *coerce_type(ParseState *pstate, Node *node, Oid inputTypeId,
			Oid targetTypeId, int32 atttypmod);
 Node *coerce_type_typmod(ParseState *pstate, Node *node,
				   Oid targetTypeId, int32 atttypmod);

# 1 "../../include/parser/parserinfo.h"
 
# 16

# 1 "../../include/nodes/pg_list.h"
 
# 18 "../../include/parser/parserinfo.h"

typedef struct ParserInfo {
 
	char* 			yytext;

	int 			yyleng;
	int 			yy_start;
	int 			yy_init;
	char 			yy_hold_char;
	int 			yy_n_chars;
	void*			yy_current_buffer;
	char*			yy_c_buf_p;
	int				yyline;
	
	List* 			parsetree;
	char* 			parseString;
	char* 			parseCh;

	char*			literalbuf;		
	int				literallen;		
	int				literalalloc;	

	int				xcdepth;
 
	int				yy_did_buffer_switch_on_eof;
	char*			yy_last_accepting_cpos;
	int				yy_last_accepting_state;

	bool 			QueryIsRule;
     
	char 			saved_relname[ 64 ];      
	
        Oid*			param_type_info;
	int			pfunc_num_args;
	char**			pfunc_names;

 
	char 			Int_yy_hold_char;
        char* 			Int_yytext;
	int 			Int_yyleng;
	int 			Int_yy_start;
	int 			Int_yy_init;
	int 			Int_yy_n_chars;
	void* 			Int_yy_current_buffer;
	char* 			Int_yy_c_buf_p;
	int 			Int_yyline;
 
	int				Int_yy_did_buffer_switch_on_eof;
	char*                           Int_yy_last_accepting_cpos;
	int				Int_yy_last_accepting_state;
} ParserInfo;

 ParserInfo* GetParserInfo(void);
 ParserInfo* CaptureParserInfo(void);


# 60 "WeaverConnection.c"

 

static long WDisposeConnection( OpaqueWConn conn );

static int      FillExecArgs(WConn connection);
static int      FreeExecArgs(PreparedPlan * plan);
static PreparedPlan *PreparePlan(char *statement, Oid * targs, char **lineup, int nargs);
 
# 73

# 75

# 93
    
extern OpaqueWConn 
WCreateConnection(const char *tName, const char *pass, const char *conn)
{
	int             sqlError = 0;
	long            opCode;
	char            dbpath[512];
	Oid             dbid =  0 ;
	WConn          connection =  0L ;
        
        if ( !isinitialized() ) return  0L ;
        
        connection =  base_mem_alloc ( sizeof ( struct Connection ) );
	memset(connection, 0x00, sizeof(struct Connection));
        
	connection->validFlag = -1;
	strncpy(connection->password, pass, 255);
	strncpy(connection->name, tName, 255);
	strncpy(connection->connect, conn, 255);

	connection->env = CreateEnv( 0L );
	if (connection->env ==  0L ) {
		sqlError = 99;
		strncpy(connection->env->errortext, "unsuccessful connection -- too many connections", 255);
		strncpy(connection->env->state, "DISCONNECTED", 39);
		WHandleError(connection, sqlError);
                 base_mem_free ( connection );
		return  0L ;
	}
        
        SetEnv(connection->env);

	connection->env->Mode = InitProcessing;
	connection->nargs = 0;

	MemoryContextInit();

	SetDatabaseName(conn);
	GetRawDatabaseInfo(conn, &dbid, dbpath);

	if (dbid ==  0 ) {
            sqlError = 99;
            strncpy(connection->env->errortext, "unsuccessful connection -- too many connections", 255);
            strncpy(connection->env->state, "DISCONNECTED", 39);
 
            SetEnv( 0L );
            DestroyEnv(connection->env);

            return  0L ;
        } else {
            connection->env->DatabaseId = dbid;
        }

	 
	InitThread(NORMAL_THREAD);
	RelationInitialize();
	InitCatalogCache();

	CallableInitInvalidationState();

	connection->env->Mode = NormalProcessing;

	 
	if ( dbid !=  0 ) {
		short           winner =  ( ( bool ) 0 );
		HeapTuple       ht =  0L ;
		char            isNull =  ( ( bool ) 1 );

		ht = SearchSysCacheTuple( 24 ,  ( ( Datum ) ( tName ) ), 0, 0, 0);
		if ( ( ( void * ) ( ht ) != 0L )) {
			Datum           dpass = SysCacheGetAttr( 24 , ht,  7 , &isNull);
			if (!isNull) {
				char            cpass[256];
				memset(cpass, 0, 256);
				strncpy(cpass, (char *)  ( ( Pointer ) ( dpass + 4 ) ), (*(int *) dpass) - 4);
				winner = (strcmp(pass, cpass) == 0);
				if (!winner) {
					strncpy(connection->env->errortext, "user password does not match", 255);
					sqlError = 1702;
				}
			} else {
				winner =  ( ( bool ) 1 );
			}
		} else {
			sqlError = 1703;
			strncpy(connection->env->errortext, "user does not exist", 255);
			winner =  ( ( bool ) 0 );
		}

	}

	connection->stage = STMT_INVALID;

	if (sqlError == 0) {
		connection->validFlag = 1;
		strncpy(connection->env->errortext, "successful connection", 255);
		strncpy(connection->env->state, "CONNECTED", 39);

		SetPgUserName(connection->name);
		SetUserId();
                pthread_mutex_init(&connection->child_lock,  0L );
                connection->parent =  0L ;
	} else {
		connection->validFlag = 0;
		strncpy(connection->env->state, "DISCONNECTED", 39);
		strncpy(connection->env->errortext, "connection failed", 255);
                WHandleError((OpaqueWConn) connection, sqlError);
	}
        
        SetEnv( 0L );
        
        return (OpaqueWConn) connection;
}

OpaqueWConn
WCreateSubConnection(OpaqueWConn parent)  {
	int             sqlError = 0;
	long            opCode;
        WConn          connection =  0L ;

        if ( parent->parent !=  0L ) {
		sqlError = 99;
		strncpy(parent->env->errortext, "a sub-connection cannot spawn children", 255);
		strncpy(parent->env->state, "DISCONNECTED", 39);
		WHandleError(parent, sqlError);
		return connection;
        }
   
        connection = MemoryContextAlloc(parent->env->global_context,sizeof(struct Connection));
        memmove(connection,parent,sizeof(struct Connection));

	connection->env = CreateEnv(parent->env);
	if (connection->env ==  0L ) {
		sqlError = 99;
		strncpy(connection->env->errortext, "unsuccessful connection -- too many connections", 255);
		strncpy(connection->env->state, "DISCONNECTED", 39);
		WHandleError(connection, sqlError);
		return connection;
	}
	SetEnv(connection->env);

	connection->env->Mode = InitProcessing;
	connection->nargs = 0;
        
        connection->env->DatabaseId = parent->env->DatabaseId;
        connection->env->DatabaseName = parent->env->DatabaseName;
        connection->env->DatabasePath = parent->env->DatabasePath;
  	connection->env->UserName = parent->env->UserName;
	connection->env->UserId = parent->env->UserId;

	MemoryContextInit();
	InitThread(NORMAL_THREAD);

	RelationInitialize();
	InitCatalogCache();

	CallableInitInvalidationState();
	connection->env->Mode = NormalProcessing;
	connection->stage = STMT_INVALID;
        
        pthread_mutex_lock(&parent->child_lock);
        connection->parent = parent;
        connection->child_count++;
        pthread_mutex_unlock(&parent->child_lock);

        SetEnv( 0L );
       
        return (OpaqueWConn) connection;
}

extern long 
WDestroyConnection(OpaqueWConn conn)
{
	int             status = 0;
        WConn     parent = conn->parent;

        if ( parent ) {
            int x = 0; 
            int land = 0;
            pthread_mutex_lock(&parent->child_lock);
            parent->child_count--;
            pthread_mutex_unlock(&parent->child_lock);
        } else {
            pthread_mutex_lock(&conn->child_lock);
            while ( conn->child_count > 0 ) {
                pthread_t  waitfor = 0;
                void*       result;
                pthread_mutex_unlock(&conn->child_lock);
                waitfor = FindChildThread(conn->env);
                if ( waitfor != 0 ) pthread_join(waitfor,&result);
                pthread_mutex_lock(&conn->child_lock);
            }
            pthread_mutex_unlock(&conn->child_lock);
        }
        
        if (conn->validFlag >= 0)
            WDisposeConnection(conn);
	if (conn->env !=  0L ) {
            DestroyEnv(conn->env);
            conn->env =  0L ;
	}

        if ( !parent ) 
             base_mem_free ( conn );
        else 
            pfree(conn);
}

extern long 
WBegin(OpaqueWConn conn, long trans)
{
    WConn connection =  ( WConn ) connection ;;
    
     int sqlError = 0 ; SetEnv ( connection -> env ) ; sqlError = setjmp ( connection -> env -> errorContext ) ; if ( sqlError != 0 ) { connection -> abortonly = 1 ; WHandleError ( connection , sqlError ) ; } else { connection -> CDA . rc = 0 ;
        
    if (connection->stage != STMT_INVALID) {
            elog( ( - 1 ), "already in transaction %d", connection->stage);
    }
    connection->abortonly = 0;

    connection->plan =  0L ;
    connection->stage = STMT_INVALID;
 
    if ( connection->parent ==  0L ) {
        StartTransaction();
        SetQuerySnapshot();
    } else {
        if ( connection->parent->stage == STMT_INVALID ) {
            elog( ( - 1 ), "parent transaction is not in a transaction");
        } else {
            pthread_mutex_lock(&connection->parent->child_lock);
            connection->parent->child_trans++;
            pthread_mutex_unlock(&connection->parent->child_lock);
            CloneParentTransaction();
        }
    }

    connection->transaction_owner = pthread_self();
    connection->stage = STMT_NEW;
    
    RELEASE(connection)
}

extern long 
WParsingFunc(OpaqueWConn conn, const char *smt)
{
	WConn          connection =  ( WConn ) connection ;;
	List           *querytree_list =  0L ;
	List           *plantree_list =  0L ;
	int             c = 0;

	if (ReadyConnection(connection)) {
            int stmtlen = strlen(smt);

            if ( CheckForCancel() ) {
                elog( ( - 1 ),"Query Cancelled");
            }

             
            if (connection->stage == STMT_INVALID) {
                    elog( ( - 1 ), "transaction not begun");
            }
            if ( !pthread_equal(connection->transaction_owner,pthread_self()) ) {
                elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
            }
            if ( stmtlen > 8191 ) {
                elog( ( - 1 ), "parsed statement too long");
            }

            WResetQuery(connection);
		
            memmove(connection->statement, smt, stmtlen+1);

            connection->stage = STMT_PARSED;

            connection->plan =  0L ;
            memset(connection->input, 0, sizeof(Binder) *  32 );
            memset(connection->lineup, 0, sizeof(char *) *  32 );
            memset(connection->targs, 0, sizeof(Oid) *  32 );
            connection->nargs = 0;

            connection->cursor = -1;
            connection->processed = -1;
	}
    
	return  } SetEnv ( 0L ) ; return sqlError ;;
}


extern long 
WOutputLinkInd(OpaqueWConn conn, short pos, void *varAdd, int varSize, int varType, short *ind, int *clength)
{
	WConn          connection =  ( WConn ) connection ;;

	if (ReadyConnection(connection)) {
            if ( CheckForCancel() ) {
                elog( ( - 1 ),"Query Cancelled");
            }
                
            if (pos >  32 || pos <= 0) {
                    coded_elog( ( - 1 ),101,"bad value - index must be greater than 0 and less than %d",  32 );
            } else {
                if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                    elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
                }
                connection->output[pos - 1].index = pos;
                connection->output[pos - 1].target = varAdd;
                connection->output[pos - 1].size = varSize;
                connection->output[pos - 1].type = varType;
                connection->output[pos - 1].isNull = ind;
                connection->output[pos - 1].length = clength;
            }
	}
    
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WExec(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;

	List           *trackquery =  0L ;
	List           *trackplan =  0L ;

	Plan           *plantree =  0L ;
	Query          *querytree =  0L ;
	int             sqlError = 0;
	short           isLast =  1 ;
	Const           tcount_const;
	Node           *count =  0L ;

    if (ReadyConnection(connection)) {
		PreparedPlan   *plan =  0L ;

                if ( CheckForCancel() ) {
                    elog( ( - 1 ),"Query Cancelled");
                }
                if (connection->stage == STMT_INVALID) {
			elog( ( - 1 ), "no statement parsed");
		}
                if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                    elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
                }
		if (connection->plan ==  0L ) {
			connection->plan = PreparePlan(connection->statement, connection->targs, connection->lineup, connection->nargs);
		}
		plan = connection->plan;

		trackquery = plan->querytreelist;
		trackplan = plan->plantreelist;


		while (trackquery) {
			 
# 451
			CommandCounterIncrement();

			querytree = (Query *)  ( ( trackquery ) -> elem . ptr_value );
			trackquery =  ( ( trackquery ) -> next );

			plantree = (Plan *)  ( ( trackplan ) -> elem . ptr_value );
			trackplan =  ( ( trackplan ) -> next );

			SetQuerySnapshot();

			WResetExecutor(connection->plan);

			if (querytree->commandType == CMD_UTILITY) {
				ProcessUtility(querytree->utilityStmt, None);
				 
# 469
			} else {
				plan->state = CreateExecutorState();

				if (connection->nargs > 0) {
					FillExecArgs(connection);
				} else {
					plan->state->es_param_list_info =  0L ;
				}

				plan->qdesc = CreateQueryDesc(querytree, plantree, None);

				plan->tupdesc = ExecutorStart(plan->qdesc, plan->state);
				plan->state->es_processed = 0;
				plan->state->es_lastoid =  0 ;

				if (plan->qdesc->operation != CMD_SELECT) {
					TupleTableSlot *slot =  0L ;

					ItemPointerData tuple_ctid;
					int             delete_count = 0;

					do {
						slot = ExecProcNode(plan->qdesc->plantree);
						if ( ( ( slot ) == 0L || ( slot ) -> val == 0L ))
							break;

						tuple_ctid = slot->val->t_self;

						switch (plan->qdesc->operation) {
                                case CMD_INSERT:
                                        slot->val->t_data->t_oid = GetGenId();
                                        ExecAppend(slot,  0L , plan->state);
                                        break;
                                case CMD_DELETE:
                                        ExecDelete(slot, &tuple_ctid, plan->state);
                                        delete_count++;
                                        break;
                                case CMD_UPDATE:
                                        ExecReplace(slot, &tuple_ctid, plan->state);
                                        delete_count++;
                                        break;
                                default:
                                        elog( ( - 2 ), "ExecutePlan: unknown operation in queryDesc");
                                        break;
						}
					} while ( ( ( bool ) 1 ));

                    if ( CheckForCancel() ) {
                        elog( ( - 1 ),"Query Cancelled");
                    }
				}
			}
		}
	}
	connection->stage = STMT_EXEC;
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WFetch(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
	PreparedPlan   *plan = connection->plan;
        
	if (ReadyConnection(connection)) {
		int             pos = 0;

		long            check;
		unsigned long   rows;
		unsigned short  stats;

                if ( CheckForCancel() ) {
                    elog( ( - 1 ),"Query Cancelled");
                }
                if (connection->stage != STMT_EXEC && connection->stage != STMT_FETCH) {
                                elog( ( - 1 ), "no statement executed");
                        }
                if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                    elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
                }
                if (connection->CDA.rc == 1403) {
             
                    coded_elog( ( - 1 ),1405,"fetch past end of cursor");
		}
		MemoryContext   parent = MemoryContextGetCurrentContext();
                if ( plan->fetch_cxt ==  0L ) {
                    plan->fetch_cxt = AllocSetContextCreate(parent,
                         "FetchContext",
                    ( 8 * 1024 ),
                        (32 * 1024),
                   ( 8 * 1024 * 1024 ));
                }
		MemoryContextSwitchTo(plan->fetch_cxt);

		TupleTableSlot *slot = ExecProcNode(plan->qdesc->plantree);
                
		if ( ( ( slot ) == 0L || ( slot ) -> val == 0L )) {
			coded_elog( ( - 1 ),1403,"no more data");
		} else {
			HeapTuple       tuple = slot->val;
			TupleDesc       tdesc = slot->ttc_tupleDescriptor;

			while (connection->output[pos].index != 0 && pos <=  32 ) {
                                Datum       val = (Datum)  0L ;
                                char            isnull = 0;
                                
				if (tuple->t_data->t_natts < connection->output[pos].index || connection->output[pos].index <= 0) {
                                    coded_elog( ( - 1 ),104,"no attribute");
				}
                                if (tuple->t_data->t_natts < pos || pos < 0) {
                                    coded_elog( ( - 1 ),107,"wrong number of attributes");
                                }

				val = HeapGetAttr(tuple, connection->output[pos].index, tdesc, &isnull);

				if (!isnull) {
                                    if ( !TransferValue(&connection->output[pos],tdesc->attrs[pos],val) ) {
                                 
                                        if (can_coerce_type(1, &tdesc->attrs[pos]->atttypid, &connection->output[pos].type)) {
                                                coded_elog( ( - 1 ),105,"Types are compatible but conversion not implemented link type: %d result type: %d",
                                                         connection->output[pos].type, tdesc->attrs[pos]->atttypid);
                                                break;
                                        } else {
                                                coded_elog( ( - 1 ),106,"Types do not match, no type conversion . position: %d type: %d result type: %d",
                                                        pos + 1, connection->output[pos].type, tdesc->attrs[pos]->atttypid);
                                                break;
                                        }
                                    }
                                    *connection->output[pos].isNull = 0;   
                                } else {
                                    *connection->output[pos].isNull = 1;   
                                }
				pos++;
			}
                        ExecClearTuple(slot);
			plan->state->es_processed++;
		}
                
               MemoryContextSwitchTo(parent);
# 611
               MemoryContextResetAndDeleteChildren(plan->fetch_cxt);
	}
	connection->stage = STMT_FETCH;
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WPrepare(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
	if ( ReadyConnection(connection) ) {
        if ( CheckForCancel() ) {
            elog( ( - 1 ),"Query Cancelled");
        }
        if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
            elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
        }
	}
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WCommit(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;

	if (ReadyConnection(connection) ) {
            if ( connection->stage == STMT_INVALID ) {
                elog( ( - 1 ),"connection is currently in an invalid state for commit");
            }
            if ( CheckForCancel() ) {
                elog( ( - 1 ),"Query Cancelled");
            }
            if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
            }
            connection->stage = STMT_COMMIT;
             
            if (connection->abortonly) {
                if (CurrentXactInProgress()) {
                    WResetQuery(connection);
                    AbortTransaction();
                }
                elog( ( - 1 ), "transaction in abort only mode");
            } else {
                WResetQuery(connection);
                if ( connection->parent ==  0L ) {
                    CommitTransaction();
                } else {
                    CloseSubTransaction();
                }
            }
	}
	connection->stage = STMT_INVALID;
	connection->plan =  0L ;
    connection->transaction_owner = 0;
    return  } SetEnv ( 0L ) ; return sqlError ;;
}


extern long 
WRollback(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
    if ( ReadyConnection(connection) ) {
            if ( connection->stage == STMT_INVALID ) {
                elog( ( - 1 ),"connection is currently in an invalid state for commit");
            }
            if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
            }
            if ( CurrentXactInProgress() ) {
                WResetQuery(connection);
                if ( connection->parent ==  0L ) {
                    AbortTransaction();
                } else {
                    CloseSubTransaction();
                }
            }
            connection->stage = STMT_ABORT;
             
# 694
	}

    connection->transaction_owner = 0;
	connection->stage = STMT_INVALID;
	connection->plan =  0L ;
    return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WBindWithIndicate(OpaqueWConn conn, const char *var, void *varAdd, int varSize, short *indAdd, int varType, int cType)
{
	WConn          connection =  ( WConn ) connection ;;
    if ( ReadyConnection(connection) ) {
		int             index = 0;
            if ( CheckForCancel() ) {
                elog( ( - 1 ),"Query Cancelled");
            }
            if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
                elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
            }

             
            for (index = 0; index <  32 ; index++) {
                    if (connection->input[index].index == 0 || strcmp(var, connection->input[index].name) == 0)
                            break;
            }

            if (index >=  32 ) {
                    coded_elog( ( - 1 ),105, "too many bind values, max is %d",  32 );
            }
            connection->input[index].index = index + 1;
            strncpy(connection->input[index].name, var, 255);
            connection->input[index].varSize = varSize;
            connection->input[index].type = varType;
            connection->input[index].ctype = cType;
            connection->input[index].target = varAdd;
            connection->input[index].isNotNull = indAdd;

            connection->lineup[index] = connection->input[index].name;
            connection->targs[index] = connection->input[index].type;

            if (index + 1 > connection->nargs)
                    connection->nargs = index + 1;
	}
    return  } SetEnv ( 0L ) ; return sqlError ;;
}


extern long 
WCancel(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	int             sqlError = 0;
	
	connection->env->cancelled =  ( ( bool ) 1 );

	return sqlError;
}

static long 
WDisposeConnection(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	int             sqlError = 0;

	if (connection->env ==  0L )
		return sqlError;
	SetEnv(connection->env);
	if (setjmp(connection->env->errorContext) == 0) {
            if (connection->validFlag == 1 && CurrentXactInProgress()) {
                WResetQuery(connection);
                if ( connection->parent !=  0L ) {
                    CloseSubTransaction();
                } else {
                    AbortTransaction();
                }
            }
        }
	FreeXactSnapshot();
	DropNoNameRels();

	if (setjmp(connection->env->errorContext) == 0) {
		MasterUnLock();
		TransactionUnlock();
	}
# 780
        if (setjmp(connection->env->errorContext) == 0) {
            if ( BufferPoolCheckLeak() ) {
                elog( 0 ,"Buffer leak in dispose connection");
                ResetBufferPool( ( ( bool ) 0 ));
            }
        }
# 787
	if (setjmp(connection->env->errorContext) == 0)
		ShutdownDolHelpers();
	if (setjmp(connection->env->errorContext) == 0)
		remove_all_temp_relations();
	if (setjmp(connection->env->errorContext) == 0)
		CallableCleanupInvalidationState();
	if (setjmp(connection->env->errorContext) == 0)
		RelationCacheShutdown();
	if (setjmp(connection->env->errorContext) == 0)
		ThreadReleaseLocks( ( ( bool ) 0 ));
	if (setjmp(connection->env->errorContext) == 0)
		ThreadReleaseSpins(GetMyThread());
	if (setjmp(connection->env->errorContext) == 0)
		MemoryContextDestroyEnv();
	if (setjmp(connection->env->errorContext) == 0)
		DestroyThread();

	connection->validFlag = -1;
	SetEnv( 0L );
        return sqlError;
}

extern long 
WGetTransactionId(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
    long            xid = -1;
             
	if ( ReadyConnection(connection) ) {
        if ( CheckForCancel() ) {
            elog( ( - 1 ),"Query Cancelled");
        }
        if (connection->stage == STMT_INVALID) {
            elog( ( - 1 ), "transaction not begun");
        }
        if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
            elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
        }
        
        xid = GetCurrentTransactionId();
    }
     } SetEnv ( 0L ) ; return sqlError ;;
    
    return xid;
}

extern long 
WBeginProcedure(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
             
	if ( ReadyConnection(connection) ) {
        if ( CheckForCancel() ) {
            elog( ( - 1 ),"Query Cancelled");
        }
        if (connection->stage == STMT_INVALID) {
            elog( ( - 1 ), "transaction not begun");
        }
        if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
            elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
        }
        
        TakeUserSnapshot();
    }
    return  } SetEnv ( 0L ) ; return sqlError ;;
}


extern long 
WEndProcedure(OpaqueWConn conn)
{
	WConn          connection =  ( WConn ) connection ;;
             
	if ( ReadyConnection(connection) ) {
        if ( CheckForCancel() ) {
            elog( ( - 1 ),"Query Cancelled");
        }
        if (connection->stage == STMT_INVALID) {
            elog( ( - 1 ), "transaction not begun");
        }
        if ( !pthread_equal(connection->transaction_owner,pthread_self() ) ) {
            elog( ( - 1 ),"transaction is owned by thread %d, cannot make call from this context",connection->transaction_owner);
        }
        
        DropUserSnapshot();
    }
    return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WUserLock(OpaqueWConn conn, const char *group, uint32_t val, char lockit)
{
	WConn          connection =  ( WConn ) connection ;;
	Oid             grouplockid = (Oid) - 3;

	if (ReadyConnection(connection) ) {
		char           *trax;
		char            gname[256];
		Relation        rel;

        if ( CheckForCancel() ) {
            elog( ( - 1 ),"query cancelled");
        }
		memset(gname, 0x00, 255);

		trax = gname;
		while (*group != 0x00) {
			*trax++ = tolower(*group++);
		}
		*trax++ = '/';
		strcpy(trax, "ownerinfo");

		rel = RelationNameGetRelation(gname, GetDatabaseId());
		if (rel !=  0L ) {
			grouplockid = rel->rd_id;
			 ( ( ( void ) ( ( bool ) ( ( ! assert_enabled ) || ! ( ! ( ( rel ) -> rd_refcnt > 0 ) ) || ( ExceptionalCondition ( "!((rel)->rd_refcnt > 0)" , & ( FailedAssertion ) , ( char * ) 0L , "WeaverConnection.c" , 902 ) ) ) ) ) , ( rel ) -> rd_refcnt -= 1 );
		} else {
			strncpy(connection->env->state, "USER", 39);
			coded_elog( ( - 1 ),502,"user unlock failed -- no relation");
		}

		if (grouplockid == -3) {
                     } SetEnv ( 0L ) ; return sqlError ;;
                    return grouplockid;
		} else {
                        int lockstate   = 0;
			LOCKTAG         tag;
			memset(&tag, 0, sizeof(tag));

			tag.relId = grouplockid;
			tag.dbId = GetDatabaseId();
			tag.objId.blkno = (BlockNumber) val;
			if (lockit) {
				TransactionId   xid = 0;
				if (LockAcquire( 3 , &tag, xid,  7 ,  ( ( bool ) 1 ))) {
					lockstate = 0;
				} else {
					lockstate = 1;
				}
				elog( ( - 2 ), "user lock on group:%s item:%d result:%d", gname, val, lockstate);
			} else {
				TransactionId   xid = 0;

				if (LockRelease( 3 , &tag, xid,  7 )) {
					lockstate = 0;
				} else {
					strncpy(connection->env->state, "USER", 39);
					coded_elog( ( - 1 ),501,"user unlock failed");
				}
				elog( ( - 2 ), "user unlock on group:%s item:%d result:%d", gname, val, lockstate);
			}
		}
	}
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern long 
WIsValidConnection(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	if (connection->validFlag > 0) {
		return 1;
	}
	return 0;
}

extern long 
WGetErrorCode(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	if (connection ==  0L )
		return -99;
	return connection->CDA.rc;
}

extern const char *
WGetErrorText(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	if (connection ==  0L )
		return "no connection";
	return connection->CDA.text;
}

extern const char *
WGetErrorState(OpaqueWConn conn)
{
	WConn          connection = (WConn) conn;
	if (connection ==  0L )
		return "DISCONNECTED";
	return connection->CDA.state;
}

extern long 
WStreamExec(OpaqueWConn conn, char *statement)
{
	WConn          connection =  ( WConn ) connection ;;
	bool            IsEmptyQuery =  ( ( bool ) 0 );
    
    if ( ReadyConnection(connection) ) {
        if ( CheckForCancel() ) {
            elog( ( - 1 ),"query cancelled");
        }
    
		SetWhereToSendOutput(Remote);
		StartTransactionCommand();
		connection->stage = STMT_EXEC;
		pg_exec_query_dest((char *) statement, Remote,  ( ( bool ) 0 ));
		CommitTransactionCommand();
		WResetQuery(connection);
		connection->stage = STMT_INVALID;
    }
	return  } SetEnv ( 0L ) ; return sqlError ;;
}

extern Pipe WPipeConnect(OpaqueWConn conn, int pipeid, int sid, int size, pipefunc func)
{
    WConn connection =  ( WConn ) connection ;;
    CommBuffer *pipe =  0L ;
    
    if ( sid == 0 ) {
            StdComm* std = MemoryContextAlloc(MemoryContextGetTopContext(),sizeof(StdComm));
            GetEnv()->pipein = std;
            std->cursor.ptr = 0;
            std->cursor.end = 0;
            std->cursor.size =  8192 ;
            pipe = &std->pipe;
	} else if ( sid == 1 ) {
            StdComm* std = MemoryContextAlloc(MemoryContextGetTopContext(),sizeof(StdComm));
            GetEnv()->pipeout = std;
            std->cursor.ptr = 0;
            std->cursor.end = 0;
            std->cursor.size =  8192 ;
            pipe = &std->pipe;
    } else {
        pipe = MemoryContextAlloc(MemoryContextGetTopContext(),sizeof(CommBuffer));
    }

	pipe->pipe = func;
	pipe->streamid = sid;
	pipe->pipeid = pipeid;
    pipe->header = sizeof(CommBuffer);
	 ( ( ( struct varlena * ) ( ( bytea * ) pipe ) ) -> vl_len |= 0x40000000 );
    
     } SetEnv ( 0L ) ; return sqlError ;;
	
    return pipe;
}

extern long 
WPipeDisconnect(OpaqueWConn conn, Pipe pipe)
{

	WConn          connection =  ( WConn ) connection ;;

    if (ReadyConnection(connection) ) {
        Env* env = GetEnv();
        if ( pipe == env->pipein || env->pipeout == env->pipeout ) {
            StdComm* comm = (StdComm*)pipe;
            if (comm->cursor.ptr < comm->cursor.end) {
                if ( comm->pipe.pipe(comm->pipe.pipeid, comm->pipe.streamid, comm->cursor.buffer, comm->cursor.ptr, comm->cursor.end - comm->cursor.ptr) == - 2 ) {
                    elog( ( - 1 ),"piping error occurred");
                }
            }
            if ( comm->pipe.streamid == 0 ) {
                    env->pipein =  0L ;
            } else if ( comm->pipe.streamid == 1 ) {
                    env->pipeout =  0L ;
            }
        }
    }
	pfree(pipe);
    return  } SetEnv ( 0L ) ; return sqlError ;;
}


extern int 
WPipeSize(OpaqueWConn conn)
{

	return sizeof(CommBuffer);
}

void 
WHandleError(WConn connection, int sqlError)
{
        if ( connection ==  0L ) {
            return;
        }

        if ( connection->env ==  0L ) {
            return;
        }

	memset(connection->CDA.state, '\0', 40);
	memset(connection->CDA.text, '\0', 256);
	connection->CDA.rc = sqlError;

	if (sqlError) {
            strncpy(connection->CDA.text, connection->env->errortext, 255);
            strncpy(connection->CDA.state, connection->env->state, 39);
	}
        
        clearerror(connection->env);
	 
	 
# 1095
}

void 
WResetQuery(WConn connection)
{
	int size = 0;
 
# 1103
        if (connection->plan !=  0L )
		WResetExecutor(connection->plan);

	MemoryContextSwitchTo(MemoryContextGetEnv()->QueryContext);
# 1111
	MemoryContextResetAndDeleteChildren(MemoryContextGetEnv()->QueryContext);
	memset(connection->output, 0, sizeof(Output) *  32 );
	memset(connection->statement, '\0', 8192);

	connection->plan =  0L ;
}

void 
WResetExecutor(PreparedPlan * plan)
{
        if (plan->qdesc !=  0L ) {
            ExecutorEnd(plan->qdesc, plan->state);
        }

	MemoryContextSwitchTo(plan->exec_cxt);
# 1129
	MemoryContextResetAndDeleteChildren(plan->exec_cxt);

	plan->qdesc =  0L ;
	plan->state =  0L ;
        plan->fetch_cxt =  0L ;
}

 
static int 
FillExecArgs(WConn connection)
{
	int             k = 0;
	PreparedPlan   *plan = connection->plan;
	MemoryContext   old =  0L ;
	ParamListInfo   paramLI;

	 do { if ( ( assert_enabled ) && ( ! ( plan != 0L ) ) ) ExceptionalCondition ( "!(plan != 0L)" , & ( FailedAssertion ) , ( char * ) 0L , "WeaverConnection.c" , 1145 ) ; } while ( 0 );

	plan->bindcontext = SubSetContextCreate(MemoryContextGetCurrentContext(),"StatementArgumentContext");
	old = MemoryContextSwitchTo(plan->bindcontext);

	paramLI = (ParamListInfo)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( ( connection -> nargs + 1 ) * sizeof ( ParamListInfoData ) ) ) ;
# 1152

	plan->state->es_param_list_info = paramLI;
	for (k = 0; k < connection->nargs; k++) {
		paramLI->kind =  11 ;
		paramLI->name = connection->input[k].name;
		paramLI->id = connection->input[k].index;
		paramLI->type = connection->input[k].type;
		paramLI->isnull = !(*connection->input[k].isNotNull);
                
                if ( *connection->input[k].isNotNull < 0 ) {
                    elog( ( - 1 ),"bound variable %s has not been set",paramLI->name);
                }
		if ( paramLI->isnull ) {
			paramLI->length = 0;
			continue;
		}
		switch (connection->input[k].ctype) {
                    case  18 :
                            paramLI->length = 1;
                            paramLI->value = *(char *) connection->input[k].target;
                            break;
                    case  16 :
                            paramLI->length = 1;
                            paramLI->value = *(char *) connection->input[k].target;
                            break;
                    case  23 :
                            paramLI->length = 4;
                            paramLI->value = *(int *) connection->input[k].target;
                            break;
                    case  1184 :
                            paramLI->length = 8;
                            paramLI->value = (Datum)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( connection -> input [ k ] . varSize ) );
                            memcpy((char *) paramLI->value, connection->input[k].target, connection->input[k].varSize);
                            break;
                     case  701 :
                            paramLI->length = 8;
                            paramLI->value = (Datum)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( connection -> input [ k ] . varSize ) );
                            memcpy((char *) paramLI->value, connection->input[k].target, connection->input[k].varSize);
                            break;
                    case  20 :
                            paramLI->length = 8;
                            paramLI->value = (Datum)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( connection -> input [ k ] . varSize ) );
                            memcpy((char *) paramLI->value, connection->input[k].target, connection->input[k].varSize);
                            break;	
                    case  1834 :
                            paramLI->value = (Datum)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( connection -> input [ k ] . varSize ) );
                            memcpy((char *) paramLI->value, connection->input[k].target, connection->input[k].varSize);
                            paramLI->length = (Size)(-1); 	
                            break;
                    case  1043 :
                    case  25 :
                    case  1803 :
                    case  1830 :
                    default:
                            if (*(int *) connection->input[k].target > connection->input[k].varSize) {
                                    strncpy(connection->env->errortext, "binary truncation on input", 255);
                                    longjmp(connection->env->errorContext, 103);
                            }
                             
# 1214
                             
# 1218
                            paramLI->value = (Datum)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( connection -> input [ k ] . varSize + 4 ) );
                            memcpy((char *) paramLI->value, connection->input[k].target, connection->input[k].varSize + 4);
                            paramLI->length = (Size)(-1); 	 
# 1222
                            break;
		}
		paramLI++;

	}
	paramLI->kind =  100 ;
	MemoryContextSwitchTo(old);
}

 
static int 
FreeExecArgs(PreparedPlan * plan)
{

	if (plan->bindcontext) {
		MemoryContextDelete(plan->bindcontext);
		plan->bindcontext =  0L ;
	} else {
		printf("argument memory context error\n");
		return 8;
	}
	return 0;
}

static PreparedPlan *
PreparePlan(char *statement, Oid * targs, char **lineup, int nargs)
{
	List           *querytree_list =  0L ;
	List           *plantree_list =  0L ;
	Plan           *plantree =  0L ;
	Query          *querytree =  0L ;


	PreparedPlan   *plan = (PreparedPlan *)  MemoryContextAlloc ( MemoryContextGetCurrentContext ( ) , ( sizeof ( PreparedPlan ) ) );

	 
	 

	querytree_list = pg_parse_and_rewrite(statement, targs, lineup, nargs,  0 );
	if (!querytree_list) {
		elog( ( - 1 ), "parsing error");
	}
	 
# 1268

	plan->querytreelist = querytree_list;

	querytree =  ( ( querytree_list ) -> elem . ptr_value );
	while (querytree_list) {
		plantree = pg_plan_query(querytree);
		plantree_list = lappend(plantree_list, plantree);
		querytree_list =  ( ( querytree_list ) -> next );
	}

	plan->plantreelist = plantree_list;
	 

	plan->tupdesc =  0L ;
	plan->state =  0L ;
	plan->qdesc =  0L ;

	plan->exec_cxt = AllocSetContextCreate(MemoryContextGetCurrentContext(),
					       "ExecutorContext",
					        ( 8 * 1024 ),
					        ( 8 * 1024 ),
					        ( 8 * 1024 * 1024 ));
 	plan->bindcontext =  0L ;
        plan->fetch_cxt =  0L ;

	return plan;
}

 
#ident "acomp: Sun Ceres C 5.10 SunOS_sparc 2008/01/28"

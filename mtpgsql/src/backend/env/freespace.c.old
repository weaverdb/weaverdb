#include <pthread.h>
#include <sys/types.h>
#include <signal.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/sdt.h>

#include "c.h"
#include "postgres.h"

#include "env/env.h"
#include "env/freespace.h"
#include "access/blobstorage.h"
#include "env/poolsweep.h"
#include "env/dbwriter.h"
#include "access/genam.h"
#include "access/heapam.h"
#include "catalog/pg_extent.h"
#include "catalog/indexing.h"
#include "catalog/catalog.h"

#include "config.h"
#include "miscadmin.h"
#include "utils/rel.h"
#include "utils/relcache.h"
#include "utils/memutils.h"
#include "storage/smgr.h"
#include "storage/buffile.h"


static HTAB*  				freetable;
static pthread_mutex_t                  freespace_access;
static bool					inited = false;
static bool					print_freespace_memory = false;
static MemoryContext		free_cxt;

#define DEFAULT_MINLIVE  (BLCKSZ / 10)  /*  default if the available space is only 10% don't bother checking anymore */

typedef struct freekey {
	Oid		 relid;
	Oid		 dbid;
} FreeKey;

typedef struct freespace {
    FreeKey				key;
    char				relkind;
    long 				queuesize;
    long 				pointer;
    long                                run;
    long                                cycles;
    int                                min_request;
    int                                max_request;
    int                                 extent;
    bool                                 extent_percentage;
    BlockNumber                         relsize;
    double 				last_live_tuple_count;
    double				last_dead_tuple_count;
    Size				min_tuple_size;
    Size 				max_tuple_size;
    Size				ave_tuple_size;
    Size				total_available;
    bool				active;
    bool				extension_requested;
    bool*				live;
    BlockNumber*                        tryblock;
    Size*				avail;
    int*				misses;
    int*				unused_pointers;
    pthread_cond_t                      creator;
    pthread_mutex_t                     accessor;
    pthread_mutex_t                     sizer;
    pthread_t                           extender;
    MemoryContext                       context;
} FreeSpace;


static void* FreespaceAlloc(Size size,void* cxt);
static void FreespaceFree(void* pointer,void* cxt);
static FreeSpace* FindFreespace(Relation rel,char* dbname,bool create);
static int AllocatePagesViaSmgr(Relation rel,int count);
static int RecommendAllocation(Relation rel,FreeSpace* space);
static BlockNumber PerformAllocation(Relation rel, FreeSpace* free, int size);
static bool LookupExtentForRelation(Relation rel, FreeSpace* free);
static void SetExtentForRelation(Relation rel, int count,bool percentage);
static void RemoveExtentForRelation(Relation rel);


static void* FreespaceAlloc(Size size,void* cxt)
{
    return MemoryContextAlloc(cxt,size);
}

static void FreespaceFree(void* pointer,void* cxt)
{
	pfree(pointer);
}


void
InitFreespace()
{
	HASHCTL ctl;
	HTAB* temptable;
    MemoryContext  hash_cxt,old;
	
    free_cxt = AllocSetContextCreate((MemoryContext) NULL,
                                                 "FreespaceMemoryContext",
                                                ALLOCSET_DEFAULT_MINSIZE,
                                                ALLOCSET_DEFAULT_INITSIZE,
                                                ALLOCSET_DEFAULT_MAXSIZE);
                                             
    hash_cxt = AllocSetContextCreate((MemoryContext)free_cxt,
                                                 "FreespaceHashCxt",
                                                ALLOCSET_DEFAULT_MINSIZE,
                                                ALLOCSET_DEFAULT_INITSIZE,
                                                ALLOCSET_DEFAULT_MAXSIZE);
                                             
    old = MemoryContextSwitchTo(free_cxt);
    
	memset(&ctl,0,sizeof(HASHCTL));
	ctl.keysize = sizeof(FreeKey);
	ctl.entrysize = sizeof(FreeSpace);
	ctl.hash = tag_hash;
	ctl.alloc = FreespaceAlloc;
	ctl.free = FreespaceFree;
	ctl.hcxt = hash_cxt;
	
	freetable = hash_create("freespace hash",100,&ctl,HASH_ELEM | HASH_ALLOC | HASH_FUNCTION | HASH_CONTEXT);
	
	MemoryContextSwitchTo(old);
	pthread_mutex_init(&freespace_access,&process_mutex_attr);
	inited = true;
}

double 
GetUpdateFactor(Oid relid, Oid dbid, char* relname, char* dbname, double last_value, bool * trackable)
{
        FreeKey    key;
	FreeSpace* entry;
        bool found;
		
	if ( !inited) return 100.0;

        key.relid = relid;
        key.dbid = dbid;
        
	pthread_mutex_lock(&freespace_access);

	entry = hash_search(freetable,(char*)&key,HASH_FIND,&found);
        
        pthread_mutex_unlock(&freespace_access);
        
        if ( !found ) {
                *trackable = false;
        } else {
		double stats = 1.0;
		double mellow = 1.0;
                pthread_mutex_lock(&entry->accessor);
                
                *trackable = (entry->relkind == RELKIND_RELATION);
/*  results aren't ready yet so return an negative stating don't set value */
		 if ( !entry->active ) {
			stats = -10.0;
                 } else if ( entry->relkind == RELKIND_RELATION) {
/*  start with one % of the live tuple count  */
                        stats = (entry->last_live_tuple_count * 0.01);
/*  add 10% of the dead tuple count, we want more frequent updates 
the more deletions there are  */          
                        stats += (entry->last_dead_tuple_count * 0.1);
/*  add a special factor for small tuples which we want to keep trim  */
                        stats += 100.0;
/*  divide by the total number of tuples + 1.0 to prevent divide by zero  */
                        stats /= (entry->last_live_tuple_count + 1.0); 
                        mellow = stats/last_value;
/*  prevent wild swings in the numbers   */
                          if ( last_value <= 0.0 ) {
                                        /*  max at 100% increase  */
                          } else if ( mellow > 3.0 ) {
                                stats = ( last_value * 3.0) ;
                          /*  min at 80% decrease  */
                           } else if ( mellow < 0.2 ) {
                                stats = ( last_value * 0.2 );
                          }
                          if ( stats < 0.00000001 ) stats = 1.0;
                } else {
                    stats = 0.0;
                }
               pthread_mutex_unlock(&entry->accessor);
               return stats;
       }
       return 100.0;
}

int 
RegisterFreespace(Relation rel,int space,BlockNumber* index,
		Size* sa,int* unused_pointers,Size min,Size max,Size ave,TupleCount live_count,TupleCount dead_count)
{
	FreeSpace* entry;
        int count;
	
	if ( !inited ) return -1;

	entry = FindFreespace(rel,NULL,true);

	pthread_mutex_lock(&entry->accessor);
        MemoryContextResetAndDeleteChildren(entry->context);
        
	entry->queuesize = space;
	entry->extension_requested = false;
	entry->pointer = 0;
        entry->cycles = 0;
        entry->min_request = MaxTupleSize;
        entry->max_request = MinTupleSize;
	entry->run = -1;
        entry->min_tuple_size = min;
	entry->max_tuple_size = max;
	entry->ave_tuple_size = ave;
        entry->last_live_tuple_count = live_count;
        entry->last_dead_tuple_count = dead_count;
    
	if ( space != 0 ) {
            MemoryContext old = MemoryContextSwitchTo(entry->context);

            entry->live = palloc(sizeof(bool) * space);
                memset(entry->live,0xff,sizeof(bool) * space);
            entry->tryblock = (BlockNumber*)palloc(sizeof(BlockNumber) * space);
                memcpy(entry->tryblock,index,sizeof(BlockNumber) * space);
            entry->avail = (Size*)palloc(sizeof(Size) * space);
                memcpy(entry->avail,sa,sizeof(Size) * space);
            entry->misses = (int*)palloc(sizeof(int) * space);
                memset(entry->misses,0,sizeof(int) * space);
            entry->unused_pointers = (int*)palloc(sizeof(int) * space);
                memcpy(entry->unused_pointers,unused_pointers,sizeof(int) * space);

            MemoryContextSwitchTo(old);
        } else {
            entry->live = NULL;
            entry->tryblock = NULL;
            entry->avail = NULL;
            entry->misses = NULL;
            entry->unused_pointers = NULL;
        }

        entry->total_available = 0;
        for (count = 0;count <space;count++) {
            entry->total_available += entry->avail[count];
        }

/*  new statistics available */
	entry->active = true;
	pthread_mutex_unlock(&entry->accessor);
}

int 
SetFreespacePending(Oid relid, Oid dbid) {
        FreeKey     key;
	FreeSpace* entry;
        bool found;
		
	if ( !inited) return -1;

        key.relid = relid;
        key.dbid = dbid;
        
	pthread_mutex_lock(&freespace_access);

	entry = hash_search(freetable,(char*)&key,HASH_FIND,&found);
        
        pthread_mutex_unlock(&freespace_access);

	if ( entry ) {
		pthread_mutex_lock(&entry->accessor);
		entry->active = false;
		pthread_mutex_unlock(&entry->accessor);
	}

	return 0;
}

Size GetAverageTupleSize(Relation rel) {

	FreeSpace* entry = NULL;
	
	if ( !inited ) return 0;

	entry = FindFreespace(rel,NULL,false);

	if ( entry ) return entry->ave_tuple_size;
	else return 0;
}

Size	GetMaximumTupleSize(Relation rel) {

	FreeSpace* entry = NULL;
	
	if ( !inited ) return 0;

	entry = FindFreespace(rel,NULL,false);

	if ( entry ) return entry->max_tuple_size;
	else return 0;
}

Size	GetMinimumTupleSize(Relation rel)  {

	FreeSpace* entry = NULL;
	
	if ( !inited ) return 0;

	entry = FindFreespace(rel,NULL,false);

	if ( entry ) return entry->min_tuple_size;
	else return 0;
}

void GetTupleSizes(Relation rel,Size* min,Size* max,Size* ave) {

	FreeSpace* entry;
	
	if ( !inited ) return;
	
	entry = FindFreespace(rel,NULL,true);

	if ( !entry ) {
		return;
	}

	*min = entry->min_tuple_size;
	*max = entry->max_tuple_size;
	*ave = entry->ave_tuple_size;
}

BlockNumber
GetFreespace(Relation rel,int request,BlockNumber limit)
{
    FreeSpace*  entry;
    char*       name = NameStr(rel->rd_rel->relname);
    BlockNumber check = InvalidBlockNumber;
    bool        allocate = false;
    int         recommend   = 0;
    int space = request;
	
    if (!inited) {
        elog(FATAL,"Freespace not initialized");
    }

    entry = FindFreespace(rel,NULL,true);	
    if ( entry ) {
        int p = 0;
        int run = 0;

        pthread_mutex_lock(&entry->accessor);
    
        while ( entry->extender != 0 ) {
            pthread_cond_wait(&entry->creator,&entry->accessor);
        }

        p = entry->pointer;
/*  this runs the length of a blob so that the full amount is covered by 
    the block allocation  
*/
        if ( space > MaxTupleSize ) {
            pthread_mutex_unlock(&entry->accessor);
            elog(ERROR,"requesting freespace greater than page size");
        }

        for ( ; p < entry->queuesize; p++) {
            run++;
            

	    if ( !entry->live[p] ) {
                if ( entry->pointer == p ) entry->pointer++;
                continue;
	    }
            
            if ( entry->tryblock[p] >= limit && entry->avail[p] > space ) break;
            
            if ( entry->cycles > 100 ) {
                if ( entry->misses[p]++ > 100 || entry->avail[p] < entry->min_request ) {
                    entry->live[p] = false;
                }
            }
        }
        if ( entry->min_request > request ) entry->min_request = request;
        if ( entry->max_request < request ) entry->max_request = request;
        
        if ( run < 0 ) entry->run = run;
        else entry->run = (entry->run + run) / 2;
 /*  this is a check to see if we are spending too much time looking through
  *  freespace.  IF after 100 cycles we are averaging (weighted) looking 
  * through more than 1/3rd of the freespace, advance the pointer one
  * and reset the counters
  */       
        if ( entry->active ) {
            if ( entry->cycles++ > 100 ) {
	    	if ( entry->run > (entry->queuesize-entry->pointer) / 2 ) {
			if ( entry->pointer < entry->queuesize ) {
				entry->pointer++;
			}
		}
	    }
            DTRACE_PROBE4(mtpg, freespace__reservation,RelationGetRelationName(rel),entry->queuesize,run,p);
        }
       
        if ( p == entry->queuesize ) {
                entry->extender = pthread_self();
                recommend = RecommendAllocation(rel,entry);
                allocate = true;
        } else {
            Size remove_space = 0;
            check = entry->tryblock[p];
            remove_space -= space;
            if ( entry->unused_pointers[p] == 0 ) {
                    remove_space -= sizeof(ItemIdData);
            } else {
                    entry->unused_pointers[p] -= 1;
            }
            entry->misses[p] = 0;
            entry->avail[p] -= remove_space;
            entry->total_available -= remove_space;
        }
/*  
    is another tuple of the same size can't fit, 
    ask for space allocation to hopefully have it available 
    at the next request
*/
/*
        if ( !allocate && entry->total_available < request  && !entry->extension_requested ) {
            entry->extension_requested = true;
            AddAllocateSpaceRequest(RelationGetRelationName(rel),GetDatabaseName(),rel->rd_id,GetDatabaseId());
        }	
 */           
        pthread_mutex_unlock(&entry->accessor);

        if ( allocate  ) {
             check = PerformAllocation(rel,entry,recommend);
        }
    }

    return check;
}

void 
DeactivateFreespace(Relation rel, BlockNumber blk,Size realspace)
{
	FreeSpace* entry = NULL;
	
	if ( !inited ) return;

 	entry = FindFreespace(rel,NULL,false);

	if ( entry ) {
		int p = 0;
		pthread_mutex_lock(&entry->accessor);
		for (p = entry->pointer;p<entry->queuesize;p++) {
			if ( entry->tryblock[p] == blk ) {
                                if ( entry->cycles > 100 && realspace < entry->min_request ) {
                                    entry->live[p] = false;
                                }
                                entry->total_available -= entry->avail[p];
                                entry->avail[p] = realspace;
                                entry->total_available += realspace;
				break;
			}
		}
		pthread_mutex_unlock(&entry->accessor);
	}
}

void PrintFreespaceMemory( ) 
{
	if ( IsDBWriter() ) {
		if ( print_freespace_memory ) {
			int total = 0;
			fprintf(stderr,"\n========== Freespace Memory ==========\n");
			total = MemoryContextStats(free_cxt);
			fprintf(stderr,"Total memory = %d\n",total);
			fprintf(stderr,"\n========== End Freespace Memory ==========\n");
			fflush(stderr);
			print_freespace_memory = false;
		}
	} else {
		print_freespace_memory = true;
	}
}

/*  rely on locking at the relation level to protect from 
    removing a referenced freespace
*/
int ForgetFreespace(Relation rel) {
	FreeKey tag;
	bool found;
        FreeSpace* entry;

        if ( !inited ) return 0;

	pthread_mutex_lock(&freespace_access);

	memset(&tag,0,sizeof(tag));
	tag.relid = rel->rd_lockInfo.lockRelId.relId;
	tag.dbid = rel->rd_lockInfo.lockRelId.dbId;

	entry = hash_search(freetable,(char*)&tag,HASH_REMOVE,&found);

        if ( !found ) {
            /*
            elog(NOTICE,"de-referencing unknown freespace %s-%s",RelationGetRelationName(rel),GetDatabaseName());
            */
        } else {
		pthread_cond_destroy(&entry->creator);
		pthread_mutex_destroy(&entry->accessor);
                MemoryContextDelete(entry->context);
        }

	pthread_mutex_unlock(&freespace_access);

        RemoveExtentForRelation(rel);

        return 0;
}


FreeSpace* FindFreespace(Relation rel,char* dbname,bool create) {

	FreeKey tag;
	bool	found;
	FreeSpace* entry;
	int type = ( create ) ? HASH_ENTER : HASH_FIND;
	
	if ( !inited ) return 0;

	memset(&tag,0,sizeof(tag));
	tag.relid = rel->rd_lockInfo.lockRelId.relId;
	tag.dbid = rel->rd_lockInfo.lockRelId.dbId;
	
	pthread_mutex_lock(&freespace_access);

	entry = (FreeSpace*)hash_search(freetable,(char*)&tag,type,&found);
	
	if ( found ) {
		pthread_mutex_unlock(&freespace_access);
		return entry;
 	} else if ( create ) {
                char*		db = ( dbname == NULL ) ? GetDatabaseName() : dbname;
		char mem_name[128];
		sprintf(mem_name,"FreespaceInstance-rel:%s-dbname:%s",RelationGetRelationName(rel),db);
		pthread_cond_init(&entry->creator,&process_cond_attr);
		pthread_mutex_init(&entry->accessor,&process_mutex_attr);
                entry->context = AllocSetContextCreate(freetable->hcxt,
						mem_name,
						ALLOCSET_DEFAULT_MINSIZE,
                                                ALLOCSET_DEFAULT_INITSIZE,
                                                ALLOCSET_DEFAULT_MAXSIZE);
/*  get an accurate count of blocks 
    all heap relations have their block count managed
    here
*/
               
		entry->relkind = rel->rd_rel->relkind;
                entry->queuesize = 0;
		entry->pointer = 0;
		entry->relsize = smgrnblocks(rel->rd_smgr);
		entry->extender = 0;
		entry->active = false;
                entry->min_tuple_size = 0;
                entry->max_tuple_size = 0;
		entry->ave_tuple_size = 0;
                entry->extent = 0;
                entry->extent_percentage = false;
                entry->live = NULL;
                entry->tryblock = NULL;
                entry->avail = NULL;
                entry->misses = NULL;
                entry->unused_pointers = NULL;

		pthread_mutex_unlock(&freespace_access);
                        
                if ( !rel->rd_myxactonly ) {
                    AddFreespaceScanRequest(RelationGetRelationName(rel),GetDatabaseName(),rel->rd_id,GetDatabaseId());
                }
                
		return entry;
	} else {
		pthread_mutex_unlock(&freespace_access);
                return NULL;
	}
}

BlockNumber
AllocateMoreSpace(Relation rel) {
    FreeSpace*  freespace = FindFreespace(rel,NULL,false);
    int recommend = 0;

    if (!inited) {
        elog(FATAL,"Freespace not initialized");
    }

/*  if not recommending a value, then the extender is not set and need to get an extension value  */
    pthread_mutex_lock(&freespace->accessor);
    if ( freespace->extender != 0 ) {
/*  forget it someone else is already extending the relation  */
        pthread_mutex_unlock(&freespace->accessor);
        return InvalidBlockNumber;
    }
    recommend = RecommendAllocation(rel,freespace);
    freespace->extender = pthread_self();
    pthread_mutex_unlock(&freespace->accessor);

    PerformAllocation(rel, freespace, recommend);
}

BlockNumber PerformAllocation(Relation rel, FreeSpace* freespace, int size) {
    BlockNumber     firstfree = InvalidBlockNumber;
    int create = AllocatePagesViaSmgr(rel, size);

    pthread_mutex_lock(&freespace->accessor);

    freespace->extension_requested = false;

    if ( create + freespace->relsize != rel->rd_nblocks ) {
        elog(FATAL,"file extension inconsistent");
    }

    if ( create > 0 ) {
        BlockNumber         blocks[create];
        Size                size[create];
        Size                total = 0;
        int                 pointers[create];
        int                 counter = 0;
        int                 oldsize,newsize;
        MemoryContext       old;
        /*        
        char* pool = ( IsPoolsweep() ) ? "true" : "false";

        elog(DEBUG,"Space Allocation: %s start size %d blocks, System: %s, allocated: %d blocks",
                RelationGetRelationName(rel),rel->rd_nblocks - create,
                pool,create);
        */
        for (counter = 0;counter < create; counter++ ) {
            blocks[counter] = freespace->relsize + counter;
            size[counter] = BLCKSZ - sizeof(PageHeaderData);
            pointers[counter] = 0;
            total += BLCKSZ - sizeof(PageHeaderData);
        }

        old = MemoryContextSwitchTo(freespace->context);

        oldsize = freespace->queuesize;
        newsize = freespace->queuesize + counter;
        
        freespace->live = repalloc(freespace->live,sizeof(bool) * newsize);
        freespace->tryblock = (BlockNumber*)repalloc(freespace->tryblock,sizeof(BlockNumber) * newsize);
        memcpy((freespace->tryblock + oldsize),blocks,sizeof(BlockNumber) * counter);
        freespace->avail = (Size*)repalloc(freespace->avail,sizeof(Size) * newsize);
        memcpy((freespace->avail + oldsize),size,sizeof(Size) * counter);
        freespace->misses = (int*)repalloc(freespace->misses,sizeof(int) * newsize);
        memset(freespace->misses + oldsize,0,sizeof(int) * (counter));
        freespace->unused_pointers = (int*)repalloc(freespace->unused_pointers,sizeof(int) * newsize);
        memcpy((freespace->unused_pointers + oldsize),pointers,sizeof(int) * counter);
        memset((freespace->live + oldsize),0xff,sizeof(bool) * (counter));
        
        freespace->queuesize = newsize;
         
        MemoryContextSwitchTo(old);

        freespace->active = true;
        freespace->relsize += create;
  /*      freespace->pointer = 0;   */
        freespace->extender = 0;
        freespace->total_available += total;

        pthread_cond_broadcast(&freespace->creator);

        firstfree = blocks[0];
    }

    pthread_mutex_unlock(&freespace->accessor);

    return firstfree;
}

int AllocatePagesViaSmgr(Relation rel,int create) {

    int test = rel->rd_nblocks;
    union {
	double align;
	char	data[BLCKSZ];
    } buffer;

    memset(buffer.data,0x00,BLCKSZ);

    PageInit((Page)buffer.data,BLCKSZ, 0);
    PageInsertChecksum((Page)buffer.data);

    rel->rd_nblocks = smgrextend(rel->rd_smgr,buffer.data, create);

    return create;
}

void    SetNextExtent(Relation rel,int blockcount, bool percent) {
    FreeSpace*  freespace = FindFreespace(rel,NULL,true);
    pthread_mutex_lock(&freespace->accessor);
    if ( blockcount <= 0 ) blockcount = 0;
    freespace->extent = blockcount;
    freespace->extent_percentage = percent;
    pthread_mutex_unlock(&freespace->accessor);

    SetExtentForRelation(rel,blockcount,percent);
}


long GetNextExtentFactor(Relation rel) {
    FreeSpace*  freespace = FindFreespace(rel,NULL,false);
    long next_extent = 1;
    
    if ( freespace != NULL ) {
        pthread_mutex_lock(&freespace->accessor);
        next_extent = RecommendAllocation(rel,freespace);
        pthread_mutex_unlock(&freespace->accessor);
    }
    return next_extent;
}

/*
 * RelationGetNumberOfBlocks
 *		Returns the buffer descriptor associated with a page in a relation.
 *
 * Note:
 *		XXX may fail for huge relations.
 *		XXX should be elsewhere.
 *		XXX maybe should be hidden
 */
BlockNumber
RelationGetNumberOfBlocks(Relation relation)
{
    BlockNumber  size = InvalidBlockNumber;

    if ( inited && 
        ( relation->rd_rel->relkind == RELKIND_RELATION || relation->rd_rel->relkind == RELKIND_UNCATALOGED ) ) {
	FreeSpace* freespace = FindFreespace(relation,NULL,false);
        
        if ( freespace == NULL ) {
            size = smgrnblocks(relation->rd_smgr);
        } else {
            pthread_mutex_lock(&freespace->accessor);
            size = freespace->relsize;
            pthread_mutex_unlock(&freespace->accessor);
        }
    } else {
        if (relation->rd_myxactonly) {
            size = relation->rd_nblocks;
        } else {
            size = smgrnblocks(relation->rd_smgr);
        }
    }

    return size;
}

int
RecommendAllocation(Relation rel,FreeSpace* freespace) {
    int create = 0;
    /*  assume freespace is already locked */
    double dead_per = ((double)freespace->last_dead_tuple_count /(double)freespace->last_live_tuple_count);

/*  if Bootstrap go one block at a time */
    if ( IsBootstrapProcessingMode() ) {
        return 1;
    }

    if ( freespace->extent == 0 ) {
/*  system relations should only be increased by 1 block, they are not accessed that much  */
/*  also, because Lookup does scans, double locking and deadlocks are possible if you try to lookup */
/*  extents for system relations */
        if ( IsSystemRelationName(RelationGetRelationName(rel)) || !LookupExtentForRelation(rel,freespace) ) {
            return 1;
        }
    }

    if ( freespace->extent_percentage ) {
        create = (int)(freespace->relsize * (((double)freespace->extent)/100.0));
    } else {
        create = freespace->extent;
    }
    
/*  introduce some sanity  */
    if ( create < 3 ) create = 3;
    if ( create > (NBuffers) ) create = (NBuffers) / 10;

    return create;
}

bool 
LookupExtentForRelation(Relation rel, FreeSpace* freespace) {
    if ( !IsNormalProcessingMode() ) {
        return false;
    } else {
        Relation erel;
        Relation irel;
        IndexScanDesc scan;
        ScanKeyData    skey;
        Buffer          release;
        bool         handled = false;

        erel = heap_openr("pg_extent", AccessShareLock);
        irel = index_openr("pg_extent_index");

        ScanKeyEntryInitialize(&skey,
                               (bits16) 0x0,
                               (AttrNumber) 1,
                               (RegProcedure) F_OIDEQ,
                  ObjectIdGetDatum(RelationGetRelid(rel)));
        scan = index_beginscan(irel, false, 1, &skey);    

        while (index_getnext(scan, ForwardScanDirection)) {
            HeapTupleData   tuple;
            bool isnull = false;
            tuple.t_self = scan->xs_ctup.t_self;

            if (heap_fetch(erel, SnapshotNow, &tuple, &release)) {
                freespace->extent = DatumGetUInt16(heap_getattr(&tuple,Anum_pg_extent_allocation,RelationGetDescr(erel),&isnull));
                freespace->extent_percentage = DatumGetChar(heap_getattr(&tuple,Anum_pg_extent_percentage,RelationGetDescr(erel),&isnull));
                ReleaseBuffer(erel,release);
                handled = true;
                break;
            }
        }

        if ( !handled ) {
            freespace->extent = 5;
            freespace->extent_percentage = true;
        }

        index_endscan(scan);

        index_close(irel);

        heap_close(erel, AccessShareLock);

        return true;
    }
}


void 
SetExtentForRelation(Relation rel, int amount,bool percentage) {
    if ( !IsNormalProcessingMode() ) {
        return;
    } else {
        Relation erel = heap_openr("pg_extent", RowExclusiveLock);
        Relation irel = index_openr("pg_extent_index");
        IndexScanDesc scan;
        ScanKeyData    skey;
        Buffer          release;
        HeapTuple   newtup = NULL;
        bool        set = false;

        ScanKeyEntryInitialize(&skey,
                               (bits16) 0x0,
                               (AttrNumber) 1,
                               (RegProcedure) F_OIDEQ,
                  ObjectIdGetDatum(RelationGetRelid(rel)));
        scan = index_beginscan(irel, false, 1, &skey);    

        while (index_getnext(scan, ForwardScanDirection)) {
            HeapTupleData   tuple;
            bool isnull = false;
            tuple.t_self = scan->xs_ctup.t_self;

            if (heap_fetch(erel, SnapshotNow, &tuple, &release)) {
                if ( amount <= 0 ) {
                    ReleaseBuffer(erel,release);
                    heap_delete(erel,&scan->xs_ctup.t_self,NULL,NULL);
                } else {
                    Datum values[Natts_pg_extent];
                    char replace[Natts_pg_extent];
                    char nulls[Natts_pg_extent];

                    values[1] = Int16GetDatum(amount);
                    values[2] = CharGetDatum(percentage);

                    nulls[0] = ' ';
                    nulls[1] = ' ';
                    nulls[2] = ' '; 

                    replace[0] = ' ';
                    replace[1] = 'r';
                    replace[2] = 'r'; 

                    newtup = heap_modifytuple(&tuple,erel,values,nulls,replace);
                    ReleaseBuffer(erel,release);

                    heap_update(erel,&newtup->t_self,newtup,NULL,NULL);
                }
                set = true;
                break;
            }
        } 
       
        if ( !set ) {
            Datum values[Natts_pg_extent];
            char nulls[Natts_pg_extent];

            values[0] = ObjectIdGetDatum(RelationGetRelid(rel));
            values[1] = Int16GetDatum(amount);
            values[2] = CharGetDatum(percentage);

            nulls[0] = ' ';
            nulls[1] = ' ';
            nulls[2] = ' ';   

            newtup = heap_formtuple(RelationGetDescr(erel),values,nulls);
            heap_insert(erel,newtup);
        }

        if ( HeapTupleIsValid(newtup) ) {
            if (RelationGetForm(erel)->relhasindex)
            {
                    Relation	idescs[1];
                    char*       names[] = {"pg_extent_index"};

                    CatalogOpenIndices(1, names, idescs);
                    CatalogIndexInsert(idescs, 1, erel, newtup);
                    CatalogCloseIndices(1, idescs);
            }
            heap_freetuple(newtup);
         }

        index_endscan(scan);

        index_close(irel);

        heap_close(erel, RowExclusiveLock);
    }
}

void
RemoveExtentForRelation(Relation rel) {
    if ( !IsNormalProcessingMode() ) {

    } else {
        Relation erel;
        Relation irel;
        IndexScanDesc scan;
        ScanKeyData    skey;
        Buffer          release;
        bool         handled = false;

        erel = heap_openr("pg_extent", RowExclusiveLock);
        irel = index_openr("pg_extent_index");

        ScanKeyEntryInitialize(&skey,
                               (bits16) 0x0,
                               (AttrNumber) 1,
                               (RegProcedure) F_OIDEQ,
                  ObjectIdGetDatum(RelationGetRelid(rel)));
        scan = index_beginscan(irel, false, 1, &skey);    

        while (index_getnext(scan, ForwardScanDirection)) {
            HeapTupleData   tuple;
            bool isnull = false;
            tuple.t_self = scan->xs_ctup.t_self;

            if (heap_fetch(erel, SnapshotNow, &tuple, &release)) {
                ReleaseBuffer(erel,release);
                heap_delete(erel,&scan->xs_ctup.t_self,NULL,NULL);
                handled = true;
                break;
            }
        }

        index_endscan(scan);

        index_close(irel);

        heap_close(erel, RowExclusiveLock);
    }
}

